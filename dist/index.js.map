{"version":3,"sources":["../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Function/dist/effect-Function.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Equivalence/dist/effect-Equivalence.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/GlobalValue/dist/effect-GlobalValue.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Predicate/dist/effect-Predicate.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Utils/dist/effect-Utils.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Hash/dist/effect-Hash.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Equal/dist/effect-Equal.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Inspectable/dist/effect-Inspectable.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Pipeable/dist/effect-Pipeable.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Data.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/effect.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Effectable.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Option.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Either.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Order/dist/effect-Order.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Number/dist/effect-Number.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Option/dist/effect-Option.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Either/dist/effect-Either.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/ReadonlyArray.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/ReadonlyRecord/dist/effect-ReadonlyRecord.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/ReadonlyArray/dist/effect-ReadonlyArray.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Chunk/dist/effect-Chunk.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Context.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Context/dist/effect-Context.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Differ/ContextPatch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/HashMap/config.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/HashMap/bitwise.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/HashMap/array.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Stack.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/HashMap/node.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/HashMap.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/HashSet.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/HashMap/dist/effect-HashMap.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/HashSet/dist/effect-HashSet.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Differ/HashSetPatch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/Differ.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Differ/dist/effect-Differ.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/MutableRef/dist/effect-MutableRef.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberId.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/FiberId/dist/effect-FiberId.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/List/dist/effect-List.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/blockedRequests.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/cause.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/cause.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/deferred.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/deferred.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/runtimeFlagsPatch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/runtimeFlags.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/RuntimeFlagsPatch/dist/effect-RuntimeFlagsPatch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/core.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Duration/dist/effect-Duration.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/timeout.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/clock.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/configError.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/configError.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/config.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/config.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/configProvider/pathPatch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/configProvider.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/defaultServices/console.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/random.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/tracer.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/defaultServices.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Clock/dist/effect-Clock.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberRefs.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/FiberRefs/dist/effect-FiberRefs.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberRefs/patch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/label.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/singleShotGen.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/LogLevel/dist/effect-LogLevel.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/logSpan.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/LogSpan/dist/effect-LogSpan.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/ref.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Ref/dist/effect-Ref.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/core-effect.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Exit/dist/effect-Exit.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/executionStrategy.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberStatus.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/FiberStatus/dist/effect-FiberStatus.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberMessage.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberScope.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiber.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Deferred/dist/effect-Deferred.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/ExecutionStrategy/dist/effect-ExecutionStrategy.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/FiberRefsPatch/dist/effect-FiberRefsPatch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/completedRequestMap.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/concurrency.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/logger.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/boundaries.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/keyType.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/key.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/state.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/hook.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/pair.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/MutableHashMap/dist/effect-MutableHashMap.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric/registry.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/metric.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/request.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/RedBlackTree/iterator.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/RedBlackTree/node.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/RedBlackTree.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/RedBlackTree/dist/effect-RedBlackTree.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/SortedSet/dist/effect-SortedSet.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/supervisor.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/supervisor/patch.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Scheduler/dist/effect-Scheduler.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/fiberRuntime.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/schedule/interval.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/ScheduleInterval/dist/effect-ScheduleInterval.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/schedule/intervals.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/ScheduleIntervals/dist/effect-ScheduleIntervals.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/schedule/decision.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/ScheduleDecision/dist/effect-ScheduleDecision.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/schedule.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/effect/circular.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Cause/dist/effect-Cause.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/layer.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Fiber/dist/effect-Fiber.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/runtime.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/synchronizedRef.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Scope/dist/effect-Scope.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/layer.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/MutableList/dist/effect-MutableList.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/MutableQueue/dist/effect-MutableQueue.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Effect/dist/effect-Effect.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Effectable/dist/effect-Effectable.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Data/dist/effect-Data.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/String/dist/effect-String.esm.js","../node_modules/.pnpm/@effect+schema@0.43.2_effect@2.0.0-next.48_fast-check@3.13.1/node_modules/@effect/schema/internal/common.esm.js","../node_modules/.pnpm/@effect+schema@0.43.2_effect@2.0.0-next.48_fast-check@3.13.1/node_modules/@effect/schema/AST/dist/effect-schema-AST.esm.js","../node_modules/.pnpm/@effect+schema@0.43.2_effect@2.0.0-next.48_fast-check@3.13.1/node_modules/@effect/schema/ParseResult/dist/effect-schema-ParseResult.esm.js","../node_modules/.pnpm/@effect+schema@0.43.2_effect@2.0.0-next.48_fast-check@3.13.1/node_modules/@effect/schema/TreeFormatter/dist/effect-schema-TreeFormatter.esm.js","../node_modules/.pnpm/@effect+schema@0.43.2_effect@2.0.0-next.48_fast-check@3.13.1/node_modules/@effect/schema/Parser/dist/effect-schema-Parser.esm.js","../node_modules/.pnpm/@effect+schema@0.43.2_effect@2.0.0-next.48_fast-check@3.13.1/node_modules/@effect/schema/Schema/dist/effect-schema-Schema.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/queue.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Queue/dist/effect-Queue.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Layer/dist/effect-Layer.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelChildExecutorDecision.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/childExecutorDecision.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/continuation.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/continuation.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelUpstreamPullStrategy.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/upstreamPullStrategy.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channel.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/core-stream.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelState.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/channelState.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/subexecutor.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelUpstreamPullRequest.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/upstreamPullRequest.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/channelExecutor.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelMergeDecision.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/mergeDecision.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelMergeState.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/mergeState.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/opCodes/channelMergeStrategy.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/mergeStrategy.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel/singleProducerAsyncInput.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/channel.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/internal/stream.esm.js","../node_modules/.pnpm/effect@2.0.0-next.48/node_modules/effect/Stream/dist/effect-Stream.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/FileSystem/dist/effect-platform-FileSystem.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/body-db8cfb3d.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/Http/Client/dist/effect-platform-Http-Client.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/Http/Method/dist/effect-platform-Http-Method.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/UrlParams-1286c728.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/clientError-c4e1466c.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/Headers-58b56a08.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/clientRequest-fe7578cf.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/Http/IncomingMessage/dist/effect-platform-Http-IncomingMessage.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/clientResponse-23f1ffca.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/Client-4f8f804b.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/Http/ClientRequest/dist/effect-platform-Http-ClientRequest.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/ClientRequest-27630c54.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/Http/ClientResponse/dist/effect-platform-Http-ClientResponse.esm.js","../node_modules/.pnpm/@effect+platform@0.22.0_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform/dist/ClientResponse-862f0a17.esm.js","../node_modules/.pnpm/@effect+platform-node@0.23.1_@effect+schema@0.43.2_effect@2.0.0-next.48/node_modules/@effect/platform-node/HttpClient/dist/effect-platform-node-HttpClient.esm.js","../src/internal/RuntimeClass.ts","../src/internal/OpenAi.ts","../src/index.ts"],"names":["id","isFunction","tag","max","keys","array","symbol","key","Structural","as","TypeId","CommonProto","left","right","make","number","mapInput","none","some","isOption","isNone","isSome","isLeft","isRight","match","fromIterable","head","last","isNonEmptyArray","index","reverse","empty","map","flatMap","flatten","b","next","copy","getEquivalence","unsafeGet","_equivalence","chunk","of","get","append","prepend","diff","headNonEmpty","sort","splitAt","tailNonEmpty","dedupe","reduce","context","_empty","service","merge","isContext","isTag","add","getOption","first","update","patch","combine","shift","mutate","i","hash","size","v","children","newValue","exists","isEmpty","remove","forEach","zero","makeImpl","set","beginMutation","endMutation","has","union","isHashSet","difference","variance","PatchProto","EmptyProto","AndThenProto","makeAndThen","differ","environment","hashSet","threadName","unsafeMake","toReadonlyArray","done","cons","appendAll","findFirst","parallel","sequential","par","seq","fiberId","cause","option","failure","onInterrupt","either","proto","effect","active","enabled","None","enable","disable","exclude","_continue","EffectTypeId","effectVariance","use","step","exit","resume","spanSymbol","die","fail","interrupt","interruptible","success","status","scope","options","zip","zipWith","ids","finalizer","list","unit","equals","nanos","micros","millis","seconds","minutes","hours","days","weeks","self","that","greaterThanOrEqualTo","path","OP_FAIL","split","prefix","values","text","string","min","buffer","clock","sleep","currentTimeMillis","forkAs","getOrDefault","updatedAs","OP_EMPTY","oldValue","fiberRefs","SingleShotGen","Error","Order","greaterThan","render","modify","getAndSet","filter","orElse","adapter","run","state","complete","summary","start","end","promise","all","failCause","succeed","zipRight","OP_SEQUENTIAL","OP_PARALLEL","runtimeFlags","running","suspended","isDone","yieldNow","join","never","_await","parallelN","unbounded","bounded","log","bigint","counter","histogram","sum","frequency","gauge","from","to","swap","insert","removeFirst","OP_AND_THEN","toSet","interruption","runtime","loop","process","blocked","f","strategy","cause2","OP_DONE","schedule","tuple","driver","isInterrupted","failureOrCause","OP_ZIP_WITH","unsafeFork","extend","layer","cached","fromEffect","suspend","capacity","length","remainder","poll","isEffect","dieMessage","gen","sync","catchAll","catchAllCause","catchTag","catchTags","ignore","try_","tryMap","tryPromise","uninterruptible","uninterruptibleMask","asUnit","mapError","acquireRelease","ensuring","fiberIdWith","forkDaemon","forkScoped","filterOrElse","filterOrFail","when","race","raceWith","tap","tapErrorCause","matchCause","matchCauseEffect","makeSemaphore","currentSpan","StructuralCommitPrototype","struct","tagged","type","decode","literal","encode","is","failures","go","transform","parse","ast","es","output","input","typeParameters","boolean","value","Class","pipe","take","mutable","offer","isShutdown","shutdown","toRuntime","OP_YIELD","OP_FOLD","OP_FROM_EFFECT","OP_SUSPEND","ChannelTypeId","channelVariance","failCauseSync","OP_EMIT","OP_READ","Done","onDone","exit2","Emit","onExit","childExecutor","emitSeparator","updatedChildExecutors","subexecutor","drain","closeLastSubstream","OP_STATE_DONE","onError","mergeAll","queue","pull","lastDone","$","unwrapScoped","both","scoped","StreamTypeId","stream","toPull","s","fromReadableStream","toReadableStream","file","formData","StreamImpl","mapEffect","retry","fromInput","setAll","toString","body","_","accept","acceptJson","appendUrl","appendUrlParam","appendUrlParams","basicAuth","bearerToken","del","fileBody","fileWebBody","formDataBody","jsonBody","post","prependUrl","put","schemaBody","setBody","setHeader","setHeaders","setMethod","setUrl","setUrlParam","setUrlParams","streamBody","textBody","uint8ArrayBody","unsafeJsonBody","updateUrl","urlParamsBody","fromWeb","schemaJson","schemaNoBody","createClient"],"mappings":"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","sourcesContent":["/**\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from 'effect/Predicate'\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isFunction = input => typeof input === \"function\";\n\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * @param arity - Either the arity of the uncurried function or a predicate\n *                which determines if the function is being used in a data-first\n *                or data-last style.\n * @param body - The definition of the uncurried function.\n *\n * @example\n * import { dual, pipe } from \"effect/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * export const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * export const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * @since 2.0.0\n */\nconst dual = function (arity, body) {\n  if (typeof arity === \"function\") {\n    return function () {\n      if (arity(arguments)) {\n        // @ts-expect-error\n        return body.apply(this, arguments);\n      }\n      return self => body(self, ...arguments);\n    };\n  }\n  switch (arity) {\n    case 0:\n      return body;\n    case 1:\n      return function (a) {\n        if (arguments.length >= 1) {\n          return body(a);\n        }\n        return function () {\n          return body(a);\n        };\n      };\n    case 2:\n      return function (a, b) {\n        if (arguments.length >= 2) {\n          return body(a, b);\n        }\n        return function (self) {\n          return body(self, a);\n        };\n      };\n    case 3:\n      return function (a, b, c) {\n        if (arguments.length >= 3) {\n          return body(a, b, c);\n        }\n        return function (self) {\n          return body(self, a, b);\n        };\n      };\n    case 4:\n      return function (a, b, c, d) {\n        if (arguments.length >= 4) {\n          return body(a, b, c, d);\n        }\n        return function (self) {\n          return body(self, a, b, c);\n        };\n      };\n    case 5:\n      return function (a, b, c, d, e) {\n        if (arguments.length >= 5) {\n          return body(a, b, c, d, e);\n        }\n        return function (self) {\n          return body(self, a, b, c, d);\n        };\n      };\n    default:\n      return function () {\n        if (arguments.length >= arity) {\n          // @ts-expect-error\n          return body.apply(this, arguments);\n        }\n        const args = arguments;\n        return function (self) {\n          return body(self, ...args);\n        };\n      };\n  }\n};\n/**\n * Apply a function to a given value.\n *\n * @param a - The value that the function will be applied to.\n * @param self - The function to be applied to a value.\n *\n * @example\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from 'effect/String'\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n *\n * @since 2.0.0\n */\nconst apply = a => self => self(a);\n\n/**\n * A lazy argument.\n *\n * @example\n * import { LazyArg, constant } from \"effect/Function\"\n *\n * export const constNull: LazyArg<null> = constant(null)\n *\n * @since 2.0.0\n */\n\n/**\n * @example\n * import { FunctionN } from \"effect/Function\"\n *\n * export const sum: FunctionN<[number, number], number> = (a, b) => a + b\n *\n * @since 2.0.0\n */\n\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @param a - The input argument.\n *\n * @example\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n *\n * @since 2.0.0\n */\nconst identity = a => a;\n\n/**\n * Casts the result to the specified type.\n *\n * @param a - The value to be casted to the target type.\n *\n * @example\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n *\n * @since 2.0.0\n */\nconst unsafeCoerce = identity;\n\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @param value - The constant value to be returned.\n *\n * @example\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 2.0.0\n */\nconst constant = value => () => value;\n\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n *\n * @since 2.0.0\n */\nconst constTrue = /*#__PURE__*/constant(true);\n\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n *\n * @since 2.0.0\n */\nconst constFalse = /*#__PURE__*/constant(false);\n\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 2.0.0\n */\nconst constNull = /*#__PURE__*/constant(null);\n\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n *\n * @since 2.0.0\n */\nconst constUndefined = /*#__PURE__*/constant(undefined);\n\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n *\n * @since 2.0.0\n */\nconst constVoid = constUndefined;\n\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @param f - A curried function that takes multiple arguments.\n *\n * @example\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n *\n * @since 2.0.0\n */\nconst flip = f => (...b) => (...a) => f(...a)(...b);\n\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @param ab - A function that maps from `A` to `B`.\n * @param bc - A function that maps from `B` to `C`.\n *\n * @example\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n *\n * @since 2.0.0\n */\nconst compose = /*#__PURE__*/dual(2, (ab, bc) => a => bc(ab(a)));\n\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */\nconst absurd = _ => {\n  throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n *\n * @since 2.0.0\n */\nconst tupled = f => a => f(...a);\n\n/**\n * Inverse function of `tupled`\n *\n * @example\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n *\n * @since 2.0.0\n */\nconst untupled = f => (...a) => f(a);\n\n/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * This is useful in combination with data-last functions as a simulation of methods:\n *\n * ```\n * as.map(f).filter(g) -> pipe(as, map(f), filter(g))\n * ```\n *\n * @example\n * import { pipe } from \"effect/Function\"\n *\n * const length = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n * const decrement = (n: number): number => n - 1\n *\n * assert.deepStrictEqual(pipe(length(\"hello\"), double, decrement), 9)\n *\n * @since 2.0.0\n */\n\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n    case 2:\n      return ab(a);\n    case 3:\n      return bc(ab(a));\n    case 4:\n      return cd(bc(ab(a)));\n    case 5:\n      return de(cd(bc(ab(a))));\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n    default:\n      {\n        let ret = arguments[0];\n        for (let i = 1; i < arguments.length; i++) {\n          ret = arguments[i](ret);\n        }\n        return ret;\n      }\n  }\n}\n\n/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * import { flow } from \"effect/Function\"\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n *\n * @since 2.0.0\n */\n\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n  return;\n}\n\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */\nconst hole = /*#__PURE__*/unsafeCoerce(absurd);\n\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @param _ - The first argument to be discarded.\n * @param b - The second argument to be returned.\n *\n * @example\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n *\n * @since 2.0.0\n */\nconst SK = (_, b) => b;\n\nexport { SK, absurd, apply, compose, constFalse, constNull, constTrue, constUndefined, constVoid, constant, dual, flip, flow, hole, identity, isFunction, pipe, tupled, unsafeCoerce, untupled };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\n\n/**\n * This module provides an implementation of the `Equivalence` type class, which defines a binary relation\n * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\n * These properties are also known in mathematics as an \"equivalence relation\".\n *\n * @since 2.0.0\n */\n\n/**\n * @category type class\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst make = isEquivalent => (self, that) => self === that || isEquivalent(self, that);\nconst isStrictEquivalent = (x, y) => x === y;\n\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst strict = () => isStrictEquivalent;\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst string = /*#__PURE__*/strict();\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst number = /*#__PURE__*/strict();\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst boolean = /*#__PURE__*/strict();\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst bigint = /*#__PURE__*/strict();\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst symbol = /*#__PURE__*/strict();\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combine = /*#__PURE__*/dual(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineMany = /*#__PURE__*/dual(2, (self, collection) => make((x, y) => {\n  if (!self(x, y)) {\n    return false;\n  }\n  for (const equivalence of collection) {\n    if (!equivalence(x, y)) {\n      return false;\n    }\n  }\n  return true;\n}));\nconst isAlwaysEquivalent = (_x, _y) => true;\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineAll = collection => combineMany(isAlwaysEquivalent, collection);\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => make((x, y) => self(f(x), f(y))));\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Date = /*#__PURE__*/mapInput(number, date => date.getTime());\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = /*#__PURE__*/dual(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst all = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const equivalence of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      if (!equivalence(x[collectionLength], y[collectionLength])) {\n        return false;\n      }\n      collectionLength++;\n    }\n    return true;\n  });\n};\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = (self, collection) => {\n  const equivalence = all(collection);\n  return make((x, y) => !self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));\n};\n\n/**\n * Similar to `Promise.all` but operates on `Equivalence`s.\n *\n * ```\n * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n * ```\n *\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst tuple = (...elements) => all(elements);\n\n/**\n * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst array = item => make((self, that) => {\n  if (self.length !== that.length) {\n    return false;\n  }\n  for (let i = 0; i < self.length; i++) {\n    const isEq = item(self[i], that[i]);\n    if (!isEq) {\n      return false;\n    }\n  }\n  return true;\n});\n\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst struct = fields => {\n  const keys = Object.keys(fields);\n  return make((self, that) => {\n    for (const key of keys) {\n      if (!fields[key](self[key], that[key])) {\n        return false;\n      }\n    }\n    return true;\n  });\n};\n\nexport { Date, all, array, bigint, boolean, combine, combineAll, combineMany, make, mapInput, number, product, productMany, strict, string, struct, symbol, tuple };\n","/**\n * @since 2.0.0\n */\nconst globalStoreId = /*#__PURE__*/Symbol.for(\"effect/GlobalValue/globalStoreId\");\nif (!(globalStoreId in globalThis)) {\n  globalThis[globalStoreId] = /*#__PURE__*/new Map();\n}\nconst globalStore = globalThis[globalStoreId];\n\n/**\n * @since 2.0.0\n */\nconst globalValue = (id, compute) => {\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute());\n  }\n  return globalStore.get(id);\n};\n\nexport { globalValue };\n","import { dual, isFunction as isFunction$1 } from '../../Function/dist/effect-Function.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * Given a `Predicate<A>` returns a `Predicate<B>`\n *\n * @param self - the `Predicate<A>` to be transformed to `Predicate<B>`.\n * @param f - a function to transform `B` to `A`.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n * import * as N from \"effect/Number\"\n *\n * const minLength3 = P.mapInput(N.greaterThan(2), (s: string) => s.length)\n *\n * assert.deepStrictEqual(minLength3(\"a\"), false)\n * assert.deepStrictEqual(minLength3(\"aa\"), false)\n * assert.deepStrictEqual(minLength3(\"aaa\"), true)\n * assert.deepStrictEqual(minLength3(\"aaaa\"), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => b => self(f(b)));\n\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n *\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isString = input => typeof input === \"string\";\n\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n *\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNumber = input => typeof input === \"number\";\n\n/**\n * Tests if a value is a `boolean`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n *\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isBoolean = input => typeof input === \"boolean\";\n\n/**\n * Tests if a value is a `bigint`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBigInt(1n), true)\n *\n * assert.deepStrictEqual(isBigInt(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isBigInt = input => typeof input === \"bigint\";\n\n/**\n * Tests if a value is a `symbol`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.deepStrictEqual(isSymbol(\"a\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isSymbol = input => typeof input === \"symbol\";\n\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n *\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isFunction = isFunction$1;\n\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUndefined(undefined), true)\n *\n * assert.deepStrictEqual(isUndefined(null), false)\n * assert.deepStrictEqual(isUndefined(\"undefined\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isUndefined = input => input === undefined;\n\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotUndefined(null), true)\n * assert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n *\n * assert.deepStrictEqual(isNotUndefined(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNotUndefined = input => input !== undefined;\n\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNull(null), true)\n *\n * assert.deepStrictEqual(isNull(undefined), false)\n * assert.deepStrictEqual(isNull(\"null\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNull = input => input === null;\n\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNull(undefined), true)\n * assert.deepStrictEqual(isNotNull(\"null\"), true)\n *\n * assert.deepStrictEqual(isNotNull(null), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNotNull = input => input !== null;\n\n/**\n * A guard that always fails.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNever(null), false)\n * assert.deepStrictEqual(isNever(undefined), false)\n * assert.deepStrictEqual(isNever({}), false)\n * assert.deepStrictEqual(isNever([]), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNever = _ => false;\n\n/**\n * A guard that always succeeds.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUnknown(null), true)\n * assert.deepStrictEqual(isUnknown(undefined), true)\n *\n * assert.deepStrictEqual(isUnknown({}), true)\n * assert.deepStrictEqual(isUnknown([]), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isUnknown = _ => true;\n\n/**\n * Tests if a value is an `object`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isObject({}), true)\n * assert.deepStrictEqual(isObject([]), true)\n *\n * assert.deepStrictEqual(isObject(null), false)\n * assert.deepStrictEqual(isObject(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isObject = input => typeof input === \"object\" && input != null || isFunction(input);\n\n/**\n * Tests if a value is an `object` with a property `_tag` that matches the given tag.\n *\n * @param input - The value to test.\n * @param tag - The tag to test for.\n *\n * @example\n * import { isTagged } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTagged(1, \"a\"), false)\n * assert.deepStrictEqual(isTagged(null, \"a\"), false)\n * assert.deepStrictEqual(isTagged({}, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\n * assert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isTagged = /*#__PURE__*/dual(2, (self, tag) => isObject(self) && \"_tag\" in self && self[\"_tag\"] === tag);\n\n/**\n * A guard that succeeds when the input is `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNullable(null), true)\n * assert.deepStrictEqual(isNullable(undefined), true)\n *\n * assert.deepStrictEqual(isNullable({}), false)\n * assert.deepStrictEqual(isNullable([]), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNullable = input => input === null || input === undefined;\n\n/**\n * A guard that succeeds when the input is not `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNullable({}), true)\n * assert.deepStrictEqual(isNotNullable([]), true)\n *\n * assert.deepStrictEqual(isNotNullable(null), false)\n * assert.deepStrictEqual(isNotNullable(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNotNullable = input => input !== null && input !== undefined;\n\n/**\n * A guard that succeeds when the input is an `Error`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isError } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isError(new Error()), true)\n *\n * assert.deepStrictEqual(isError(null), false)\n * assert.deepStrictEqual(isError({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isError = input => input instanceof Error;\n\n/**\n * A guard that succeeds when the input is a `Uint8Array`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.deepStrictEqual(isUint8Array(null), false)\n * assert.deepStrictEqual(isUint8Array({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isUint8Array = input => input instanceof Uint8Array;\n\n/**\n * A guard that succeeds when the input is a `Date`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isDate(new Date()), true)\n *\n * assert.deepStrictEqual(isDate(null), false)\n * assert.deepStrictEqual(isDate({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isDate = input => input instanceof Date;\n\n/**\n * A guard that succeeds when the input is an `Iterable`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isIterable([]), true)\n * assert.deepStrictEqual(isIterable(new Set()), true)\n *\n * assert.deepStrictEqual(isIterable(null), false)\n * assert.deepStrictEqual(isIterable({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isIterable = input => isObject(input) && Symbol.iterator in input;\n\n/**\n * A guard that succeeds when the input is a record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isRecord({}), true)\n * assert.deepStrictEqual(isRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isRecord([]), false)\n * assert.deepStrictEqual(isRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isRecord(null), false)\n * assert.deepStrictEqual(isRecord(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isRecord = input => isObject(input) && !Array.isArray(input);\n\n/**\n * A guard that succeeds when the input is a readonly record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isReadonlyRecord({}), true)\n * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isReadonlyRecord([]), false)\n * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isReadonlyRecord(null), false)\n * assert.deepStrictEqual(isReadonlyRecord(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isReadonlyRecord = isRecord;\n\n/**\n * @since 2.0.0\n */\nconst compose = /*#__PURE__*/dual(2, (ab, bc) => a => ab(a) && bc(a));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = (self, that) => ([a, b]) => self(a) && that(b);\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst all = collection => {\n  return as => {\n    let collectionIndex = 0;\n    for (const p of collection) {\n      if (collectionIndex >= as.length) {\n        break;\n      }\n      if (p(as[collectionIndex]) === false) {\n        return false;\n      }\n      collectionIndex++;\n    }\n    return true;\n  };\n};\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = (self, collection) => {\n  const rest = all(collection);\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail);\n};\n\n/**\n * Similar to `Promise.all` but operates on `Predicate`s.\n *\n * ```\n * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n * ```\n *\n * @since 2.0.0\n */\nconst tuple = (...elements) => all(elements);\n\n/**\n * @since 2.0.0\n */\nconst struct = fields => {\n  const keys = Object.keys(fields);\n  return a => {\n    for (const key of keys) {\n      if (!fields[key](a[key])) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n\n/**\n * Negates the result of a given predicate.\n *\n * @param self - A predicate.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n * import * as N from \"effect/Number\"\n *\n * const isPositive = P.not(N.lessThan(0))\n *\n * assert.deepStrictEqual(isPositive(-1), false)\n * assert.deepStrictEqual(isPositive(0), true)\n * assert.deepStrictEqual(isPositive(1), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst not = self => a => !self(a);\n\n/**\n * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n * import * as N from \"effect/Number\"\n *\n * const nonZero = P.or(N.lessThan(0), N.greaterThan(0))\n *\n * assert.deepStrictEqual(nonZero(-1), true)\n * assert.deepStrictEqual(nonZero(0), false)\n * assert.deepStrictEqual(nonZero(1), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst or = /*#__PURE__*/dual(2, (self, that) => a => self(a) || that(a));\n\n/**\n * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n *\n * const minLength = (n: number) => (s: string) => s.length >= n\n * const maxLength = (n: number) => (s: string) => s.length <= n\n *\n * const length = (n: number) => P.and(minLength(n), maxLength(n))\n *\n * assert.deepStrictEqual(length(2)(\"aa\"), true)\n * assert.deepStrictEqual(length(2)(\"a\"), false)\n * assert.deepStrictEqual(length(2)(\"aaa\"), false)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst and = /*#__PURE__*/dual(2, (self, that) => a => self(a) && that(a));\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst xor = /*#__PURE__*/dual(2, (self, that) => a => self(a) !== that(a));\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst eqv = /*#__PURE__*/dual(2, (self, that) => a => self(a) === that(a));\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst implies = /*#__PURE__*/dual(2, (self, that) => a => self(a) ? that(a) : true);\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst nor = /*#__PURE__*/dual(2, (self, that) => a => !(self(a) || that(a)));\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst nand = /*#__PURE__*/dual(2, (self, that) => a => !(self(a) && that(a)));\n\n/**\n * @category elements\n * @since 2.0.0\n */\nconst every = collection => a => {\n  for (const p of collection) {\n    if (!p(a)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * @category elements\n * @since 2.0.0\n */\nconst some = collection => a => {\n  for (const p of collection) {\n    if (p(a)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport { all, and, compose, eqv, every, implies, isBigInt, isBoolean, isDate, isError, isFunction, isIterable, isNever, isNotNull, isNotNullable, isNotUndefined, isNull, isNullable, isNumber, isObject, isReadonlyRecord, isRecord, isString, isSymbol, isTagged, isUint8Array, isUndefined, isUnknown, mapInput, nand, nor, not, or, product, productMany, some, struct, tuple, xor };\n","import { identity } from '../../Function/dist/effect-Function.esm.js';\nimport { isNullable } from '../../Predicate/dist/effect-Predicate.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nconst GenKindTypeId = /*#__PURE__*/Symbol.for(\"effect/Gen/GenKind\");\n\n/**\n * @category symbols\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nclass GenKindImpl {\n  constructor(\n  /**\n   * @since 2.0.0\n   */\n  value) {\n    this.value = value;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _F() {\n    return identity;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _R() {\n    return _ => _;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _O() {\n    return _ => _;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _E() {\n    return _ => _;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  [GenKindTypeId] = GenKindTypeId;\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this);\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nclass SingleShotGen {\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  throw(e) {\n    throw e;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst makeGenKind = kind => new GenKindImpl(kind);\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category adapters\n * @since 2.0.0\n */\nconst adapter = () =>\n// @ts-expect-error\nfunction () {\n  let x = arguments[0];\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x);\n  }\n  return new GenKindImpl(x);\n};\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n\n/**\n * @category model\n * @since 2.0.0\n */\n\n/**\n * @category model\n * @since 2.0.0\n */\n\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */\nclass PCGRandom {\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * @param seed - The low 32 bits of the seed (0 is used for high 32 bits).\n   *\n   * @memberOf PCGRandom\n   */\n\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * @param seedHi - The high 32 bits of the seed.\n   * @param seedLo - The low 32 bits of the seed.\n   * @param inc - The low 32 bits of the incrementer (0 is used for high 32 bits).\n   *\n   * @memberOf PCGRandom\n   */\n\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * @param seedHi - The high 32 bits of the seed.\n   * @param seedLo - The low 32 bits of the seed.\n   * @param incHi - The high 32 bits of the incrementer.\n   * @param incLo - The low 32 bits of the incrementer.\n   *\n   * @memberOf PCGRandom\n   */\n\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if (isNullable(seedLo) && isNullable(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if (isNullable(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if (isNullable(incLo) && isNullable(incHi)) {\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if (isNullable(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */\n  integer(max) {\n    if (!max) {\n      return this._next();\n    }\n    max = max >>> 0;\n    if ((max & max - 1) === 0) {\n      return this._next() & max - 1; // fast path for power of 2\n    }\n\n    let num = 0;\n    const skew = (-max >>> 0) % max >>> 0;\n    for (num = this._next(); num < skew; num = this._next()) {\n      // this loop will rarely execute more than twice,\n      // and is intentionally empty\n    }\n    return num % max;\n  }\n\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n\nexport { GenKindImpl, GenKindTypeId, PCGRandom, SingleShotGen, adapter, makeGenKind };\n","import { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { PCGRandom } from '../../Utils/dist/effect-Utils.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/** @internal */\nconst randomHashCache = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Hash/randomHashCache\"), () => new WeakMap());\n/** @internal */\nconst pcgr = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Hash/pcgr\"), () => new PCGRandom());\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst symbol = /*#__PURE__*/Symbol.for(\"effect/Hash\");\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst hash = self => {\n  switch (typeof self) {\n    case \"number\":\n      {\n        return number(self);\n      }\n    case \"bigint\":\n      {\n        return string(self.toString(10));\n      }\n    case \"boolean\":\n      {\n        return string(String(self));\n      }\n    case \"symbol\":\n      {\n        return string(String(self));\n      }\n    case \"string\":\n      {\n        return string(self);\n      }\n    case \"undefined\":\n      {\n        return string(\"undefined\");\n      }\n    case \"function\":\n    case \"object\":\n      {\n        if (self === null) {\n          return string(\"null\");\n        }\n        if (isHash(self)) {\n          return self[symbol]();\n        } else {\n          return random(self);\n        }\n      }\n    default:\n      {\n        throw new Error(\"Bug in Equal.hash\");\n      }\n  }\n};\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst random = self => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(pcgr.integer(Number.MAX_SAFE_INTEGER)));\n  }\n  return randomHashCache.get(self);\n};\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst combine = b => self => self * 53 ^ b;\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;\n\n/**\n * @since 2.0.0\n * @category guards\n */\nconst isHash = u => typeof u === \"object\" && u !== null && symbol in u;\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst number = n => {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  let h = n | 0;\n  if (h !== n) {\n    h ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff;\n  }\n  return optimize(n);\n};\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst string = str => {\n  let h = 5381,\n    i = str.length;\n  while (i) {\n    h = h * 33 ^ str.charCodeAt(--i);\n  }\n  return optimize(h);\n};\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst structureKeys = (o, keys) => {\n  let h = 12289;\n  for (let i = 0; i < keys.length; i++) {\n    h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));\n  }\n  return optimize(h);\n};\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst structure = o => structureKeys(o, Object.keys(o));\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst array = arr => {\n  let h = 6151;\n  for (let i = 0; i < arr.length; i++) {\n    h = pipe(h, combine(hash(arr[i])));\n  }\n  return optimize(h);\n};\n\nexport { array, combine, hash, isHash, number, optimize, random, string, structure, structureKeys, symbol };\n","import { hash } from '../../Hash/dist/effect-Hash.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst symbol = /*#__PURE__*/Symbol.for(\"effect/Equal\");\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category equality\n */\n\nfunction equals() {\n  if (arguments.length === 1) {\n    return self => compareBoth(self, arguments[0]);\n  }\n  return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n  if (self === that) {\n    return true;\n  }\n  const selfType = typeof self;\n  if (selfType !== typeof that) {\n    return false;\n  }\n  if ((selfType === \"object\" || selfType === \"function\") && self !== null && that !== null) {\n    if (isEqual(self) && isEqual(that)) {\n      return hash(self) === hash(that) && self[symbol](that);\n    }\n  }\n  return false;\n}\n\n/**\n * @since 2.0.0\n * @category guards\n */\nconst isEqual = u => typeof u === \"object\" && u !== null && symbol in u;\n\n/**\n * @since 2.0.0\n * @category instances\n */\nconst equivalence = () => (self, that) => equals(self, that);\n\nexport { equals, equivalence, isEqual, symbol };\n","/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst NodeInspectSymbol = /*#__PURE__*/Symbol.for(\"nodejs.util.inspect.custom\");\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\nconst toJSON = x => {\n  if (typeof x === \"object\" && x !== null && \"toJSON\" in x && typeof x[\"toJSON\"] === \"function\" && x[\"toJSON\"].length === 0) {\n    return x.toJSON();\n  } else if (Array.isArray(x)) {\n    return x.map(toJSON);\n  }\n  return x;\n};\n\n/**\n * @since 2.0.0\n */\nconst toString = x => JSON.stringify(x, null, 2);\n\nexport { NodeInspectSymbol, toJSON, toString };\n","/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\nconst pipeArguments = (self, args) => {\n  switch (args.length) {\n    case 1:\n      return args[0](self);\n    case 2:\n      return args[1](args[0](self));\n    case 3:\n      return args[2](args[1](args[0](self)));\n    case 4:\n      return args[3](args[2](args[1](args[0](self))));\n    case 5:\n      return args[4](args[3](args[2](args[1](args[0](self)))));\n    case 6:\n      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));\n    case 7:\n      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));\n    case 8:\n      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));\n    case 9:\n      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));\n    default:\n      {\n        let ret = self;\n        for (let i = 0, len = args.length; i < len; i++) {\n          ret = args[i](ret);\n        }\n        return ret;\n      }\n  }\n};\n\nexport { pipeArguments };\n","import { symbol as symbol$1, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { symbol, array, structure } from '../Hash/dist/effect-Hash.esm.js';\n\n/** @internal */\nconst ArrayProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(Array.prototype), {\n  [symbol]() {\n    return array(this);\n  },\n  [symbol$1](that) {\n    if (Array.isArray(that) && this.length === that.length) {\n      return this.every((v, i) => equals(v, that[i]));\n    } else {\n      return false;\n    }\n  }\n});\n\n/** @internal */\nconst StructProto = {\n  [symbol]() {\n    return structure(this);\n  },\n  [symbol$1](that) {\n    const selfKeys = Object.keys(this);\n    const thatKeys = Object.keys(that);\n    if (selfKeys.length !== thatKeys.length) {\n      return false;\n    }\n    for (const key of selfKeys) {\n      if (!(key in that && equals(this[key], that[key]))) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\n/** @internal */\nconst Structural = /*#__PURE__*/function () {\n  function Structural(args) {\n    if (args) {\n      Object.assign(this, args);\n    }\n  }\n  Structural.prototype = StructProto;\n  return Structural;\n}();\n\n/** @internal */\nconst struct = as => Object.assign(Object.create(StructProto), as);\n\nexport { ArrayProto, StructProto, Structural, struct };\n","/** @internal */\n\n/** @internal */\nconst OP_ASYNC = \"Async\";\n\n/** @internal */\n\n/** @internal */\nconst OP_COMMIT = \"Commit\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FAILURE = \"Failure\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ON_FAILURE = \"OnFailure\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ON_SUCCESS = \"OnSuccess\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SUCCESS = \"Success\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SYNC = \"Sync\";\n\n/** @internal */\nconst OP_TAG = \"Tag\";\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\";\n\n/** @internal */\n\n/** @internal */\nconst OP_WHILE = \"While\";\n\n/** @internal */\n\n/** @internal */\nconst OP_WITH_RUNTIME = \"WithRuntime\";\n\n/** @internal */\n\n/** @internal */\nconst OP_YIELD = \"Yield\";\n\n/** @internal */\n\n/** @internal */\nconst OP_REVERT_FLAGS = \"RevertFlags\";\n\nexport { OP_ASYNC, OP_COMMIT, OP_FAILURE, OP_ON_FAILURE, OP_ON_SUCCESS, OP_ON_SUCCESS_AND_FAILURE, OP_REVERT_FLAGS, OP_SUCCESS, OP_SYNC, OP_TAG, OP_UPDATE_RUNTIME_FLAGS, OP_WHILE, OP_WITH_RUNTIME, OP_YIELD };\n","import { symbol } from '../Equal/dist/effect-Equal.esm.js';\nimport { symbol as symbol$1, random } from '../Hash/dist/effect-Hash.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { Structural } from './Data.esm.js';\nimport { OP_COMMIT } from './opCodes/effect.esm.js';\n\n/** @internal */\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"effect/Effect\");\n\n/** @internal */\nconst StreamTypeId = /*#__PURE__*/Symbol.for(\"effect/Stream\");\n\n/** @internal */\nconst SinkTypeId = /*#__PURE__*/Symbol.for(\"effect/Sink\");\n\n/** @internal */\nconst ChannelTypeId = /*#__PURE__*/Symbol.for(\"effect/Channel\");\n\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\nconst sinkVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _In: _ => _,\n  _L: _ => _,\n  _Z: _ => _\n};\n\n/** @internal */\nconst channelVariance = {\n  _Env: _ => _,\n  _InErr: _ => _,\n  _InElem: _ => _,\n  _InDone: _ => _,\n  _OutErr: _ => _,\n  _OutElem: _ => _,\n  _OutDone: _ => _\n};\n\n/** @internal */\nconst EffectPrototype = {\n  [EffectTypeId]: effectVariance,\n  [StreamTypeId]: effectVariance,\n  [SinkTypeId]: sinkVariance,\n  [ChannelTypeId]: channelVariance,\n  [symbol](that) {\n    return this === that;\n  },\n  [symbol$1]() {\n    return random(this);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst CommitPrototype = {\n  ...EffectPrototype,\n  _op: OP_COMMIT\n};\n\n/** @internal */\nconst StructuralCommitPrototype = {\n  ...CommitPrototype,\n  ...Structural.prototype\n};\n\n/** @internal */\nconst Base = /*#__PURE__*/function () {\n  function Base() {}\n  Base.prototype = CommitPrototype;\n  return Base;\n}();\n\n/** @internal */\nconst StructuralBase = /*#__PURE__*/function () {\n  function Base() {}\n  Base.prototype = StructuralCommitPrototype;\n  return Base;\n}();\n\nexport { Base, ChannelTypeId, CommitPrototype, EffectPrototype, EffectTypeId, SinkTypeId, StreamTypeId, StructuralBase, StructuralCommitPrototype, channelVariance, effectVariance, sinkVariance };\n","import { symbol, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { symbol as symbol$1, combine, hash } from '../Hash/dist/effect-Hash.esm.js';\nimport { NodeInspectSymbol, toString, toJSON } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { EffectPrototype } from './Effectable.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Option\");\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _A: _ => _\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return toString(this.toJSON());\n  }\n};\nconst SomeProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Some\",\n  _op: \"Some\",\n  [symbol](that) {\n    return isOption(that) && isSome(that) && equals(that.value, this.value);\n  },\n  [symbol$1]() {\n    return combine(hash(this._tag))(hash(this.value));\n  },\n  toJSON() {\n    return {\n      _id: \"Option\",\n      _tag: this._tag,\n      value: toJSON(this.value)\n    };\n  }\n});\nconst NoneProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"None\",\n  _op: \"None\",\n  [symbol](that) {\n    return isOption(that) && isNone(that);\n  },\n  [symbol$1]() {\n    return combine(hash(this._tag));\n  },\n  toJSON() {\n    return {\n      _id: \"Option\",\n      _tag: this._tag\n    };\n  }\n});\n\n/** @internal */\nconst isOption = input => typeof input === \"object\" && input != null && TypeId in input;\n\n/** @internal */\nconst isNone = fa => fa._tag === \"None\";\n\n/** @internal */\nconst isSome = fa => fa._tag === \"Some\";\n\n/** @internal */\nconst none = /*#__PURE__*/Object.create(NoneProto);\n\n/** @internal */\nconst some = value => {\n  const a = Object.create(SomeProto);\n  a.value = value;\n  return a;\n};\n\nexport { isNone, isOption, isSome, none, some };\n","import { symbol, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../Function/dist/effect-Function.esm.js';\nimport { symbol as symbol$1, combine, hash } from '../Hash/dist/effect-Hash.esm.js';\nimport { NodeInspectSymbol, toString, toJSON } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { none, some, isNone } from './Option.esm.js';\nimport { EffectPrototype } from './Effectable.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @internal\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Either\");\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _A: _ => _\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return toString(this.toJSON());\n  }\n};\nconst RightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Right\",\n  _op: \"Right\",\n  [symbol](that) {\n    return isEither(that) && isRight(that) && equals(that.right, this.right);\n  },\n  [symbol$1]() {\n    return combine(hash(this._tag))(hash(this.right));\n  },\n  toJSON() {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      right: toJSON(this.right)\n    };\n  }\n});\nconst LeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Left\",\n  _op: \"Left\",\n  [symbol](that) {\n    return isEither(that) && isLeft(that) && equals(that.left, this.left);\n  },\n  [symbol$1]() {\n    return combine(hash(this._tag))(hash(this.left));\n  },\n  toJSON() {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      left: toJSON(this.left)\n    };\n  }\n});\n\n/** @internal */\nconst isEither = input => typeof input === \"object\" && input != null && TypeId in input;\n\n/** @internal */\nconst isLeft = ma => ma._tag === \"Left\";\n\n/** @internal */\nconst isRight = ma => ma._tag === \"Right\";\n\n/** @internal */\nconst left = left => {\n  const a = Object.create(LeftProto);\n  a.left = left;\n  return a;\n};\n\n/** @internal */\nconst right = right => {\n  const a = Object.create(RightProto);\n  a.right = right;\n  return a;\n};\n\n/** @internal */\nconst getLeft = self => isRight(self) ? none : some(self.left);\n\n/** @internal */\nconst getRight = self => isLeft(self) ? none : some(self.right);\n\n/** @internal */\nconst fromOption = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));\n\nexport { TypeId, fromOption, getLeft, getRight, isEither, isLeft, isRight, left, right };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category type class\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst make = compare => (self, that) => self === that ? 0 : compare(self, that);\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst string = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst number = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst boolean = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst bigint = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n\n/**\n * @since 2.0.0\n */\nconst reverse = O => make((self, that) => O(that, self));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combine = /*#__PURE__*/dual(2, (self, that) => make((a1, a2) => {\n  const out = self(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  return that(a1, a2);\n}));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineMany = /*#__PURE__*/dual(2, (self, collection) => make((a1, a2) => {\n  let out = self(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  for (const O of collection) {\n    out = O(a1, a2);\n    if (out !== 0) {\n      return out;\n    }\n  }\n  return out;\n}));\n\n/**\n * @since 2.0.0\n */\nconst empty = () => make(() => 0);\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineAll = collection => combineMany(empty(), collection);\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => make((b1, b2) => self(f(b1), f(b2))));\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Date = /*#__PURE__*/mapInput(number, date => date.getTime());\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = /*#__PURE__*/dual(2, (self, that) => make(([xa, xb], [ya, yb]) => {\n  const o = self(xa, ya);\n  return o !== 0 ? o : that(xb, yb);\n}));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst all = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const O of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      const o = O(x[collectionLength], y[collectionLength]);\n      if (o !== 0) {\n        return o;\n      }\n      collectionLength++;\n    }\n    return 0;\n  });\n};\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = /*#__PURE__*/dual(2, (self, collection) => {\n  const O = all(collection);\n  return make((x, y) => {\n    const o = self(x[0], y[0]);\n    return o !== 0 ? o : O(x.slice(1), y.slice(1));\n  });\n});\n\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst tuple = (...elements) => all(elements);\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst array = O => make((self, that) => {\n  const aLen = self.length;\n  const bLen = that.length;\n  const len = Math.min(aLen, bLen);\n  for (let i = 0; i < len; i++) {\n    const o = O(self[i], that[i]);\n    if (o !== 0) {\n      return o;\n    }\n  }\n  return number(aLen, bLen);\n});\n\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst struct = fields => {\n  const keys = Object.keys(fields);\n  return make((self, that) => {\n    for (const key of keys) {\n      const o = fields[key](self[key], that[key]);\n      if (o !== 0) {\n        return o;\n      }\n    }\n    return 0;\n  });\n};\n\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 2.0.0\n */\nconst lessThan = O => dual(2, (self, that) => O(self, that) === -1);\n\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 2.0.0\n */\nconst greaterThan = O => dual(2, (self, that) => O(self, that) === 1);\n\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 2.0.0\n */\nconst lessThanOrEqualTo = O => dual(2, (self, that) => O(self, that) !== 1);\n\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 2.0.0\n */\nconst greaterThanOrEqualTo = O => dual(2, (self, that) => O(self, that) !== -1);\n\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nconst min = O => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);\n\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nconst max = O => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);\n\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @since 2.0.0\n */\nconst clamp = O => dual(3, (self, minimum, maximum) => min(O)(maximum, max(O)(minimum, self)));\n\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 2.0.0\n */\nconst between = O => dual(3, (self, minimum, maximum) => !lessThan(O)(self, minimum) && !greaterThan(O)(self, maximum));\n\nexport { Date, all, array, between, bigint, boolean, clamp, combine, combineAll, combineMany, empty, greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo, make, mapInput, max, min, number, product, productMany, reverse, string, struct, tuple };\n","import { number } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { number as number$1, lessThan as lessThan$1, lessThanOrEqualTo as lessThanOrEqualTo$1, greaterThan as greaterThan$1, greaterThanOrEqualTo as greaterThanOrEqualTo$1, between as between$1, clamp as clamp$1, min as min$1, max as max$1 } from '../../Order/dist/effect-Order.esm.js';\nimport { isNumber as isNumber$1 } from '../../Predicate/dist/effect-Predicate.esm.js';\n\n/**\n * This module provides utility functions and type class instances for working with the `number` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @since 2.0.0\n */\n\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from 'effect/Number'\n *\n * assert.deepStrictEqual(isNumber(2), true)\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNumber = isNumber$1;\n\n/**\n * Provides an addition operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { sum } from 'effect/Number'\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n *\n * @category math\n * @since 2.0.0\n */\nconst sum = /*#__PURE__*/dual(2, (self, that) => self + that);\n\n/**\n * Provides a multiplication operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { multiply } from 'effect/Number'\n *\n * assert.deepStrictEqual(multiply(2, 3), 6)\n *\n * @category math\n * @since 2.0.0\n */\nconst multiply = /*#__PURE__*/dual(2, (self, that) => self * that);\n\n/**\n * Provides a subtraction operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { subtract } from 'effect/Number'\n *\n * assert.deepStrictEqual(subtract(2, 3), -1)\n *\n * @category math\n * @since 2.0.0\n */\nconst subtract = /*#__PURE__*/dual(2, (self, that) => self - that);\n\n/**\n * Provides a division operation on `number`s.\n *\n * @param self - The dividend operand.\n * @param that - The divisor operand.\n *\n * @example\n * import { divide } from 'effect/Number'\n *\n * assert.deepStrictEqual(divide(6, 3), 2)\n *\n * @category math\n * @since 2.0.0\n */\nconst divide = /*#__PURE__*/dual(2, (self, that) => self / that);\n\n/**\n * Returns the result of adding `1` to a given number.\n *\n * @param n - A `number` to be incremented.\n *\n * @example\n * import { increment } from 'effect/Number'\n *\n * assert.deepStrictEqual(increment(2), 3)\n *\n * @category math\n * @since 2.0.0\n */\nconst increment = n => n + 1;\n\n/**\n * Decrements a number by `1`.\n *\n * @param n - A `number` to be decremented.\n *\n * @example\n * import { decrement } from 'effect/Number'\n *\n * assert.deepStrictEqual(decrement(3), 2)\n *\n * @category math\n * @since 2.0.0\n */\nconst decrement = n => n - 1;\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Equivalence = number;\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Order = number$1;\n\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { lessThan } from 'effect/Number'\n *\n * assert.deepStrictEqual(lessThan(2, 3), true)\n * assert.deepStrictEqual(lessThan(3, 3), false)\n * assert.deepStrictEqual(lessThan(4, 3), false)\n *\n * @category predicates\n * @since 2.0.0\n */\nconst lessThan = /*#__PURE__*/lessThan$1(Order);\n\n/**\n * Returns a function that checks if a given `number` is less than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { lessThanOrEqualTo } from 'effect/Number'\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n *\n * @category predicates\n * @since 2.0.0\n */\nconst lessThanOrEqualTo = /*#__PURE__*/lessThanOrEqualTo$1(Order);\n\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { greaterThan } from 'effect/Number'\n *\n * assert.deepStrictEqual(greaterThan(2, 3), false)\n * assert.deepStrictEqual(greaterThan(3, 3), false)\n * assert.deepStrictEqual(greaterThan(4, 3), true)\n *\n * @category predicates\n * @since 2.0.0\n */\nconst greaterThan = /*#__PURE__*/greaterThan$1(Order);\n\n/**\n * Returns a function that checks if a given `number` is greater than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { greaterThanOrEqualTo } from 'effect/Number'\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n *\n * @category predicates\n * @since 2.0.0\n */\nconst greaterThanOrEqualTo = /*#__PURE__*/greaterThanOrEqualTo$1(Order);\n\n/**\n * Checks if a `number` is between a `minimum` and `maximum` value (inclusive).\n *\n * @param self - The `number` to check.\n * @param minimum - The `minimum` value to check.\n * @param maximum - The `maximum` value to check.\n *\n * @example\n * import { between } from 'effect/Number'\n *\n * assert.deepStrictEqual(between(0, 5)(3), true)\n * assert.deepStrictEqual(between(0, 5)(-1), false)\n * assert.deepStrictEqual(between(0, 5)(6), false)\n *\n * @category predicates\n * @since 2.0.0\n */\nconst between = /*#__PURE__*/between$1(Order);\n\n/**\n * Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `number`.\n *\n * @param self - The `number` to be clamped.\n * @param minimum - The lower end of the range.\n * @param maximum - The upper end of the range.\n *\n * @example\n * import { clamp } from 'effect/Number'\n *\n * assert.deepStrictEqual(clamp(0, 5)(3), 3)\n * assert.deepStrictEqual(clamp(0, 5)(-1), 0)\n * assert.deepStrictEqual(clamp(0, 5)(6), 5)\n *\n * @since 2.0.0\n */\nconst clamp = /*#__PURE__*/clamp$1(Order);\n\n/**\n * Returns the minimum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { min } from 'effect/Number'\n *\n * assert.deepStrictEqual(min(2, 3), 2)\n *\n * @since 2.0.0\n */\nconst min = /*#__PURE__*/min$1(Order);\n\n/**\n * Returns the maximum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { max } from 'effect/Number'\n *\n * assert.deepStrictEqual(max(2, 3), 3)\n *\n * @since 2.0.0\n */\nconst max = /*#__PURE__*/max$1(Order);\n\n/**\n * Determines the sign of a given `number`.\n *\n * @param n - The `number` to determine the sign of.\n *\n * @example\n * import { sign } from 'effect/Number'\n *\n * assert.deepStrictEqual(sign(-5), -1)\n * assert.deepStrictEqual(sign(0), 0)\n * assert.deepStrictEqual(sign(5), 1)\n *\n * @category math\n * @since 2.0.0\n */\nconst sign = n => Order(n, 0);\n\n/**\n * Takes an `Iterable` of `number`s and returns their sum as a single `number`.\n *\n * @param collection - The collection of `number`s to sum.\n *\n * @example\n * import { sumAll } from 'effect/Number'\n *\n * assert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n *\n * @category math\n * @since 2.0.0\n */\nconst sumAll = collection => {\n  let out = 0;\n  for (const n of collection) {\n    out += n;\n  }\n  return out;\n};\n\n/**\n * Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.\n *\n * @param collection - The collection of `number`s to multiply.\n *\n * @example\n * import { multiplyAll } from 'effect/Number'\n *\n * assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n *\n * @category math\n * @since 2.0.0\n */\nconst multiplyAll = collection => {\n  let out = 1;\n  for (const n of collection) {\n    if (n === 0) {\n      return 0;\n    }\n    out *= n;\n  }\n  return out;\n};\n\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * It always takes the sign of the dividend.\n *\n * @param self - The dividend.\n * @param divisor - The divisor.\n *\n * @example\n * import { remainder } from \"effect/Number\"\n *\n * assert.deepStrictEqual(remainder(2, 2), 0)\n * assert.deepStrictEqual(remainder(3, 2), 1)\n * assert.deepStrictEqual(remainder(-4, 2), -0)\n *\n * @category math\n * @since 2.0.0\n */\nconst remainder = /*#__PURE__*/dual(2, (self, divisor) => {\n  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n  const selfDecCount = (self.toString().split(\".\")[1] || \"\").length;\n  const divisorDecCount = (divisor.toString().split(\".\")[1] || \"\").length;\n  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;\n  const selfInt = parseInt(self.toFixed(decCount).replace(\".\", \"\"));\n  const divisorInt = parseInt(divisor.toFixed(decCount).replace(\".\", \"\"));\n  return selfInt % divisorInt / Math.pow(10, decCount);\n});\n\nexport { Equivalence, Order, between, clamp, decrement, divide, greaterThan, greaterThanOrEqualTo, increment, isNumber, lessThan, lessThanOrEqualTo, max, min, multiply, multiplyAll, remainder, sign, subtract, sum, sumAll };\n","import { equivalence } from '../../Equal/dist/effect-Equal.esm.js';\nimport { make } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual, constNull, constUndefined, identity } from '../../Function/dist/effect-Function.esm.js';\nimport { getRight as getRight$1, getLeft as getLeft$1, right, left, isLeft } from '../../internal/Either.esm.js';\nimport { none as none$1, some as some$1, isOption as isOption$1, isNone as isNone$1, isSome as isSome$1 } from '../../internal/Option.esm.js';\nimport { sum as sum$1, multiply as multiply$1, subtract as subtract$1, divide as divide$1 } from '../../Number/dist/effect-Number.esm.js';\nimport { make as make$1 } from '../../Order/dist/effect-Order.esm.js';\nimport { adapter as adapter$1 } from '../../Utils/dist/effect-Utils.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Option\");\n\n/**\n * @category symbols\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * Creates a new `Option` that represents the absence of a value.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst none = () => none$1;\n\n/**\n * Creates a new `Option` that wraps the given value.\n *\n * @param value - The value to wrap.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst some = some$1;\n\n/**\n * Tests if a value is a `Option`.\n *\n * @param input - The value to check.\n *\n * @example\n * import { some, none, isOption } from 'effect/Option'\n *\n * assert.deepStrictEqual(isOption(some(1)), true)\n * assert.deepStrictEqual(isOption(none()), true)\n * assert.deepStrictEqual(isOption({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isOption = isOption$1;\n\n/**\n * Determine if a `Option` is a `None`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isNone } from 'effect/Option'\n *\n * assert.deepStrictEqual(isNone(some(1)), false)\n * assert.deepStrictEqual(isNone(none()), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNone = isNone$1;\n\n/**\n * Determine if a `Option` is a `Some`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isSome } from 'effect/Option'\n *\n * assert.deepStrictEqual(isSome(some(1)), true)\n * assert.deepStrictEqual(isSome(none()), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isSome = isSome$1;\n\n/**\n * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`\n * function when passed the `Option`'s value.\n *\n * @param self - The `Option` to match\n * @param onNone - The value to be returned if the `Option` is `None`\n * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned\n *\n * @example\n * import { some, none, match } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(some(1), match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a some containing 1'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(none(), match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.0.0\n */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onNone,\n  onSome\n}) => isNone(self) ? onNone() : onSome(self.value));\n\n/**\n * Returns a type guard from a `Option` returning function.\n * This function ensures that a type guard definition is type-safe.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const parsePositive = (n: number): O.Option<number> =>\n *   n > 0 ? O.some(n) : O.none()\n *\n * const isPositive = O.toRefinement(parsePositive)\n *\n * assert.deepStrictEqual(isPositive(1), true)\n * assert.deepStrictEqual(isPositive(-1), false)\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toRefinement = f => a => isSome(f(a));\n\n/**\n * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`\n * if the `Iterable` is not empty, otherwise returns `None`.\n *\n * @param collection - The `Iterable` to be converted to an `Option`.\n *\n * @example\n * import { fromIterable, some, none } from 'effect/Option'\n *\n * assert.deepStrictEqual(fromIterable([1, 2, 3]), some(1))\n * assert.deepStrictEqual(fromIterable([]), none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromIterable = collection => {\n  for (const a of collection) {\n    return some(a);\n  }\n  return none();\n};\n\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * Alias of {@link fromEither}.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(O.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(O.getRight(E.left('err')), O.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getRight = getRight$1;\n\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(O.getLeft(E.right(\"ok\")), O.none())\n * assert.deepStrictEqual(O.getLeft(E.left(\"a\")), O.some(\"a\"))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getLeft = getLeft$1;\n\n/**\n * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`\n *\n * @param self - The `Option` to get the value of.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import { some, none, getOrElse } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(pipe(some(1), getOrElse(() => 0)), 1)\n * assert.deepStrictEqual(pipe(none(), getOrElse(() => 0)), 0)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrElse = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? onNone() : self.value);\n\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.none())\n *   ),\n *   O.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.none())\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that() : self);\n\n/**\n * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,\n * which contains information about which of the two `Option`s has been chosen.\n *\n * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The second `Option` to be considered if the first `Option` is `None`.\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElseEither = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? map(that(), right) : map(self, left));\n\n/**\n * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.\n *\n * @param collection - An iterable collection of `Option` to be searched.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.firstSomeOf([O.none(), O.some(1), O.some(2)]), O.some(1))\n *\n * @category error handling\n * @since 2.0.0\n */\nconst firstSomeOf = collection => {\n  let out = none();\n  for (out of collection) {\n    if (isSome(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @param nullableValue - The nullable value to be converted to an `Option`.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.fromNullable(undefined), O.none())\n * assert.deepStrictEqual(O.fromNullable(null), O.none())\n * assert.deepStrictEqual(O.fromNullable(1), O.some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromNullable = nullableValue => nullableValue == null ? none() : some(nullableValue);\n\n/**\n * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = O.liftNullable(parse)\n *\n * assert.deepStrictEqual(parseOption('1'), O.some(1))\n * assert.deepStrictEqual(parseOption('not a number'), O.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst liftNullable = f => (...a) => fromNullable(f(...a));\n\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.getOrNull(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrNull(O.none()), null)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrNull = /*#__PURE__*/getOrElse(constNull);\n\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.getOrUndefined(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrUndefined(O.none()), undefined)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n\n/**\n * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.\n *\n * This function is useful for any function that might throw an exception, allowing the developer to handle\n * the exception in a more functional way.\n *\n * @param f - the function that can throw exceptions.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const parse = O.liftThrowable(JSON.parse)\n *\n * assert.deepStrictEqual(parse(\"1\"), O.some(1))\n * assert.deepStrictEqual(parse(\"\"), O.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst liftThrowable = f => (...a) => {\n  try {\n    return some(f(...a));\n  } catch (e) {\n    return none();\n  }\n};\n\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Option` to extract the value from.\n * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   O.getOrThrowWith(O.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => O.getOrThrowWith(O.none(), () => new Error('Unexpected None')))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getOrThrowWith = /*#__PURE__*/dual(2, (self, onNone) => {\n  if (isSome(self)) {\n    return self.value;\n  }\n  throw onNone();\n});\n\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Option` to extract the value from.\n * @throws `Error(\"getOrThrow called on a None\")`\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.getOrThrow(O.some(1)), 1)\n * assert.throws(() => O.getOrThrow(O.none()))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a None\"));\n\n/**\n * Maps the `Some` side of an `Option` value to a new `Option` value.\n *\n * @param self - An `Option` to map\n * @param f - The function to map over the value of the `Option`\n *\n * @category transforming\n * @since 2.0.0\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : some(f(self.value)));\n\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category transforming\n * @since 2.0.0\n */\nconst as = /*#__PURE__*/dual(2, (self, b) => map(self, () => b));\n\n/**\n * Maps the `Some` value of this `Option` to the `void` constant value.\n *\n * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.\n *\n * @category transforming\n * @since 2.0.0\n */\nconst asUnit = /*#__PURE__*/as(undefined);\n\n/**\n * @since 2.0.0\n */\nconst unit = /*#__PURE__*/some(undefined);\n\n/**\n * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.\n *\n * @category transforming\n * @since 2.0.0\n */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : f(self.value));\n\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, flatMapNullable } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee1),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee2),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   none()\n * )\n *\n * @category transforming\n * @since 2.0.0\n */\nconst flatMapNullable = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : fromNullable(f(self.value)));\n\n/**\n * @category transforming\n * @since 2.0.0\n */\nconst flatten = /*#__PURE__*/flatMap(identity);\n\n/**\n * @category transforming\n * @since 2.0.0\n */\nconst zipRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));\n\n/**\n * @category transforming\n * @since 2.0.0\n */\nconst composeK = /*#__PURE__*/dual(2, (afb, bfc) => a => flatMap(afb(a), bfc));\n\n/**\n * Sequences the specified `that` `Option` but ignores its value.\n *\n * It is useful when we want to chain multiple operations, but only care about the result of `self`.\n *\n * @param that - The `Option` that will be ignored in the chain and discarded\n * @param self - The `Option` we care about\n *\n * @category transforming\n * @since 2.0.0\n */\nconst zipLeft = /*#__PURE__*/dual(2, (self, that) => tap(self, () => that));\n\n/**\n * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`\n * unless `f` returns `None`, in which case it returns `None`.\n *\n * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.\n *\n * @param f - Function to apply to the value of the `Option` if it is `Some`\n * @param self - The `Option` to apply the function to\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.tap(O.none(), getInteger), O.none())\n * assert.deepStrictEqual(O.tap(O.some(1), getInteger), O.some(1))\n * assert.deepStrictEqual(O.tap(O.some(1.14), getInteger), O.none())\n *\n * @category transforming\n * @since 2.0.0\n */\nconst tap = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => map(f(a), () => a)));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : none();\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = (self, collection) => {\n  if (isNone(self)) {\n    return none();\n  }\n  const out = [self.value];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n\n/**\n * Takes a structure of `Option`s and returns an `Option` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Option` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Option` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Option` will contain an array.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.all([O.some(1), O.some(2)]), O.some([1, 2]))\n * assert.deepStrictEqual(O.all({ a: O.some(1), b: O.some(\"hello\") }), O.some({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(O.all({ a: O.some(1), b: O.none() }), O.none())\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nconst all = input => {\n  if (Symbol.iterator in input) {\n    const out = [];\n    for (const o of input) {\n      if (isNone(o)) {\n        return none();\n      }\n      out.push(o.value);\n    }\n    return some(out);\n  }\n  const out = {};\n  for (const key of Object.keys(input)) {\n    const o = input[key];\n    if (isNone(o)) {\n      return none();\n    }\n    out[key] = o.value;\n  }\n  return some(out);\n};\n\n/**\n * Zips two `Option` values together using a provided function, returning a new `Option` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * type Complex = [number, number]\n *\n * const complex = (real: number, imaginary: number): Complex => [real, imaginary]\n *\n * assert.deepStrictEqual(O.zipWith(O.none(), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.none(), O.some(1), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.some(2), complex), O.some([1, 2]))\n *\n * assert.deepStrictEqual(O.zipWith(O.some(1), complex)(O.some(2)), O.some([2, 1]))\n *\n * @category combining\n * @since 2.0.0\n */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => map(product(self, that), ([a, b]) => f(a, b)));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst ap = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.\n *\n * @param self - The Iterable of `Option<A>` to be reduced.\n * @param b - The initial value of the accumulator.\n * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.\n *\n * @example\n * import { some, none, reduceCompact } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * const iterable = [some(1), none(), some(2), none()]\n * assert.deepStrictEqual(pipe(iterable, reduceCompact(0, (b, a) => b + a)), 3)\n *\n * @category folding\n * @since 2.0.0\n */\nconst reduceCompact = /*#__PURE__*/dual(3, (self, b, f) => {\n  let out = b;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out = f(out, oa.value);\n    }\n  }\n  return out;\n});\n\n/**\n * Transforms an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, the value is wrapped in an array.\n *\n * @param self - The `Option` to convert to an array.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.toArray(O.some(1)), [1])\n * assert.deepStrictEqual(O.toArray(O.none()), [])\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toArray = self => isNone(self) ? [] : [self.value];\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNone(self)) {\n    return [none(), none()];\n  }\n  const e = f(self.value);\n  return isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)];\n});\n\n/**\n * Maps over the value of an `Option` and filters out `None`s.\n *\n * Useful when in addition to filtering you also want to change the type of the `Option`.\n *\n * @param self - The `Option` to map over.\n * @param f - A function to apply to the value of the `Option`.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const evenNumber = (n: number) => n % 2 === 0 ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.filterMap(O.none(), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(3), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(2), evenNumber), O.some(2))\n *\n * @category filtering\n * @since 2.0.0\n */\nconst filterMap = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : f(self.value));\n\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @param predicate - A predicate function to apply to the `Option` value.\n * @param fb - The `Option` to filter.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * // predicate\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(O.filter(O.none(), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(3), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isEven), O.some(2))\n *\n * // refinement\n * const isNumber = (v: unknown): v is number => typeof v === \"number\"\n *\n * assert.deepStrictEqual(O.filter(O.none(), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some('hello'), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isNumber), O.some(2))\n *\n * @category filtering\n * @since 2.0.0\n */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => filterMap(self, b => predicate(b) ? some$1(b) : none$1));\n\n/**\n * @example\n * import { none, some, getEquivalence } from 'effect/Option'\n * import * as N from 'effect/Number'\n *\n * const isEquivalent = getEquivalence(N.Equivalence)\n * assert.deepStrictEqual(isEquivalent(none(), none()), true)\n * assert.deepStrictEqual(isEquivalent(none(), some(1)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), none()), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(2)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(1)), true)\n *\n * @category equivalence\n * @since 2.0.0\n */\nconst getEquivalence = isEquivalent => make((x, y) => x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value)));\n\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * import { none, some, getOrder } from 'effect/Option'\n * import * as N from 'effect/Number'\n * import { pipe } from \"effect/Function\"\n *\n * const O = getOrder(N.Order)\n * assert.deepStrictEqual(O(none(), none()), 0)\n * assert.deepStrictEqual(O(none(), some(1)), -1)\n * assert.deepStrictEqual(O(some(1), none()), 1)\n * assert.deepStrictEqual(O(some(1), some(2)), -1)\n * assert.deepStrictEqual(O(some(1), some(1)), 0)\n *\n * @category sorting\n * @since 2.0.0\n */\nconst getOrder = O => make$1((self, that) => isSome(self) ? isSome(that) ? O(self.value, that.value) : 1 : -1);\n\n/**\n * Lifts a binary function into `Option`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 2.0.0\n */\nconst lift2 = f => dual(2, (self, that) => zipWith(self, that, f));\n\n/**\n * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`\n * if the predicate returns `false`.\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const getOption = O.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), O.none())\n * assert.deepStrictEqual(getOption(1), O.some(1))\n *\n * @category lifting\n * @since 2.0.0\n */\nconst liftPredicate = predicate => b => predicate(b) ? some(b) : none();\n\n/**\n * Returns a function that checks if a `Option` contains a given value using a provided `isEquivalent` function.\n *\n * @param equivalent - An `Equivalence` instance to compare values of the `Option`.\n * @param self - The `Option` to apply the comparison to.\n * @param a - The value to compare against the `Option`.\n *\n * @example\n * import { some, none, containsWith } from 'effect/Option'\n * import { Equivalence } from 'effect/Number'\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(pipe(some(2), containsWith(Equivalence)(2)), true)\n * assert.deepStrictEqual(pipe(some(1), containsWith(Equivalence)(2)), false)\n * assert.deepStrictEqual(pipe(none(), containsWith(Equivalence)(2)), false)\n *\n * @category elements\n * @since 2.0.0\n */\nconst containsWith = isEquivalent => dual(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));\nconst _equivalence = /*#__PURE__*/equivalence();\n\n/**\n * Returns a function that checks if an `Option` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nconst contains = /*#__PURE__*/containsWith(_equivalence);\n\n/**\n * Check if a value in an `Option` type meets a certain predicate.\n *\n * @param self - The `Option` to check.\n * @param predicate - The condition to check.\n *\n * @example\n * import { some, none, exists } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(pipe(some(2), exists(isEven)), true)\n * assert.deepStrictEqual(pipe(some(1), exists(isEven)), false)\n * assert.deepStrictEqual(pipe(none(), exists(isEven)), false)\n *\n * @since 2.0.0\n */\nconst exists = /*#__PURE__*/dual(2, (self, predicate) => isNone(self) ? false : predicate(self.value));\n\n// -------------------------------------------------------------------------------------\n// math\n// -------------------------------------------------------------------------------------\n\n/**\n * @category math\n * @since 2.0.0\n */\nconst sum = /*#__PURE__*/lift2(sum$1);\n\n/**\n * @category math\n * @since 2.0.0\n */\nconst multiply = /*#__PURE__*/lift2(multiply$1);\n\n/**\n * @category math\n * @since 2.0.0\n */\nconst subtract = /*#__PURE__*/lift2(subtract$1);\n\n/**\n * @category math\n * @since 2.0.0\n */\nconst divide = /*#__PURE__*/lift2(divide$1);\n\n/**\n * Sum all numbers in an iterable of `Option<number>` ignoring the `None` values.\n *\n * @param self - The iterable of `Option<number>` to be summed.\n *\n * @example\n * import { sumCompact, some, none } from 'effect/Option'\n *\n * const iterable = [some(2), none(), some(3), none()]\n * assert.deepStrictEqual(sumCompact(iterable), 5)\n *\n * @category math\n * @since 2.0.0\n */\nconst sumCompact = self => {\n  let out = 0;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out += oa.value;\n    }\n  }\n  return out;\n};\n\n/**\n * Multiply all numbers in an iterable of `Option<number>` ignoring the `None` values.\n *\n * @param self - The iterable of `Option<number>` to be multiplied.\n *\n * @example\n * import { multiplyCompact, some, none } from 'effect/Option'\n *\n * const iterable = [some(2), none(), some(3), none()]\n * assert.deepStrictEqual(multiplyCompact(iterable), 6)\n *\n * @category math\n * @since 2.0.0\n */\nconst multiplyCompact = self => {\n  let out = 1;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      const a = oa.value;\n      if (a === 0) {\n        return 0;\n      }\n      out *= a;\n    }\n  }\n  return out;\n};\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nconst bindTo = /*#__PURE__*/dual(2, (self, name) => map(self, a => ({\n  [name]: a\n})));\nconst let_ = /*#__PURE__*/dual(3, (self, name, f) => map(self, a => Object.assign({}, a, {\n  [name]: f(a)\n})));\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nconst bind = /*#__PURE__*/dual(3, (self, name, f) => flatMap(self, a => map(f(a), b => Object.assign({}, a, {\n  [name]: b\n}))));\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nconst Do = /*#__PURE__*/some({});\nconst adapter = /*#__PURE__*/adapter$1();\n\n/**\n * @category generators\n * @since 2.0.0\n */\nconst gen = f => {\n  const iterator = f(adapter);\n  let state = iterator.next();\n  if (state.done) {\n    return some(void 0);\n  } else {\n    let current = state.value.value;\n    if (isNone(current)) {\n      return current;\n    }\n    while (!state.done) {\n      state = iterator.next(current.value);\n      if (!state.done) {\n        current = state.value.value;\n        if (isNone(current)) {\n          return current;\n        }\n      }\n    }\n    return some(state.value);\n  }\n};\n\nexport { Do, TypeId, all, ap, as, asUnit, bind, bindTo, composeK, contains, containsWith, divide, exists, filter, filterMap, firstSomeOf, flatMap, flatMapNullable, flatten, fromIterable, fromNullable, gen, getEquivalence, getLeft, getOrElse, getOrNull, getOrThrow, getOrThrowWith, getOrUndefined, getOrder, getRight, isNone, isOption, isSome, let_ as let, lift2, liftNullable, liftPredicate, liftThrowable, map, match, multiply, multiplyCompact, none, orElse, orElseEither, partitionMap, product, productMany, reduceCompact, some, subtract, sum, sumCompact, tap, toArray, toRefinement, unit, zipLeft, zipRight, zipWith };\n","import { make } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual, identity, constNull, constUndefined } from '../../Function/dist/effect-Function.esm.js';\nimport { TypeId as TypeId$1, right as right$1, left as left$1, fromOption as fromOption$1, isEither as isEither$1, isLeft as isLeft$1, isRight as isRight$1, getRight as getRight$1, getLeft as getLeft$1 } from '../../internal/Either.esm.js';\nimport { isFunction } from '../../Predicate/dist/effect-Predicate.esm.js';\nimport { adapter as adapter$1 } from '../../Utils/dist/effect-Utils.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nconst TypeId = TypeId$1;\n\n/**\n * @category symbols\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst right = right$1;\n\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst left = left$1;\n\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n *\n * @category constructors\n * @since 2.0.0\n */\nconst fromNullable = /*#__PURE__*/dual(2, (self, onNullable) => self == null ? left(onNullable(self)) : right(self));\n\n/**\n * @example\n * import * as Either from 'effect/Either'\n * import * as Option from 'effect/Option'\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n *\n * @category constructors\n * @since 2.0.0\n */\nconst fromOption = fromOption$1;\nconst try_ = evaluate => {\n  if (isFunction(evaluate)) {\n    try {\n      return right(evaluate());\n    } catch (e) {\n      return left(e);\n    }\n  } else {\n    try {\n      return right(evaluate.try());\n    } catch (e) {\n      return left(evaluate.catch(e));\n    }\n  }\n};\n\n/**\n * Tests if a value is a `Either`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isEither, left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(isEither(right(1)), true)\n * assert.deepStrictEqual(isEither(left(\"a\")), true)\n * assert.deepStrictEqual(isEither({ right: 1 }), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isEither = isEither$1;\n\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { isLeft, left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(isLeft(right(1)), false)\n * assert.deepStrictEqual(isLeft(left(\"a\")), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isLeft = isLeft$1;\n\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { isRight, left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(isRight(right(1)), true)\n * assert.deepStrictEqual(isRight(left(\"a\")), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isRight = isRight$1;\n\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * Alias of {@link toOption}.\n *\n * @example\n * import * as O from 'effect/Option'\n * import * as E from 'effect/Either'\n *\n * assert.deepStrictEqual(E.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(E.getRight(E.left('err')), O.none())\n *\n * @category getters\n * @since 2.0.0\n */\nconst getRight = getRight$1;\n\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from 'effect/Option'\n * import * as E from 'effect/Either'\n *\n * assert.deepStrictEqual(E.getLeft(E.right('ok')), O.none())\n * assert.deepStrictEqual(E.getLeft(E.left('err')), O.some('err'))\n *\n * @category getters\n * @since 2.0.0\n */\nconst getLeft = getLeft$1;\n\n/**\n * @category equivalence\n * @since 2.0.0\n */\nconst getEquivalence = (EE, EA) => make((x, y) => x === y || (isLeft(x) ? isLeft(y) && EE(x.left, y.left) : isRight(y) && EA(x.right, y.right)));\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nconst mapBoth = /*#__PURE__*/dual(2, (self, {\n  onLeft,\n  onRight\n}) => isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right)));\n\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @param self - The input `Either` value to map.\n * @param f - A transformation function to apply to the `Left` value of the input `Either`.\n *\n * @category mapping\n * @since 2.0.0\n */\nconst mapLeft = /*#__PURE__*/dual(2, (self, f) => isLeft(self) ? left(f(self.left)) : right(self.right));\n\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @param self - An `Either` to map\n * @param f - The function to map over the value of the `Either`\n *\n * @category mapping\n * @since 2.0.0\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => isRight(self) ? right(f(self.right)) : left(self.left));\n\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * import * as E from 'effect/Either'\n * import { pipe } from 'effect/Function'\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(E.right(1), E.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(E.left(['string 1', 'string 2']), E.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n *\n * @category pattern matching\n * @since 2.0.0\n */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onLeft,\n  onRight\n}) => isLeft(self) ? onLeft(self.left) : onRight(self.right));\n\n/**\n * @category getters\n * @since 2.0.0\n */\nconst merge = /*#__PURE__*/match({\n  onLeft: identity,\n  onRight: identity\n});\n\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrElse = /*#__PURE__*/dual(2, (self, onLeft) => isLeft(self) ? onLeft(self.left) : self.right);\n\n/**\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrNull = /*#__PURE__*/getOrElse(constNull);\n\n/**\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Either` to extract the value from.\n * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.\n *\n * @example\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   E.getOrThrowWith(E.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => E.getOrThrowWith(E.left(\"error\"), () => new Error('Unexpected Left')))\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrThrowWith = /*#__PURE__*/dual(2, (self, onLeft) => {\n  if (isRight(self)) {\n    return self.right;\n  }\n  throw onLeft(self.left);\n});\n\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Either` to extract the value from.\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @example\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(E.getOrThrow(E.right(1)), 1)\n * assert.throws(() => E.getOrThrow(E.left(\"error\")))\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a Left\"));\n\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @param self - The input `Either` value to check and potentially return.\n * @param that - A function that takes the error value from `self` (if it's a `Left`) and returns a new `Either` value.\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => isLeft(self) ? that(self.left) : right(self.right));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => isLeft(self) ? left(self.left) : f(self.right));\n\n/**\n * @since 2.0.0\n * @category combining\n */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, a => map(that, b => f(a, b))));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst ap = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n\n/**\n * Takes a structure of `Option`s and returns an `Option` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Option` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Option` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Option` will contain an array.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * import * as Either from \"effect/Either\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ a: Either.right(1), b: Either.right(\"hello\") }), Either.right({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ a: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nconst all = input => {\n  if (Symbol.iterator in input) {\n    const out = [];\n    for (const e of input) {\n      if (isLeft(e)) {\n        return e;\n      }\n      out.push(e.right);\n    }\n    return right(out);\n  }\n  const out = {};\n  for (const key of Object.keys(input)) {\n    const e = input[key];\n    if (isLeft(e)) {\n      return e;\n    }\n    out[key] = e.right;\n  }\n  return right(out);\n};\n\n/**\n * @since 2.0.0\n */\nconst reverse = self => isLeft(self) ? right(self.left) : left(self.right);\nconst adapter = /*#__PURE__*/adapter$1();\n\n/**\n * @category generators\n * @since 2.0.0\n */\nconst gen = f => {\n  const iterator = f(adapter);\n  let state = iterator.next();\n  if (state.done) {\n    return right(void 0);\n  } else {\n    let current = state.value.value;\n    if (isLeft(current)) {\n      return current;\n    }\n    while (!state.done) {\n      state = iterator.next(current.right);\n      if (!state.done) {\n        current = state.value.value;\n        if (isLeft(current)) {\n          return current;\n        }\n      }\n    }\n    return right(state.value);\n  }\n};\n\nexport { TypeId, all, ap, flatMap, fromNullable, fromOption, gen, getEquivalence, getLeft, getOrElse, getOrNull, getOrThrow, getOrThrowWith, getOrUndefined, getRight, isEither, isLeft, isRight, left, map, mapBoth, mapLeft, match, merge, orElse, reverse, right, try_ as try, zipWith };\n","/**\n * @since 2.0.0\n */\n\n/** @internal */\nconst isNonEmptyArray = self => self.length > 0;\n\nexport { isNonEmptyArray };\n","import { isLeft } from '../../Either/dist/effect-Either.esm.js';\nimport { dual, identity } from '../../Function/dist/effect-Function.esm.js';\nimport { some, none, isSome } from '../../Option/dist/effect-Option.esm.js';\n\n/**\n * This module provides utility functions for working with records in TypeScript.\n *\n * @since 2.0.0\n */\n\n// -------------------------------------------------------------------------------------\n// models\n// -------------------------------------------------------------------------------------\n\n/**\n * @category models\n * @since 2.0.0\n */\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Creates a new, empty record.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst empty = () => ({});\n\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n\n/**\n * Determine if a `Record` is empty.\n *\n * @param self - `Record` to test for emptiness.\n *\n * @example\n * import { isEmptyRecord } from \"effect/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmptyRecord({}), true);\n * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n *\n * @category guards\n * @since 2.0.0\n */\nconst isEmptyRecord = self => {\n  for (const k in self) {\n    if (has(self, k)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Determine if a `ReadonlyRecord` is empty.\n *\n * @param self - `ReadonlyRecord` to test for emptiness.\n *\n * @example\n * import { isEmptyReadonlyRecord } from \"effect/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\n * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n *\n * @category guards\n * @since 2.0.0\n */\nconst isEmptyReadonlyRecord = isEmptyRecord;\n\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n\n/**\n * Takes an iterable and a projection function and returns a record.\n * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n *\n * @param self - An iterable of values to be mapped to a record.\n * @param f - A projection function that maps values of the iterable to a tuple of a key and a value.\n *\n * @example\n * import { fromIterable } from 'effect/ReadonlyRecord'\n *\n * const input = [1, 2, 3, 4]\n *\n * assert.deepStrictEqual(\n *   fromIterable(input, a => [String(a), a * 2]),\n *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromIterable = /*#__PURE__*/dual(2, (self, f) => {\n  const out = {};\n  for (const a of self) {\n    const [k, b] = f(a);\n    out[k] = b;\n  }\n  return out;\n});\n\n/**\n * Builds a record from an iterable of key-value pairs.\n *\n * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\n * previous ones. So the resulting record will only have the value of the last occurrence of each key.\n *\n * @param self - The iterable of key-value pairs.\n *\n * @example\n * import { fromEntries } from 'effect/ReadonlyRecord'\n *\n * const input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n *\n * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromEntries = /*#__PURE__*/fromIterable(identity);\n\n/**\n * Transforms the values of a `ReadonlyRecord` into an `Array` with a custom mapping function.\n *\n * @param self - The `ReadonlyRecord` to transform.\n * @param f - The custom mapping function to apply to each key/value of the `ReadonlyRecord`.\n *\n * @example\n * import { collect } from \"effect/ReadonlyRecord\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nconst collect = /*#__PURE__*/dual(2, (self, f) => {\n  const out = [];\n  for (const key of Object.keys(self)) {\n    out.push(f(key, self[key]));\n  }\n  return out;\n});\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { toEntries } from \"effect/ReadonlyRecord\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toEntries = /*#__PURE__*/collect((key, value) => [key, value]);\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * Alias of {@link toEntries}.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { toArray } from \"effect/ReadonlyRecord\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toArray(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toArray = toEntries;\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns the number of key/value pairs in a `ReadonlyRecord`.\n *\n * @param self - A `ReadonlyRecord` to calculate the number of key/value pairs in.\n *\n * @example\n * import { size } from \"effect/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n *\n * @since 2.0.0\n */\nconst size = self => Object.keys(self).length;\n\n/**\n * Check if a given `key` exists in a `ReadonlyRecord`.\n *\n * @param self - the `ReadonlyRecord` to look in.\n * @param key - the key to look for in the `ReadonlyRecord`.\n *\n * @example\n * import { has } from 'effect/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"c\"), false);\n *\n * @since 2.0.0\n */\nconst has = /*#__PURE__*/dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));\n\n/**\n * Retrieve a value at a particular key from a `ReadonlyRecord`, returning it wrapped in an `Option`.\n *\n * @param self - The `ReadonlyRecord` to retrieve value from.\n * @param key - Key to retrieve from `ReadonlyRecord`.\n *\n * @example\n * import { get } from \"effect/ReadonlyRecord\"\n * import { some, none } from \"effect/Option\"\n *\n * const person = { name: \"John Doe\", age: 35 }\n *\n * assert.deepStrictEqual(get(person, \"name\"), some(\"John Doe\"))\n * assert.deepStrictEqual(get(person, \"email\"), none())\n *\n * @since 2.0.0\n */\nconst get = /*#__PURE__*/dual(2, (self, key) => has(self, key) ? some(self[key]) : none());\n\n/**\n * Apply a function to the element at the specified key, creating a new record,\n * or return `None` if the key doesn't exist.\n *\n * @param self - The `ReadonlyRecord` to be updated.\n * @param key - The key of the element to modify.\n * @param f - The function to apply to the element.\n *\n * @example\n * import { modifyOption } from \"effect/ReadonlyRecord\"\n * import { some, none } from \"effect/Option\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  modifyOption({ a: 3 }, 'a', f),\n *  some({ a: 6 })\n * )\n * assert.deepStrictEqual(\n *  modifyOption({ a: 3 }, 'b', f),\n *  none()\n * )\n *\n * @since 2.0.0\n */\nconst modifyOption = /*#__PURE__*/dual(3, (self, key, f) => {\n  if (!has(self, key)) {\n    return none();\n  }\n  const out = {\n    ...self\n  };\n  out[key] = f(self[key]);\n  return some(out);\n});\n\n/**\n * Replaces a value in the record with the new value passed as parameter.\n *\n * @param self - The `ReadonlyRecord` to be updated.\n * @param key - The key to search for in the record.\n * @param b - The new value to replace the existing value with.\n *\n * @example\n * import { replaceOption } from \"effect/ReadonlyRecord\"\n * import { some, none } from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n *   some({ a: 10, b: 2, c: 3 })\n * )\n * assert.deepStrictEqual(replaceOption({}, 'a', 10), none())\n *\n * @since 2.0.0\n */\nconst replaceOption = /*#__PURE__*/dual(3, (self, key, b) => modifyOption(self, key, () => b));\n\n/**\n * Removes a key from a `ReadonlyRecord` and returns a new `Record`\n *\n * @param self - the `ReadonlyRecord` to remove the key from.\n * @param key - the key to remove from the `ReadonlyRecord`.\n *\n * @example\n * import { remove } from 'effect/ReadonlyRecord'\n *\n * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n *\n * @since 2.0.0\n */\nconst remove = /*#__PURE__*/dual(2, (self, key) => {\n  const out = {\n    ...self\n  };\n  delete out[key];\n  return out;\n});\n\n/**\n * Retrieves the value of the property with the given `key` from a `ReadonlyRecord` and returns an `Option`\n * of a tuple with the value and the `ReadonlyRecord` with the removed property.\n * If the key is not present, returns `O.none`.\n *\n * @param self - The input `ReadonlyRecord`.\n * @param key - The key of the property to retrieve.\n *\n * @example\n * import { pop } from 'effect/ReadonlyRecord'\n * import { some, none } from 'effect/Option'\n *\n * assert.deepStrictEqual(pop({ a: 1, b: 2 }, \"a\"), some([1, { b: 2 }]))\n * assert.deepStrictEqual(pop({ a: 1, b: 2 }, \"c\"), none())\n *\n * @category record\n * @since 2.0.0\n */\nconst pop = /*#__PURE__*/dual(2, (self, key) => has(self, key) ? some([self[key], remove(self, key)]) : none());\n\n/**\n * Maps a `ReadonlyRecord` into another `Record` by applying a transformation function to each of its values.\n *\n * @param self - The `ReadonlyRecord` to be mapped.\n * @param f - A transformation function that will be applied to each of the values in the `ReadonlyRecord`.\n *\n * @example\n * import { map } from \"effect/ReadonlyRecord\"\n *\n * const f = (n: number) => `-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n *\n * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n *\n * @since 2.0.0\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => {\n  const out = {};\n  for (const key of Object.keys(self)) {\n    out[key] = f(self[key], key);\n  }\n  return out;\n});\n\n/**\n * Transforms a `ReadonlyRecord` into a `Record` by applying the function `f` to each key and value in the original `ReadonlyRecord`.\n * If the function returns `Some`, the key-value pair is included in the output `Record`.\n *\n * @param self - The input `ReadonlyRecord`.\n * @param f - The transformation function.\n *\n * @example\n * import { filterMap } from 'effect/ReadonlyRecord'\n * import { some, none } from 'effect/Option'\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (a: number, key: string) => a > 2 ? some(a * 2) : none()\n * assert.deepStrictEqual(filterMap(x, f), { c: 6 })\n *\n * @since 2.0.0\n */\nconst filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const out = {};\n  for (const key of Object.keys(self)) {\n    const o = f(self[key], key);\n    if (isSome(o)) {\n      out[key] = o.value;\n    }\n  }\n  return out;\n});\n\n/**\n * Selects properties from a record whose values match the given predicate.\n *\n * @param self - The `ReadonlyRecord` to filter.\n * @param predicate - A function that returns a `boolean` value to determine if the entry should be included in the new record.\n *\n * @example\n * import { filter } from 'effect/ReadonlyRecord'\n *\n * const x = { a: 1, b: 2, c: 3, d: 4 }\n * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n *\n * @category filtering\n * @since 2.0.0\n */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => {\n  const out = {};\n  for (const key of Object.keys(self)) {\n    if (predicate(self[key], key)) {\n      out[key] = self[key];\n    }\n  }\n  return out;\n});\n\n/**\n * Given a `ReadonlyRecord` with `Option` values, returns a `Record` with only the `Some` values, with the same keys.\n *\n * @param self - A `ReadonlyRecord` with `Option` values.\n *\n * @example\n * import { compact } from 'effect/ReadonlyRecord'\n * import { some, none } from 'effect/Option'\n *\n * assert.deepStrictEqual(\n *   compact({ a: some(1), b: none(), c: some(2) }),\n *   { a: 1, c: 2 }\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nconst compact = /*#__PURE__*/filterMap(identity);\n\n/**\n * Partitions the elements of a `ReadonlyRecord` into two groups: those that match a predicate, and those that don't.\n *\n * @param self - The `ReadonlyRecord` to partition.\n * @param f - The predicate function to apply to each element.\n *\n * @example\n * import { partitionMap } from 'effect/ReadonlyRecord'\n * import { left, right } from 'effect/Either'\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (n: number) => (n % 2 === 0 ? right(n) : left(n))\n * assert.deepStrictEqual(partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n *\n * @category filtering\n * @since 2.0.0\n */\nconst partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = {};\n  const right = {};\n  for (const key of Object.keys(self)) {\n    const e = f(self[key], key);\n    if (isLeft(e)) {\n      left[key] = e.left;\n    } else {\n      right[key] = e.right;\n    }\n  }\n  return [left, right];\n});\n\n/**\n * Partitions a `ReadonlyRecord` of `Either` values into two separate records,\n * one with the `Left` values and one with the `Right` values.\n *\n * @param self - the `ReadonlyRecord` to partition.\n *\n * @example\n * import { separate } from 'effect/ReadonlyRecord'\n * import { left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(\n *   separate({ a: left(\"e\"), b: right(1) }),\n *   [{ a: \"e\" }, { b: 1 }]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nconst separate = /*#__PURE__*/partitionMap(identity);\n\n/**\n * Partitions a `ReadonlyRecord` into two separate `Record`s based on the result of a predicate function.\n *\n * @param self - The input `ReadonlyRecord` to partition.\n * @param predicate - The partitioning function to determine the partitioning of each value of the `ReadonlyRecord`.\n *\n * @example\n * import { partition } from 'effect/ReadonlyRecord'\n *\n * assert.deepStrictEqual(\n *   partition({ a: 1, b: 3 }, (n) => n > 2),\n *   [{ a: 1 }, { b: 3 }]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nconst partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = {};\n  const right = {};\n  for (const key of Object.keys(self)) {\n    if (predicate(self[key], key)) {\n      right[key] = self[key];\n    } else {\n      left[key] = self[key];\n    }\n  }\n  return [left, right];\n});\n\nexport { collect, compact, empty, filter, filterMap, fromEntries, fromIterable, get, has, isEmptyReadonlyRecord, isEmptyRecord, map, modifyOption, partition, partitionMap, pop, remove, replaceOption, separate, size, toArray, toEntries };\n","import { isLeft } from '../../Either/dist/effect-Either.esm.js';\nimport { equivalence } from '../../Equal/dist/effect-Equal.esm.js';\nimport { array as array$1 } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual, identity } from '../../Function/dist/effect-Function.esm.js';\nimport { isNonEmptyArray as isNonEmptyArray$1 } from '../../internal/ReadonlyArray.esm.js';\nimport { toArray, none, some as some$1, getOrElse, isSome, isNone } from '../../Option/dist/effect-Option.esm.js';\nimport { mapInput, combineAll, min as min$1, max as max$1, array } from '../../Order/dist/effect-Order.esm.js';\nimport { toEntries } from '../../ReadonlyRecord/dist/effect-ReadonlyRecord.esm.js';\n\n/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst make = (...elements) => elements;\n\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { makeBy } from 'effect/ReadonlyArray'\n *\n * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.0.0\n */\nconst makeBy = (n, f) => {\n  const max = Math.max(1, Math.floor(n));\n  const out = [f(0)];\n  for (let i = 1; i < max; i++) {\n    out.push(f(i));\n  }\n  return out;\n};\n\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'effect/ReadonlyArray'\n *\n * assert.deepStrictEqual(range(1, 3), [1, 2, 3])\n *\n * @category constructors\n * @since 2.0.0\n */\nconst range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : [start];\n\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { replicate } from 'effect/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(\"a\", 3), [\"a\", \"a\", \"a\"])\n *\n * @category constructors\n * @since 2.0.0\n */\nconst replicate = /*#__PURE__*/dual(2, (a, n) => makeBy(n, () => a));\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nconst fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { fromRecord } from \"effect/ReadonlyArray\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(fromRecord(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromRecord = toEntries;\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nconst fromOption = toArray;\n\n/**\n * @category pattern matching\n * @since 2.0.0\n */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onEmpty,\n  onNonEmpty\n}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());\n\n/**\n * @category pattern matching\n * @since 2.0.0\n */\nconst matchLeft = /*#__PURE__*/dual(2, (self, {\n  onEmpty,\n  onNonEmpty\n}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());\n\n/**\n * @category pattern matching\n * @since 2.0.0\n */\nconst matchRight = /*#__PURE__*/dual(2, (self, {\n  onEmpty,\n  onNonEmpty\n}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());\n\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst prepend = /*#__PURE__*/dual(2, (self, head) => [head, ...self]);\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAll = /*#__PURE__*/dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => prependAll(self, that));\n\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst append = /*#__PURE__*/dual(2, (self, last) => [...self, last]);\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst appendAll = /*#__PURE__*/dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst appendAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => appendAll(self, that));\n\n/**\n * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 2.0.0\n */\nconst scan = /*#__PURE__*/dual(3, (self, b, f) => {\n  const out = [b];\n  let i = 0;\n  for (const a of self) {\n    out[i + 1] = f(out[i], a);\n    i++;\n  }\n  return out;\n});\n\n/**\n * Reduce an `Iterable` from the right, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 2.0.0\n */\nconst scanRight = /*#__PURE__*/dual(3, (self, b, f) => {\n  const input = fromIterable(self);\n  const out = new Array(input.length + 1);\n  out[input.length] = b;\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i]);\n  }\n  return out;\n});\n\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isEmptyArray } from \"effect/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isEmptyArray([]), true);\n * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 2.0.0\n */\nconst isEmptyArray = self => self.length === 0;\n\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isEmptyReadonlyArray } from \"effect/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);\n * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 2.0.0\n */\nconst isEmptyReadonlyArray = isEmptyArray;\n\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isNonEmptyArray } from \"effect/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isNonEmptyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNonEmptyArray = isNonEmptyArray$1;\n\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isNonEmptyReadonlyArray } from \"effect/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNonEmptyReadonlyArray = isNonEmptyArray$1;\n\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nconst length = self => self.length;\nconst isOutOfBound = (i, as) => i < 0 || i >= as.length;\nconst clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));\n\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nconst get = /*#__PURE__*/dual(2, (self, index) => {\n  const i = Math.floor(index);\n  return isOutOfBound(i, self) ? none() : some$1(self[i]);\n});\n\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeGet = /*#__PURE__*/dual(2, (self, index) => {\n  const i = Math.floor(index);\n  if (isOutOfBound(i, self)) {\n    throw new Error(`Index ${i} out of bounds`);\n  }\n  return self[i];\n});\n\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * @category getters\n * @since 2.0.0\n */\nconst unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];\n\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * @category getters\n * @since 2.0.0\n */\nconst unappend = self => [initNonEmpty(self), lastNonEmpty(self)];\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nconst head = /*#__PURE__*/get(0);\n\n/**\n * @category getters\n * @since 2.0.0\n */\nconst headNonEmpty = /*#__PURE__*/unsafeGet(0);\n\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nconst last = self => isNonEmptyReadonlyArray(self) ? some$1(lastNonEmpty(self)) : none();\n\n/**\n * @category getters\n * @since 2.0.0\n */\nconst lastNonEmpty = self => self[self.length - 1];\n\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nconst tail = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? some$1(tailNonEmpty(input)) : none();\n};\n\n/**\n * @category getters\n * @since 2.0.0\n */\nconst tailNonEmpty = self => self.slice(1);\n\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nconst init = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? some$1(initNonEmpty(input)) : none();\n};\n\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @category getters\n * @since 2.0.0\n */\nconst initNonEmpty = self => self.slice(0, -1);\n\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nconst take = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, clamp(n, input));\n});\n\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nconst takeRight = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  const i = clamp(n, input);\n  return i === 0 ? [] : input.slice(-i);\n});\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 2.0.0\n */\nconst takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const out = [];\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    out.push(a);\n  }\n  return out;\n});\nconst spanIndex = (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n};\n\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category filtering\n * @since 2.0.0\n */\nconst span = /*#__PURE__*/dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));\n\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nconst drop = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(clamp(n, input), input.length);\n});\n\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nconst dropRight = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, input.length - clamp(n, input));\n});\n\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 2.0.0\n */\nconst dropWhile = /*#__PURE__*/dual(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));\n\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirstIndex = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (predicate(a)) {\n      return some$1(i);\n    }\n    i++;\n  }\n  return none();\n});\n\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findLastIndex = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return some$1(i);\n    }\n  }\n  return none();\n});\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = 0; i < input.length; i++) {\n    if (predicate(input[i])) {\n      return some$1(input[i]);\n    }\n  }\n  return none();\n});\n\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findLast = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return some$1(input[i]);\n    }\n  }\n  return none();\n});\n\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst insertAt = /*#__PURE__*/dual(3, (self, i, b) => {\n  const out = Array.from(self);\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return none();\n  }\n  out.splice(i, 0, b);\n  return some$1(out);\n});\n\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst replace = /*#__PURE__*/dual(3, (self, i, b) => modify(self, i, () => b));\n\n/**\n * @since 2.0.0\n */\nconst replaceOption = /*#__PURE__*/dual(3, (self, i, b) => modifyOption(self, i, () => b));\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst modify = /*#__PURE__*/dual(3, (self, i, f) => getOrElse(modifyOption(self, i, f), () => Array.from(self)));\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst modifyOption = /*#__PURE__*/dual(3, (self, i, f) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return none();\n  }\n  const next = f(out[i]);\n  // @ts-expect-error\n  out[i] = next;\n  return some$1(out);\n});\n\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst remove = /*#__PURE__*/dual(2, (self, i) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return out;\n  }\n  out.splice(i, 1);\n  return out;\n});\n\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * @category elements\n * @since 2.0.0\n */\nconst reverse = self => Array.from(self).reverse();\n\n/**\n * @category elements\n * @since 2.0.0\n */\nconst reverseNonEmpty = self => [lastNonEmpty(self), ...self.slice(0, -1).reverse()];\n\n/**\n * Sort the elements of an `Iterable` in increasing order, creating a new `Array`.\n *\n * @category sorting\n * @since 2.0.0\n */\nconst sort = /*#__PURE__*/dual(2, (self, O) => {\n  const out = Array.from(self);\n  out.sort(O);\n  return out;\n});\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst sortWith = /*#__PURE__*/dual(3, (self, f, order) => sort(self, mapInput(order, f)));\n\n/**\n * Sort the elements of a `NonEmptyReadonlyArray` in increasing order, creating a new `NonEmptyArray`.\n *\n * @category sorting\n * @since 2.0.0\n */\nconst sortNonEmpty = /*#__PURE__*/dual(2, (self, O) => sort(O)(self));\n\n/**\n * Sort the elements of an `Iterable` in increasing order, where elements are compared\n * using first `orders[0]`, then `orders[1]`, etc...\n *\n * @category sorting\n * @since 2.0.0\n */\nconst sortBy = (...orders) => self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? sortByNonEmpty(...orders)(input) : [];\n};\n\n/**\n * @category sorting\n * @since 2.0.0\n */\nconst sortByNonEmpty = (...orders) => sortNonEmpty(combineAll(orders));\n\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * @since 2.0.0\n */\nconst zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @since 2.0.0\n */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const as = fromIterable(self);\n  const bs = fromIterable(that);\n  return isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs) ? zipNonEmptyWith(bs, f)(as) : [];\n});\n\n/**\n * @since 2.0.0\n */\nconst zipNonEmpty = /*#__PURE__*/dual(2, (self, that) => zipNonEmptyWith(self, that, (a, b) => [a, b]));\n\n/**\n * @since 2.0.0\n */\nconst zipNonEmptyWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const cs = [f(headNonEmpty(self), headNonEmpty(that))];\n  const len = Math.min(self.length, that.length);\n  for (let i = 1; i < len; i++) {\n    cs[i] = f(self[i], that[i]);\n  }\n  return cs;\n});\n\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * @since 2.0.0\n */\nconst unzip = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? unzipNonEmpty(input) : [[], []];\n};\n\n/**\n * @since 2.0.0\n */\nconst unzipNonEmpty = self => {\n  const fa = [self[0][0]];\n  const fb = [self[0][1]];\n  for (let i = 1; i < self.length; i++) {\n    fa[i] = self[i][0];\n    fb[i] = self[i][1];\n  }\n  return [fa, fb];\n};\n\n/**\n * Places an element in between members of an `Iterable`\n *\n * @since 2.0.0\n */\nconst intersperse = /*#__PURE__*/dual(2, (self, middle) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? intersperseNonEmpty(input, middle) : [];\n});\n\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`\n *\n * @since 2.0.0\n */\nconst intersperseNonEmpty = /*#__PURE__*/dual(2, (self, middle) => {\n  const out = [headNonEmpty(self)];\n  const tail = tailNonEmpty(self);\n  for (let i = 0; i < tail.length; i++) {\n    if (i < tail.length) {\n      out.push(middle);\n    }\n    out.push(tail[i]);\n  }\n  return out;\n});\n\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nconst modifyNonEmptyHead = /*#__PURE__*/dual(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);\n\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nconst setNonEmptyHead = /*#__PURE__*/dual(2, (self, b) => modifyNonEmptyHead(self, () => b));\n\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nconst modifyNonEmptyLast = /*#__PURE__*/dual(2, (self, f) => append(initNonEmpty(self), f(lastNonEmpty(self))));\n\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nconst setNonEmptyLast = /*#__PURE__*/dual(2, (self, b) => modifyNonEmptyLast(self, () => b));\n\n/**\n * Rotate an `Iterable` by `n` steps.\n *\n * @since 2.0.0\n */\nconst rotate = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? rotateNonEmpty(input, n) : [];\n});\n\n/**\n * Rotate a `NonEmptyReadonlyArray` by `n` steps.\n *\n * @since 2.0.0\n */\nconst rotateNonEmpty = /*#__PURE__*/dual(2, (self, n) => {\n  const len = self.length;\n  const m = Math.round(n) % len;\n  if (isOutOfBound(Math.abs(m), self) || m === 0) {\n    return copy(self);\n  }\n  if (m < 0) {\n    const [f, s] = splitNonEmptyAt(self, -m);\n    return appendAllNonEmpty(s, f);\n  } else {\n    return rotateNonEmpty(self, m - len);\n  }\n});\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nconst containsWith = isEquivalent => dual(2, (self, a) => {\n  for (const i of self) {\n    if (isEquivalent(a, i)) {\n      return true;\n    }\n  }\n  return false;\n});\nconst _equivalence = /*#__PURE__*/equivalence();\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nconst contains = /*#__PURE__*/containsWith(_equivalence);\n\n/**\n * Remove duplicates from a `NonEmptyReadonlyArray`, keeping the first occurrence of an element using the provided `isEquivalent` function.\n *\n * @since 2.0.0\n */\nconst dedupeNonEmptyWith = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const out = [headNonEmpty(self)];\n  const rest = tailNonEmpty(self);\n  for (const a of rest) {\n    if (out.every(o => !isEquivalent(a, o))) {\n      out.push(a);\n    }\n  }\n  return out;\n});\n\n/**\n * Remove duplicates from a `NonEmptyReadonlyArray`, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n */\nconst dedupeNonEmpty = /*#__PURE__*/dedupeNonEmptyWith( /*#__PURE__*/equivalence());\n\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * @since 2.0.0\n */\nconst chop = /*#__PURE__*/dual(2, (self, f) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? chopNonEmpty(input, f) : [];\n});\n\n/**\n * A useful recursion pattern for processing a `NonEmptyReadonlyArray` to produce a new `NonEmptyReadonlyArray`, often used for \"chopping\" up the input\n * `NonEmptyReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `NonEmptyReadonlyArray` and produce a\n * value and the tail of the `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nconst chopNonEmpty = /*#__PURE__*/dual(2, (self, f) => {\n  const [b, rest] = f(self);\n  const out = [b];\n  let next = rest;\n  while (isNonEmptyArray$1(next)) {\n    const [b, rest] = f(next);\n    out.push(b);\n    next = rest;\n  }\n  return out;\n});\n\n/**\n * Splits an `Iterable` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 2.0.0\n */\nconst splitAt = /*#__PURE__*/dual(2, (self, n) => {\n  const input = Array.from(self);\n  return n >= 1 && isNonEmptyReadonlyArray(input) ? splitNonEmptyAt(input, n) : isEmptyReadonlyArray(input) ? [input, []] : [[], input];\n});\n\n/**\n * @since 2.0.0\n */\nconst copy = self => self.slice();\n\n/**\n * Splits a `NonEmptyReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 2.0.0\n */\nconst splitNonEmptyAt = /*#__PURE__*/dual(2, (self, n) => {\n  const m = Math.max(1, n);\n  return m >= self.length ? [copy(self), []] : [prepend(self.slice(1, m), headNonEmpty(self)), self.slice(m)];\n});\n\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * @category getters\n * @since 2.0.0\n */\nconst chunksOf = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? chunksOfNonEmpty(input, n) : [];\n});\n\n/**\n * Splits a `NonEmptyReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `NonEmptyReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nconst chunksOfNonEmpty = /*#__PURE__*/dual(2, (self, n) => chopNonEmpty(self, splitNonEmptyAt(n)));\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * @category grouping\n * @since 2.0.0\n */\nconst groupWith = /*#__PURE__*/dual(2, (self, isEquivalent) => chopNonEmpty(self, as => {\n  const h = headNonEmpty(as);\n  const out = [h];\n  let i = 1;\n  for (; i < as.length; i++) {\n    const a = as[i];\n    if (isEquivalent(a, h)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return [out, as.slice(i)];\n}));\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 2.0.0\n */\nconst group = /*#__PURE__*/groupWith( /*#__PURE__*/equivalence());\n\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 2.0.0\n */\nconst groupBy = /*#__PURE__*/dual(2, (self, f) => {\n  const out = {};\n  for (const a of self) {\n    const k = f(a);\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a);\n    } else {\n      out[k] = [a];\n    }\n  }\n  return out;\n});\n\n/**\n * @since 2.0.0\n */\nconst unionWith = isEquivalent => dual(2, (self, that) => {\n  const a = fromIterable(self);\n  const b = fromIterable(that);\n  return isNonEmptyReadonlyArray(a) && isNonEmptyReadonlyArray(b) ? unionNonEmptyWith(isEquivalent)(a, b) : isNonEmptyReadonlyArray(a) ? a : b;\n});\n\n/**\n * @since 2.0.0\n */\nconst union = /*#__PURE__*/unionWith(_equivalence);\n\n/**\n * @since 2.0.0\n */\nconst unionNonEmptyWith = isEquivalent => {\n  const dedupe = dedupeNonEmptyWith(isEquivalent);\n  return dual(2, (self, that) => dedupe(appendAllNonEmpty(self, that)));\n};\n\n/**\n * @since 2.0.0\n */\nconst unionNonEmpty = /*#__PURE__*/unionNonEmptyWith(_equivalence);\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nconst intersectionWith = isEquivalent => {\n  const has = containsWith(isEquivalent);\n  return dual(2, (self, that) => fromIterable(self).filter(a => has(that, a)));\n};\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nconst intersection = /*#__PURE__*/intersectionWith(_equivalence);\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nconst differenceWith = isEquivalent => {\n  const has = containsWith(isEquivalent);\n  return dual(2, (self, that) => fromIterable(self).filter(a => !has(that, a)));\n};\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nconst difference = /*#__PURE__*/differenceWith(_equivalence);\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst empty = () => [];\n\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst of = a => [a];\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => self.map(f));\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nconst mapNonEmpty = map;\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (isEmptyReadonlyArray(self)) {\n    return [];\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    out.push(...f(self[i], i));\n  }\n  return out;\n});\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMapNonEmpty = flatMap;\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatten = /*#__PURE__*/flatMap(identity);\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flattenNonEmpty = /*#__PURE__*/flatMapNonEmpty(identity);\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    const o = f(as[i], i);\n    if (isSome(o)) {\n      out.push(o.value);\n    }\n  }\n  return out;\n});\n\n/**\n * Transforms all elements of the `readonlyArray` for as long as the specified function returns some value\n *\n * @category filtering\n * @since 2.0.0\n */\nconst filterMapWhile = /*#__PURE__*/dual(2, (self, f) => {\n  const out = [];\n  for (const a of self) {\n    const b = f(a);\n    if (isSome(b)) {\n      out.push(b.value);\n    } else {\n      break;\n    }\n  }\n  return out;\n});\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    const e = f(as[i], i);\n    if (isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [left, right];\n});\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst compact = /*#__PURE__*/filterMap(identity);\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      out.push(as[i]);\n    }\n  }\n  return out;\n});\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      right.push(as[i]);\n    } else {\n      left.push(as[i]);\n    }\n  }\n  return [left, right];\n});\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst separate = /*#__PURE__*/partitionMap(identity);\n\n/**\n * @category folding\n * @since 2.0.0\n */\nconst reduce = /*#__PURE__*/dual(3, (self, b, f) => fromIterable(self).reduce((b, a, i) => f(b, a, i), b));\n\n/**\n * @category folding\n * @since 2.0.0\n */\nconst reduceRight = /*#__PURE__*/dual(3, (self, b, f) => fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b));\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nconst liftPredicate = predicate => b => predicate(b) ? [b] : [];\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nconst liftOption = f => (...a) => fromOption(f(...a));\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nconst fromNullable = a => a == null ? empty() : [a];\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nconst liftNullable = f => (...a) => fromNullable(f(...a));\n\n/**\n * @category combining\n * @since 2.0.0\n */\nconst flatMapNullable = /*#__PURE__*/dual(2, (self, f) => isNonEmptyReadonlyArray(self) ? fromNullable(f(headNonEmpty(self))) : empty());\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nconst liftEither = f => (...a) => {\n  const e = f(...a);\n  return isLeft(e) ? [] : [e.right];\n};\n\n/**\n * Check if a predicate holds true for every `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nconst every = /*#__PURE__*/dual(2, (self, refinement) => self.every(refinement));\n\n/**\n * Check if a predicate holds true for some `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nconst some = /*#__PURE__*/dual(2, (self, predicate) => self.some(predicate));\n\n/**\n * @since 2.0.0\n */\nconst extend = /*#__PURE__*/dual(2, (self, f) => self.map((_, i, as) => f(as.slice(i))));\n\n/**\n * @since 2.0.0\n */\nconst min = /*#__PURE__*/dual(2, (self, O) => self.reduce(min$1(O)));\n\n/**\n * @since 2.0.0\n */\nconst max = /*#__PURE__*/dual(2, (self, O) => self.reduce(max$1(O)));\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst unfold = (b, f) => {\n  const out = [];\n  let next = b;\n  let o;\n  while (isSome(o = f(next))) {\n    const [a, b] = o.value;\n    out.push(a);\n    next = b;\n  }\n  return out;\n};\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 2.0.0\n */\nconst getOrder = array;\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst getEquivalence = array$1;\n\n/**\n * Iterate over the `Iterable` applying `f`.\n *\n * @since 2.0.0\n */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => fromIterable(self).forEach((a, i) => f(a, i)));\n\n/**\n * Remove duplicates from am `Iterable` using the provided `isEquivalent` function, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n */\nconst dedupeWith = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? dedupeNonEmptyWith(isEquivalent)(input) : [];\n});\n\n/**\n * Remove duplicates from am `Iterable`, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n */\nconst dedupe = /*#__PURE__*/dedupeWith( /*#__PURE__*/equivalence());\n\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * @since 2.0.0\n */\nconst dedupeAdjacentWith = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const out = [];\n  let lastA = none();\n  for (const a of self) {\n    if (isNone(lastA) || !isEquivalent(a, lastA.value)) {\n      out.push(a);\n      lastA = some$1(a);\n    }\n  }\n  return out;\n});\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n */\nconst dedupeAdjacent = /*#__PURE__*/dedupeAdjacentWith( /*#__PURE__*/equivalence());\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @since 2.0.0\n * @category folding\n */\nconst join = /*#__PURE__*/dual(2, (self, sep) => fromIterable(self).join(sep));\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nconst mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  let s1 = s;\n  const out = [];\n  for (const a of self) {\n    const r = f(s1, a);\n    s1 = r[0];\n    out.push(r[1]);\n  }\n  return [s1, out];\n});\n\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category elements\n */\nconst cartesianWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, a => map(that, b => f(a, b))));\n\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nconst cartesian = /*#__PURE__*/dual(2, (self, that) => cartesianWith(self, that, (a, b) => [a, b]));\n\nexport { append, appendAll, appendAllNonEmpty, cartesian, cartesianWith, chop, chopNonEmpty, chunksOf, chunksOfNonEmpty, compact, contains, containsWith, copy, dedupe, dedupeAdjacent, dedupeAdjacentWith, dedupeNonEmpty, dedupeNonEmptyWith, dedupeWith, difference, differenceWith, drop, dropRight, dropWhile, empty, every, extend, filter, filterMap, filterMapWhile, findFirst, findFirstIndex, findLast, findLastIndex, flatMap, flatMapNonEmpty, flatMapNullable, flatten, flattenNonEmpty, forEach, fromIterable, fromNullable, fromOption, fromRecord, get, getEquivalence, getOrder, group, groupBy, groupWith, head, headNonEmpty, init, initNonEmpty, insertAt, intersection, intersectionWith, intersperse, intersperseNonEmpty, isEmptyArray, isEmptyReadonlyArray, isNonEmptyArray, isNonEmptyReadonlyArray, join, last, lastNonEmpty, length, liftEither, liftNullable, liftOption, liftPredicate, make, makeBy, map, mapAccum, mapNonEmpty, match, matchLeft, matchRight, max, min, modify, modifyNonEmptyHead, modifyNonEmptyLast, modifyOption, of, partition, partitionMap, prepend, prependAll, prependAllNonEmpty, range, reduce, reduceRight, remove, replace, replaceOption, replicate, reverse, reverseNonEmpty, rotate, rotateNonEmpty, scan, scanRight, separate, setNonEmptyHead, setNonEmptyLast, some, sort, sortBy, sortByNonEmpty, sortNonEmpty, sortWith, span, splitAt, splitNonEmptyAt, tail, tailNonEmpty, take, takeRight, takeWhile, unappend, unfold, union, unionNonEmpty, unionNonEmptyWith, unionWith, unprepend, unsafeGet, unzip, unzipNonEmpty, zip, zipNonEmpty, zipNonEmptyWith, zipWith };\n","import { symbol, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { make as make$1 } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual, identity, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol as symbol$1, array } from '../../Hash/dist/effect-Hash.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { none, some as some$1, liftPredicate, map as map$2, getOrElse } from '../../Option/dist/effect-Option.esm.js';\nimport { mapInput } from '../../Order/dist/effect-Order.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isObject } from '../../Predicate/dist/effect-Predicate.esm.js';\nimport { fromIterable as fromIterable$1, reverse as reverse$1, filterMap as filterMap$1, filterMapWhile as filterMapWhile$1, intersection as intersection$1, map as map$1, mapAccum as mapAccum$1, partition as partition$1, partitionMap as partitionMap$1, separate as separate$1, sort as sort$1, union as union$1, dedupe as dedupe$1, dedupeAdjacent as dedupeAdjacent$1, unzip as unzip$1, zipWith as zipWith$1, remove as remove$1, modifyOption as modifyOption$1, makeBy as makeBy$1, contains as contains$1, containsWith as containsWith$1, findFirst as findFirst$1, findFirstIndex as findFirstIndex$1, findLast as findLast$1, findLastIndex as findLastIndex$1, join as join$1, reduce as reduce$1, reduceRight as reduceRight$1 } from '../../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Chunk\");\n\n/**\n * @category symbol\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category model\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\nfunction copy(src, srcPos, dest, destPos, len) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i];\n  }\n  return dest;\n}\nconst emptyArray = [];\n\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @category equivalence\n * @since 2.0.0\n */\nconst getEquivalence = isEquivalent => make$1((self, that) => toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet(that, i))));\nconst _equivalence = /*#__PURE__*/getEquivalence(equals);\nconst ChunkProto = {\n  [TypeId]: {\n    _A: _ => _\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Chunk\",\n      values: toReadonlyArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [symbol](that) {\n    return isChunk(that) && _equivalence(this, that);\n  },\n  [symbol$1]() {\n    return array(toReadonlyArray(this));\n  },\n  [Symbol.iterator]() {\n    switch (this.backing._tag) {\n      case \"IArray\":\n        {\n          return this.backing.array[Symbol.iterator]();\n        }\n      case \"IEmpty\":\n        {\n          return emptyArray[Symbol.iterator]();\n        }\n      default:\n        {\n          return toReadonlyArray(this)[Symbol.iterator]();\n        }\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeChunk = backing => {\n  const chunk = Object.create(ChunkProto);\n  chunk.backing = backing;\n  switch (backing._tag) {\n    case \"IEmpty\":\n      {\n        chunk.length = 0;\n        chunk.depth = 0;\n        chunk.left = chunk;\n        chunk.right = chunk;\n        break;\n      }\n    case \"IConcat\":\n      {\n        chunk.length = backing.left.length + backing.right.length;\n        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);\n        chunk.left = backing.left;\n        chunk.right = backing.right;\n        break;\n      }\n    case \"IArray\":\n      {\n        chunk.length = backing.array.length;\n        chunk.depth = 0;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n    case \"ISingleton\":\n      {\n        chunk.length = 1;\n        chunk.depth = 0;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n    case \"ISlice\":\n      {\n        chunk.length = backing.length;\n        chunk.depth = backing.chunk.depth + 1;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n  }\n  return chunk;\n};\n\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @category constructors\n * @since 2.0.0\n */\nconst isChunk = u => isObject(u) && TypeId in u;\nconst _empty = /*#__PURE__*/makeChunk({\n  _tag: \"IEmpty\"\n});\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst empty = () => _empty;\n\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst make = (...as) => as.length === 1 ? of(as[0]) : unsafeFromNonEmptyArray(as);\n\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst of = a => makeChunk({\n  _tag: \"ISingleton\",\n  a\n});\n\n/**\n * Converts from an `Iterable<A>`\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromIterable = self => isChunk(self) ? self : makeChunk({\n  _tag: \"IArray\",\n  array: fromIterable$1(self)\n});\nconst copyToArray = (self, array, initial) => {\n  switch (self.backing._tag) {\n    case \"IArray\":\n      {\n        copy(self.backing.array, 0, array, initial, self.length);\n        break;\n      }\n    case \"IConcat\":\n      {\n        copyToArray(self.left, array, initial);\n        copyToArray(self.right, array, initial + self.left.length);\n        break;\n      }\n    case \"ISingleton\":\n      {\n        array[initial] = self.backing.a;\n        break;\n      }\n    case \"ISlice\":\n      {\n        let i = 0;\n        let j = initial;\n        while (i < self.length) {\n          array[j] = unsafeGet(self, i);\n          i += 1;\n          j += 1;\n        }\n        break;\n      }\n  }\n};\n\n/**\n * Converts the specified `Chunk` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toReadonlyArray = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        return emptyArray;\n      }\n    case \"IArray\":\n      {\n        return self.backing.array;\n      }\n    default:\n      {\n        const arr = new Array(self.length);\n        copyToArray(self, arr, 0);\n        self.backing = {\n          _tag: \"IArray\",\n          array: arr\n        };\n        self.left = _empty;\n        self.right = _empty;\n        self.depth = 0;\n        return arr;\n      }\n  }\n};\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst reverse = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n    case \"ISingleton\":\n      return self;\n    case \"IArray\":\n      {\n        return makeChunk({\n          _tag: \"IArray\",\n          array: reverse$1(self.backing.array)\n        });\n      }\n    case \"IConcat\":\n      {\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: reverse(self.backing.right),\n          right: reverse(self.backing.left)\n        });\n      }\n    case \"ISlice\":\n      return unsafeFromArray(reverse$1(toReadonlyArray(self)));\n  }\n};\n\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @category elements\n * @since 2.0.0\n */\nconst get = /*#__PURE__*/dual(2, (self, index) => index < 0 || index >= self.length ? none() : some$1(unsafeGet(self, index)));\n\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeFromArray = self => makeChunk({\n  _tag: \"IArray\",\n  array: self\n});\n\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeFromNonEmptyArray = self => unsafeFromArray(self);\n\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeGet = /*#__PURE__*/dual(2, (self, index) => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        throw new Error(`Index out of bounds`);\n      }\n    case \"ISingleton\":\n      {\n        if (index !== 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.a;\n      }\n    case \"IArray\":\n      {\n        if (index >= self.length || index < 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.array[index];\n      }\n    case \"IConcat\":\n      {\n        return index < self.left.length ? unsafeGet(self.left, index) : unsafeGet(self.right, index - self.left.length);\n      }\n    case \"ISlice\":\n      {\n        return unsafeGet(self.backing.chunk, index + self.backing.offset);\n      }\n  }\n});\n\n/**\n * Appends the specified element to the end of the `Chunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst append = /*#__PURE__*/dual(2, (self, a) => appendAllNonEmpty(self, of(a)));\n\n/**\n * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst prepend = /*#__PURE__*/dual(2, (self, elem) => appendAllNonEmpty(of(elem), self));\n\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nconst take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _empty;\n  } else if (n >= self.length) {\n    return self;\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\":\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self.backing.chunk,\n            length: n,\n            offset: self.backing.offset\n          });\n        }\n      case \"IConcat\":\n        {\n          if (n > self.left.length) {\n            return makeChunk({\n              _tag: \"IConcat\",\n              left: self.left,\n              right: take(self.right, n - self.left.length)\n            });\n          }\n          return take(self.left, n);\n        }\n      default:\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self,\n            offset: 0,\n            length: n\n          });\n        }\n    }\n  }\n});\n\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nconst drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  } else if (n >= self.length) {\n    return _empty;\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\":\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self.backing.chunk,\n            offset: self.backing.offset + n,\n            length: self.backing.length - n\n          });\n        }\n      case \"IConcat\":\n        {\n          if (n > self.left.length) {\n            return drop(self.right, n - self.left.length);\n          }\n          return makeChunk({\n            _tag: \"IConcat\",\n            left: drop(self.left, n),\n            right: self.right\n          });\n        }\n      default:\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self,\n            offset: n,\n            length: self.length - n\n          });\n        }\n    }\n  }\n});\n\n/**\n * Drops the last `n` elements.\n *\n * @since 2.0.0\n */\nconst dropRight = /*#__PURE__*/dual(2, (self, n) => take(self, Math.max(0, self.length - n)));\n\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n */\nconst dropWhile = /*#__PURE__*/dual(2, (self, f) => {\n  const arr = toReadonlyArray(self);\n  const len = arr.length;\n  let i = 0;\n  while (i < len && f(arr[i])) {\n    i++;\n  }\n  return drop(self, i);\n});\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAll = /*#__PURE__*/dual(2, (self, that) => appendAll(that, self));\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => prependAll(self, that));\n\n/**\n * Concatenates the two chunks\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst appendAll = /*#__PURE__*/dual(2, (self, that) => {\n  if (self.backing._tag === \"IEmpty\") {\n    return that;\n  }\n  if (that.backing._tag === \"IEmpty\") {\n    return self;\n  }\n  const diff = that.depth - self.depth;\n  if (Math.abs(diff) <= 1) {\n    return makeChunk({\n      _tag: \"IConcat\",\n      left: self,\n      right: that\n    });\n  } else if (diff < -1) {\n    if (self.left.depth >= self.right.depth) {\n      const nr = appendAll(self.right, that);\n      return makeChunk({\n        _tag: \"IConcat\",\n        left: self.left,\n        right: nr\n      });\n    } else {\n      const nrr = appendAll(self.right.right, that);\n      if (nrr.depth === self.depth - 3) {\n        const nr = makeChunk({\n          _tag: \"IConcat\",\n          left: self.right.left,\n          right: nrr\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: nr\n        });\n      } else {\n        const nl = makeChunk({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: self.right.left\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nl,\n          right: nrr\n        });\n      }\n    }\n  } else {\n    if (that.right.depth >= that.left.depth) {\n      const nl = appendAll(self, that.left);\n      return makeChunk({\n        _tag: \"IConcat\",\n        left: nl,\n        right: that.right\n      });\n    } else {\n      const nll = appendAll(self, that.left.left);\n      if (nll.depth === that.depth - 3) {\n        const nl = makeChunk({\n          _tag: \"IConcat\",\n          left: nll,\n          right: that.left.right\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nl,\n          right: that.right\n        });\n      } else {\n        const nr = makeChunk({\n          _tag: \"IConcat\",\n          left: that.left.right,\n          right: that.right\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nll,\n          right: nr\n        });\n      }\n    }\n  }\n});\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst appendAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => appendAll(self, that));\n\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filterMap = /*#__PURE__*/dual(2, (self, f) => unsafeFromArray(filterMap$1(self, f)));\n\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => unsafeFromArray(filterMap$1(self, liftPredicate(predicate))));\n\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filterMapWhile = /*#__PURE__*/dual(2, (self, f) => unsafeFromArray(filterMapWhile$1(self, f)));\n\n/**\n * Filter out optional values\n *\n * @since 2.0.0\n * @category filtering\n */\nconst compact = self => filterMap(self, identity);\n\n/**\n * Returns a chunk with the elements mapped by the specified function.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a, 0);\n  }\n  let out = _empty;\n  let i = 0;\n  for (const k of self) {\n    out = appendAll(out, f(k, i++));\n  }\n  return out;\n});\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMapNonEmpty = flatMap;\n\n/**\n * Applies the specified function to each element of the `List`.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => toReadonlyArray(self).forEach(f));\n\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatten = /*#__PURE__*/flatMap(identity);\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flattenNonEmpty = /*#__PURE__*/flatMapNonEmpty(identity);\n\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nconst chunksOf = /*#__PURE__*/dual(2, (self, n) => {\n  const gr = [];\n  let current = [];\n  toReadonlyArray(self).forEach(a => {\n    current.push(a);\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current));\n      current = [];\n    }\n  });\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current));\n  }\n  return unsafeFromArray(gr);\n});\n\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nconst intersection = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(intersection$1(toReadonlyArray(self), toReadonlyArray(that))));\n\n/**\n * Determines if the chunk is empty.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isEmpty = self => self.length === 0;\n\n/**\n * Determines if the chunk is not empty.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isNonEmpty = self => self.length > 0;\n\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nconst head = /*#__PURE__*/get(0);\n\n/**\n * Returns the first element of this chunk.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeHead = self => unsafeGet(self, 0);\n\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nconst headNonEmpty = unsafeHead;\n\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nconst last = self => get(self, self.length - 1);\n\n/**\n * Returns the last element of this chunk.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeLast = self => unsafeGet(self, self.length - 1);\n\n/**\n * Returns an effect whose success is mapped by the specified f function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? of(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map$1((a, i) => f(a, i)))));\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nconst mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  const [s1, as] = mapAccum$1(self, s, f);\n  return [s1, unsafeFromArray(as)];\n});\n\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */\nconst partition = /*#__PURE__*/dual(2, (self, predicate) => pipe(partition$1(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 2.0.0\n */\nconst partitionMap = /*#__PURE__*/dual(2, (self, f) => pipe(partitionMap$1(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 2.0.0\n */\nconst separate = self => pipe(separate$1(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);\n\n/**\n * Retireves the size of the chunk\n *\n * @since 2.0.0\n * @category elements\n */\nconst size = self => self.length;\n\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nconst sort = /*#__PURE__*/dual(2, (self, O) => unsafeFromArray(sort$1(toReadonlyArray(self), O)));\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst sortWith = /*#__PURE__*/dual(3, (self, f, order) => sort(self, mapInput(order, f)));\n\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 2.0.0\n * @category elements\n */\nconst splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 2.0.0\n * @category elements\n */\nconst split = /*#__PURE__*/dual(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));\n\n/**\n * Splits this chunk on the first element that matches this predicate.\n *\n * @category elements\n * @since 2.0.0\n */\nconst splitWhere = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      break;\n    } else {\n      i++;\n    }\n  }\n  return splitAt(self, i);\n});\n\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nconst tail = self => self.length > 0 ? some$1(drop(self, 1)) : none();\n\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nconst tailNonEmpty = self => drop(self, 1);\n\n/**\n * Takes the last `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nconst takeRight = /*#__PURE__*/dual(2, (self, n) => drop(self, self.length - n));\n\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n * @category elements\n */\nconst takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const res = [];\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      res.push(a);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(res);\n});\n\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 2.0.0\n * @category elements\n */\nconst union = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(union$1(toReadonlyArray(self), toReadonlyArray(that))));\n\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst dedupe = self => unsafeFromArray(dedupe$1(toReadonlyArray(self)));\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst dedupeAdjacent = self => unsafeFromArray(dedupeAdjacent$1(self));\n\n/**\n * Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 2.0.0\n * @category elements\n */\nconst unzip = self => {\n  const [left, right] = unzip$1(self);\n  return [unsafeFromArray(left), unsafeFromArray(right)];\n};\n\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category elements\n */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => unsafeFromArray(zipWith$1(self, that, f)));\n\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nconst zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n\n/**\n * Delete the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst remove = /*#__PURE__*/dual(2, (self, i) => unsafeFromArray(remove$1(toReadonlyArray(self), i)));\n\n/**\n * @since 2.0.0\n */\nconst modifyOption = /*#__PURE__*/dual(3, (self, i, f) => map$2(modifyOption$1(toReadonlyArray(self), i, f), unsafeFromArray));\n\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst modify = /*#__PURE__*/dual(3, (self, i, f) => getOrElse(modifyOption(self, i, f), () => self));\n\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nconst replace = /*#__PURE__*/dual(3, (self, i, b) => modify(self, i, () => b));\n\n/**\n * @since 2.0.0\n */\nconst replaceOption = /*#__PURE__*/dual(3, (self, i, b) => modifyOption(self, i, () => b));\n\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst makeBy = /*#__PURE__*/dual(2, (n, f) => fromIterable(makeBy$1(n, f)));\n\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);\n\n// -------------------------------------------------------------------------------------\n// re-exports from ReadonlyArray\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nconst contains = contains$1;\n\n/**\n * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nconst containsWith = containsWith$1;\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirst = findFirst$1;\n\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirstIndex = findFirstIndex$1;\n\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findLast = findLast$1;\n\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findLastIndex = findLastIndex$1;\n\n/**\n * Check if a predicate holds true for every `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nconst every = /*#__PURE__*/dual(2, (self, refinement) => fromIterable$1(self).every(refinement));\n\n/**\n * Check if a predicate holds true for some `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nconst some = /*#__PURE__*/dual(2, (self, predicate) => fromIterable$1(self).some(predicate));\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @category folding\n * @since 2.0.0\n */\nconst join = join$1;\n\n/**\n * @category folding\n * @since 2.0.0\n */\nconst reduce = reduce$1;\n\n/**\n * @category folding\n * @since 2.0.0\n */\nconst reduceRight = reduceRight$1;\n\nexport { append, appendAll, appendAllNonEmpty, chunksOf, compact, contains, containsWith, dedupe, dedupeAdjacent, drop, dropRight, dropWhile, empty, every, filter, filterMap, filterMapWhile, findFirst, findFirstIndex, findLast, findLastIndex, flatMap, flatMapNonEmpty, flatten, flattenNonEmpty, forEach, fromIterable, get, getEquivalence, head, headNonEmpty, intersection, isChunk, isEmpty, isNonEmpty, join, last, make, makeBy, map, mapAccum, modify, modifyOption, of, partition, partitionMap, prepend, prependAll, prependAllNonEmpty, range, reduce, reduceRight, remove, replace, replaceOption, reverse, separate, size, some, sort, sortWith, split, splitAt, splitWhere, tail, tailNonEmpty, take, takeRight, takeWhile, toReadonlyArray, union, unsafeFromArray, unsafeFromNonEmptyArray, unsafeGet, unsafeHead, unsafeLast, unzip, zip, zipWith };\n","import { symbol, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { symbol as symbol$1, number } from '../Hash/dist/effect-Hash.esm.js';\nimport { toString, NodeInspectSymbol, toJSON } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { EffectPrototype, effectVariance } from './Effectable.esm.js';\nimport { none, some } from './Option.esm.js';\n\n/** @internal */\nconst TagTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Tag\");\n\n/** @internal */\nconst STMSymbolKey = \"effect/STM\";\n\n/** @internal */\nconst STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);\n\n/** @internal */\nconst TagProto = {\n  ...EffectPrototype,\n  _tag: \"Tag\",\n  _op: \"Tag\",\n  [STMTypeId]: effectVariance,\n  [TagTypeId]: {\n    _S: _ => _,\n    _I: _ => _\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Tag\",\n      identifier: this.identifier,\n      stack: this.stack\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  of(self) {\n    return self;\n  },\n  context(self) {\n    return make(this, self);\n  }\n};\nconst tagRegistry = /*#__PURE__*/globalValue(\"effect/Context/Tag/tagRegistry\", () => new Map());\n\n/** @internal */\nconst makeTag = identifier => {\n  if (identifier && tagRegistry.has(identifier)) {\n    return tagRegistry.get(identifier);\n  }\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  const tag = Object.create(TagProto);\n  Object.defineProperty(tag, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  if (identifier) {\n    tag.identifier = identifier;\n    tagRegistry.set(identifier, tag);\n  }\n  return tag;\n};\n\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Context\");\n\n/** @internal */\nconst ContextProto = {\n  [TypeId]: {\n    _S: _ => _\n  },\n  [symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  [symbol$1]() {\n    return number(this.unsafeMap.size);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Context\",\n      services: Array.from(this.unsafeMap).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n\n/** @internal */\nconst makeContext = unsafeMap => {\n  const context = Object.create(ContextProto);\n  context.unsafeMap = unsafeMap;\n  return context;\n};\nconst serviceNotFoundError = tag => {\n  const error = new Error(`Service not found${tag.identifier ? `: ${String(tag.identifier)}` : \"\"}`);\n  if (tag.stack) {\n    const lines = tag.stack.split(\"\\n\");\n    if (lines.length > 2) {\n      const afterAt = lines[2].match(/at (.*)/);\n      if (afterAt) {\n        error.message = error.message + ` (defined at ${afterAt[1]})`;\n      }\n    }\n  }\n  if (error.stack) {\n    const lines = error.stack.split(\"\\n\");\n    lines.splice(1, 3);\n    error.stack = lines.join(\"\\n\");\n  }\n  return error;\n};\n\n/** @internal */\nconst isContext = u => typeof u === \"object\" && u !== null && TypeId in u;\n\n/** @internal */\nconst isTag = u => typeof u === \"object\" && u !== null && TagTypeId in u;\nconst _empty = /*#__PURE__*/makeContext( /*#__PURE__*/new Map());\n\n/** @internal */\nconst empty = () => _empty;\n\n/** @internal */\nconst make = (tag, service) => makeContext(new Map([[tag, service]]));\n\n/** @internal */\nconst add = /*#__PURE__*/dual(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag, service);\n  return makeContext(map);\n});\n\n/** @internal */\nconst unsafeGet = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    throw serviceNotFoundError(tag);\n  }\n  return self.unsafeMap.get(tag);\n});\n\n/** @internal */\nconst get = unsafeGet;\n\n/** @internal */\nconst getOption = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    return none;\n  }\n  return some(self.unsafeMap.get(tag));\n});\n\n/** @internal */\nconst merge = /*#__PURE__*/dual(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n\n/** @internal */\nconst pick = (...tags) => self => {\n  const tagSet = new Set(tags);\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return makeContext(newEnv);\n};\n\n/** @internal */\nconst omit = (...tags) => self => {\n  const newEnv = new Map(self.unsafeMap);\n  for (const tag of tags) {\n    newEnv.delete(tag);\n  }\n  return makeContext(newEnv);\n};\n\nexport { ContextProto, STMTypeId, TagProto, TagTypeId, TypeId, add, empty, get, getOption, isContext, isTag, make, makeContext, makeTag, merge, omit, pick, unsafeGet };\n","import { makeTag, makeContext, isContext as isContext$1, isTag as isTag$1, empty as empty$1, make as make$1, add as add$1, get as get$1, unsafeGet as unsafeGet$1, getOption as getOption$1, merge as merge$1, pick as pick$1, omit as omit$1 } from '../../internal/Context.esm.js';\n\n/**\n * This module provides a data structure called `Context` that can be used for dependency injection in effectful\n * programs. It is essentially a table mapping `Tag`s to their implementations (called `Service`s), and can be used to\n * manage dependencies in a type-safe way. The `Context` data structure is essentially a way of providing access to a set\n * of related services that can be passed around as a single unit. This module provides functions to create, modify, and\n * query the contents of a `Context`, as well as a number of utility types for working with tags and services.\n *\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * Specifying the `key` will make the `Tag` global, meaning two tags with the same\n * key will map to the same instance.\n *\n * Note: this is useful for cases where live reload can happen and it is\n * desireable to preserve the instance across reloads.\n *\n * @param key - An optional key that makes the `Tag` global.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * assert.strictEqual(Context.Tag() === Context.Tag(), false)\n * assert.strictEqual(Context.Tag(\"PORT\") === Context.Tag(\"PORT\"), true)\n *\n * @since 2.0.0\n * @category constructors\n */\nconst Tag = makeTag;\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst unsafeMake = makeContext;\n\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @param input - The value to be checked if it is a `Context`.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 2.0.0\n * @category guards\n */\nconst isContext = isContext$1;\n\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @param input - The value to be checked if it is a `Tag`.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * assert.strictEqual(Context.isTag(Context.Tag()), true)\n *\n * @since 2.0.0\n * @category guards\n */\nconst isTag = isTag$1;\n\n/**\n * Returns an empty `Context`.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * import * as Context from \"effect/Context\"\n * import { pipe } from \"effect/Function\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n */\nconst add = add$1;\n\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import * as Context from \"effect/Context\"\n * import { pipe } from \"effect/Function\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n * @category getters\n */\nconst get = get$1;\n\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeGet = unsafeGet$1;\n\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import * as Context from \"effect/Context\"\n * import * as O from \"effect/Option\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), O.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), O.none())\n *\n * @since 2.0.0\n * @category getters\n */\nconst getOption = getOption$1;\n\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @param self - The first `Context` to merge.\n * @param that - The second `Context` to merge.\n *\n * @example\n * import * as Context from \"effect/Context\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n */\nconst merge = merge$1;\n\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @param self - The `Context` to prune services from.\n * @param tags - The list of `Tag`s to be included in the new `Context`.\n *\n * @example\n * import * as Context from \"effect/Context\"\n * import { pipe } from \"effect/Function\"\n * import * as O from \"effect/Option\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), O.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), O.none())\n *\n * @since 2.0.0\n */\nconst pick = pick$1;\n\n/**\n * @since 2.0.0\n */\nconst omit = omit$1;\n\nexport { Tag, add, empty, get, getOption, isContext, isTag, make, merge, omit, pick, unsafeGet, unsafeMake };\n","import { of, isNonEmpty, headNonEmpty, tailNonEmpty, prepend } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { makeContext } from '../Context.esm.js';\nimport { Structural } from '../Data.esm.js';\n\n/** @internal */\nconst ContextPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferContextPatch\");\nfunction variance(a) {\n  return a;\n}\n\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [ContextPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n\n/**\n * @internal\n */\nconst empty = () => _empty;\n\n/** @internal */\n\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\n\n/** @internal */\n\nconst AddServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AddService\"\n});\nconst makeAddService = (tag, service) => {\n  const o = Object.create(AddServiceProto);\n  o.tag = tag;\n  o.service = service;\n  return o;\n};\n\n/** @internal */\n\nconst RemoveServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"RemoveService\"\n});\nconst makeRemoveService = tag => {\n  const o = Object.create(RemoveServiceProto);\n  o.tag = tag;\n  return o;\n};\n\n/** @internal */\n\nconst UpdateServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"UpdateService\"\n});\nconst makeUpdateService = (tag, update) => {\n  const o = Object.create(UpdateServiceProto);\n  o.tag = tag;\n  o.update = update;\n  return o;\n};\n/** @internal */\nconst diff = (oldValue, newValue) => {\n  const missingServices = new Map(oldValue.unsafeMap);\n  let patch = empty();\n  for (const [tag, newService] of newValue.unsafeMap.entries()) {\n    if (missingServices.has(tag)) {\n      const old = missingServices.get(tag);\n      missingServices.delete(tag);\n      if (!equals(old, newService)) {\n        patch = combine(makeUpdateService(tag, () => newService))(patch);\n      }\n    } else {\n      missingServices.delete(tag);\n      patch = combine(makeAddService(tag, newService))(patch);\n    }\n  }\n  for (const [tag] of missingServices.entries()) {\n    patch = combine(makeRemoveService(tag))(patch);\n  }\n  return patch;\n};\n\n/** @internal */\nconst combine = /*#__PURE__*/dual(2, (self, that) => makeAndThen(self, that));\n\n/** @internal */\nconst patch = /*#__PURE__*/dual(2, (self, context) => {\n  let wasServiceUpdated = false;\n  let patches = of(self);\n  const updatedContext = new Map(context.unsafeMap);\n  while (isNonEmpty(patches)) {\n    const head = headNonEmpty(patches);\n    const tail = tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AddService\":\n        {\n          updatedContext.set(head.tag, head.service);\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = prepend(prepend(tail, head.second), head.first);\n          break;\n        }\n      case \"RemoveService\":\n        {\n          updatedContext.delete(head.tag);\n          patches = tail;\n          break;\n        }\n      case \"UpdateService\":\n        {\n          updatedContext.set(head.tag, head.update(updatedContext.get(head.tag)));\n          wasServiceUpdated = true;\n          patches = tail;\n          break;\n        }\n    }\n  }\n  if (!wasServiceUpdated) {\n    return makeContext(updatedContext);\n  }\n  const map = new Map();\n  for (const [tag] of context.unsafeMap) {\n    if (updatedContext.has(tag)) {\n      map.set(tag, updatedContext.get(tag));\n      updatedContext.delete(tag);\n    }\n  }\n  for (const [tag, s] of updatedContext) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n\nexport { ContextPatchTypeId, combine, diff, empty, patch };\n","/** @internal */\nconst SIZE = 5;\n\n/** @internal */\nconst BUCKET_SIZE = /*#__PURE__*/Math.pow(2, SIZE);\n\n/** @internal */\nconst MASK = BUCKET_SIZE - 1;\n\n/** @internal */\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2;\n\n/** @internal */\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n\nexport { BUCKET_SIZE, MASK, MAX_INDEX_NODE, MIN_ARRAY_NODE, SIZE };\n","import { MASK } from './config.esm.js';\n\n/**\n * Hamming weight.\n *\n * Taken from: http://jsperf.com/hamming-weight\n *\n * @internal\n */\nfunction popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\n/** @internal */\nfunction hashFragment(shift, h) {\n  return h >>> shift & MASK;\n}\n\n/** @internal */\nfunction toBitmap(x) {\n  return 1 << x;\n}\n\n/** @internal */\nfunction fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n}\n\nexport { fromBitmap, hashFragment, popcount, toBitmap };\n","/** @internal */\nfunction arrayUpdate(mutate, at, v, arr) {\n  let out = arr;\n  if (!mutate) {\n    const len = arr.length;\n    out = new Array(len);\n    for (let i = 0; i < len; ++i) out[i] = arr[i];\n  }\n  out[at] = v;\n  return out;\n}\n\n/** @internal */\nfunction arraySpliceOut(mutate, at, arr) {\n  const newLen = arr.length - 1;\n  let i = 0;\n  let g = 0;\n  let out = arr;\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n    while (i < at) out[g++] = arr[i++];\n  }\n  ++i;\n  while (i <= newLen) out[g++] = arr[i++];\n  if (mutate) {\n    out.length = newLen;\n  }\n  return out;\n}\n\n/** @internal */\nfunction arraySpliceIn(mutate, at, v, arr) {\n  const len = arr.length;\n  if (mutate) {\n    let i = len;\n    while (i >= at) arr[i--] = arr[i];\n    arr[at] = v;\n    return arr;\n  }\n  let i = 0,\n    g = 0;\n  const out = new Array(len + 1);\n  while (i < at) out[g++] = arr[i++];\n  out[at] = v;\n  while (i < len) out[++g] = arr[i++];\n  return out;\n}\n\nexport { arraySpliceIn, arraySpliceOut, arrayUpdate };\n","/** @internal */\nclass Stack {\n  constructor(value, previous) {\n    this.value = value;\n    this.previous = previous;\n  }\n}\n\nexport { Stack };\n","import { equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { arraySpliceOut, arrayUpdate, arraySpliceIn } from './array.esm.js';\nimport { hashFragment, toBitmap, fromBitmap } from './bitwise.esm.js';\nimport { SIZE, MAX_INDEX_NODE, MIN_ARRAY_NODE } from './config.esm.js';\nimport { Stack } from '../Stack.esm.js';\nimport { none, isNone } from '../../Option/dist/effect-Option.esm.js';\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nclass EmptyNode {\n  _tag = \"EmptyNode\";\n  modify(edit, _shift, f, hash, key, size) {\n    const v = f(none());\n    if (isNone(v)) return new EmptyNode();\n    ++size.value;\n    return new LeafNode(edit, hash, key, v);\n  }\n}\n\n/** @internal */\nfunction isEmptyNode(a) {\n  return a instanceof EmptyNode;\n}\n\n/** @internal */\nfunction isLeafNode(node) {\n  return isEmptyNode(node) || node._tag === \"LeafNode\" || node._tag === \"CollisionNode\";\n}\n\n/** @internal */\nfunction canEditNode(node, edit) {\n  return isEmptyNode(node) ? false : edit === node.edit;\n}\n\n/** @internal */\nclass LeafNode {\n  _tag = \"LeafNode\";\n  constructor(edit, hash, key, value) {\n    this.edit = edit;\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (equals(key, this.key)) {\n      const v = f(this.value);\n      if (v === this.value) return this;else if (isNone(v)) {\n        --size.value;\n        return new EmptyNode();\n      }\n      if (canEditNode(this, edit)) {\n        this.value = v;\n        return this;\n      }\n      return new LeafNode(edit, hash, key, v);\n    }\n    const v = f(none());\n    if (isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n}\n\n/** @internal */\nclass CollisionNode {\n  _tag = \"CollisionNode\";\n  constructor(edit, hash, children) {\n    this.edit = edit;\n    this.hash = hash;\n    this.children = children;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (hash === this.hash) {\n      const canEdit = canEditNode(this, edit);\n      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    const v = f(none());\n    if (isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n  updateCollisionList(mutate, edit, hash, list, f, key, size) {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n      const child = list[i];\n      if (\"key\" in child && equals(key, child.key)) {\n        const value = child.value;\n        const newValue = f(value);\n        if (newValue === value) return list;\n        if (isNone(newValue)) {\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list);\n      }\n    }\n    const newValue = f(none());\n    if (isNone(newValue)) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list);\n  }\n}\n\n/** @internal */\nclass IndexedNode {\n  _tag = \"IndexedNode\";\n  constructor(edit, mask, children) {\n    this.edit = edit;\n    this.mask = mask;\n    this.children = children;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = hashFragment(shift, hash);\n    const bit = toBitmap(frag);\n    const indx = fromBitmap(mask, bit);\n    const exists = mask & bit;\n    const canEdit = canEditNode(this, edit);\n    if (!exists) {\n      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash, key, size);\n      if (!_newChild) return this;\n      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));\n    }\n    const current = children[indx];\n    const child = current.modify(edit, shift + SIZE, f, hash, key, size);\n    if (current === child) return this;\n    let bitmap = mask;\n    let newChildren;\n    if (isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return new EmptyNode();\n      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {\n        return children[indx ^ 1]; // collapse\n      }\n\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n    return new IndexedNode(edit, bitmap, newChildren);\n  }\n}\n\n/** @internal */\nclass ArrayNode {\n  _tag = \"ArrayNode\";\n  constructor(edit, size, children) {\n    this.edit = edit;\n    this.size = size;\n    this.children = children;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    let count = this.size;\n    const children = this.children;\n    const frag = hashFragment(shift, hash);\n    const child = children[frag];\n    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash, key, size);\n    if (child === newChild) return this;\n    const canEdit = canEditNode(this, edit);\n    let newChildren;\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      --count;\n      if (count <= MIN_ARRAY_NODE) {\n        return pack(edit, count, frag, children);\n      }\n      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n    return new ArrayNode(edit, count, newChildren);\n  }\n}\nfunction pack(edit, count, removed, elements) {\n  const children = new Array(count - 1);\n  let g = 0;\n  let bitmap = 0;\n  for (let i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      const elem = elements[i];\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n  return new IndexedNode(edit, bitmap, children);\n}\nfunction expand(edit, frag, child, bitmap, subNodes) {\n  const arr = [];\n  let bit = bitmap;\n  let count = 0;\n  for (let i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n  arr[frag] = child;\n  return new ArrayNode(edit, count + 1, arr);\n}\nfunction mergeLeavesInner(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);\n  const subH1 = hashFragment(shift, h1);\n  const subH2 = hashFragment(shift, h2);\n  if (subH1 === subH2) {\n    return child => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);\n  } else {\n    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];\n    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);\n  }\n}\nfunction mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  let stack = undefined;\n  let currentShift = shift;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);\n    if (typeof res === \"function\") {\n      stack = new Stack(res, stack);\n      currentShift = currentShift + SIZE;\n    } else {\n      let final = res;\n      while (stack != null) {\n        final = stack.value(final);\n        stack = stack.previous;\n      }\n      return final;\n    }\n  }\n}\n\nexport { ArrayNode, CollisionNode, EmptyNode, IndexedNode, LeafNode, canEditNode, isEmptyNode, isLeafNode };\n","import { equals, symbol as symbol$1 } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual, pipe, identity } from '../Function/dist/effect-Function.esm.js';\nimport { hash, symbol, combine } from '../Hash/dist/effect-Hash.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { hashFragment, fromBitmap, toBitmap } from './HashMap/bitwise.esm.js';\nimport { SIZE } from './HashMap/config.esm.js';\nimport { isEmptyNode, EmptyNode } from './HashMap/node.esm.js';\nimport { none, isNone, isSome, some, map as map$1 } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isObject } from '../Predicate/dist/effect-Predicate.esm.js';\n\n/** @internal */\nconst HashMapTypeId = /*#__PURE__*/Symbol.for(\"effect/HashMap\");\n\n/** @internal */\n\nconst HashMapProto = {\n  [HashMapTypeId]: HashMapTypeId,\n  [Symbol.iterator]() {\n    return new HashMapIterator(this, (k, v) => [k, v]);\n  },\n  [symbol]() {\n    let hash$1 = hash(\"HashMap\");\n    for (const item of this) {\n      hash$1 ^= combine(hash(item[0]))(hash(item[1]));\n    }\n    return hash$1;\n  },\n  [symbol$1](that) {\n    if (isHashMap(that)) {\n      if (that._size !== this._size) {\n        return false;\n      }\n      for (const item of this) {\n        const elem = pipe(that, getHash(item[0], hash(item[0])));\n        if (isNone(elem)) {\n          return false;\n        } else {\n          if (!equals(item[1], elem.value)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"HashMap\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeImpl = (editable, edit, root, size) => {\n  const map = Object.create(HashMapProto);\n  map._editable = editable;\n  map._edit = edit;\n  map._root = root;\n  map._size = size;\n  return map;\n};\nclass HashMapIterator {\n  constructor(map, f) {\n    this.map = map;\n    this.f = f;\n    this.v = visitLazy(this.map._root, this.f, undefined);\n  }\n  next() {\n    if (isNone(this.v)) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const v0 = this.v.value;\n    this.v = applyCont(v0.cont);\n    return {\n      done: false,\n      value: v0.value\n    };\n  }\n  [Symbol.iterator]() {\n    return new HashMapIterator(this.map, this.f);\n  }\n}\nconst applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none();\nconst visitLazy = (node, f, cont = undefined) => {\n  switch (node._tag) {\n    case \"LeafNode\":\n      {\n        if (isSome(node.value)) {\n          return some({\n            value: f(node.key, node.value.value),\n            cont\n          });\n        }\n        return applyCont(cont);\n      }\n    case \"CollisionNode\":\n    case \"ArrayNode\":\n    case \"IndexedNode\":\n      {\n        const children = node.children;\n        return visitLazyChildren(children.length, children, 0, f, cont);\n      }\n    default:\n      {\n        return applyCont(cont);\n      }\n  }\n};\nconst visitLazyChildren = (len, children, i, f, cont) => {\n  while (i < len) {\n    const child = children[i++];\n    if (child && !isEmptyNode(child)) {\n      return visitLazy(child, f, [len, children, i, f, cont]);\n    }\n  }\n  return applyCont(cont);\n};\nconst _empty = /*#__PURE__*/makeImpl(false, 0, /*#__PURE__*/new EmptyNode(), 0);\n\n/** @internal */\nconst empty = () => _empty;\n\n/** @internal */\nconst make = (...entries) => fromIterable(entries);\n\n/** @internal */\nconst fromIterable = entries => {\n  const map = beginMutation(empty());\n  for (const entry of entries) {\n    set(entry[0], entry[1])(map);\n  }\n  return endMutation(map);\n};\n\n/** @internal */\nconst isHashMap = u => isObject(u) && HashMapTypeId in u;\n\n/** @internal */\nconst isEmpty = self => self && isEmptyNode(self._root);\n\n/** @internal */\nconst get = /*#__PURE__*/dual(2, (self, key) => getHash(self, key, hash(key)));\n\n/** @internal */\nconst getHash = /*#__PURE__*/dual(3, (self, key, hash) => {\n  let node = self._root;\n  let shift = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    switch (node._tag) {\n      case \"LeafNode\":\n        {\n          return equals(key, node.key) ? node.value : none();\n        }\n      case \"CollisionNode\":\n        {\n          if (hash === node.hash) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; ++i) {\n              const child = children[i];\n              if (\"key\" in child && equals(key, child.key)) {\n                return child.value;\n              }\n            }\n          }\n          return none();\n        }\n      case \"IndexedNode\":\n        {\n          const frag = hashFragment(shift, hash);\n          const bit = toBitmap(frag);\n          if (node.mask & bit) {\n            node = node.children[fromBitmap(node.mask, bit)];\n            shift += SIZE;\n            break;\n          }\n          return none();\n        }\n      case \"ArrayNode\":\n        {\n          node = node.children[hashFragment(shift, hash)];\n          if (node) {\n            shift += SIZE;\n            break;\n          }\n          return none();\n        }\n      default:\n        return none();\n    }\n  }\n});\n\n/** @internal */\nconst unsafeGet = /*#__PURE__*/dual(2, (self, key) => {\n  const element = getHash(self, key, hash(key));\n  if (isNone(element)) {\n    throw new Error(\"Error: Expected map to contain key\");\n  }\n  return element.value;\n});\n\n/** @internal */\nconst has = /*#__PURE__*/dual(2, (self, key) => isSome(getHash(self, key, hash(key))));\n\n/** @internal */\nconst hasHash = /*#__PURE__*/dual(3, (self, key, hash) => isSome(getHash(self, key, hash)));\n\n/** @internal */\nconst set = /*#__PURE__*/dual(3, (self, key, value) => modifyAt(self, key, () => some(value)));\n\n/** @internal */\nconst setTree = /*#__PURE__*/dual(3, (self, newRoot, newSize) => {\n  if (self._editable) {\n    self._root = newRoot;\n    self._size = newSize;\n    return self;\n  }\n  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);\n});\n\n/** @internal */\nconst keys = self => new HashMapIterator(self, key => key);\n\n/** @internal */\nconst values = self => new HashMapIterator(self, (_, value) => value);\n\n/** @internal */\nconst size = self => self._size;\n\n/** @internal */\nconst beginMutation = self => makeImpl(true, self._edit + 1, self._root, self._size);\n\n/** @internal */\nconst endMutation = self => {\n  self._editable = false;\n  return self;\n};\n\n/** @internal */\nconst mutate = /*#__PURE__*/dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n\n/** @internal */\nconst modifyAt = /*#__PURE__*/dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));\n\n/** @internal */\nconst modifyHash = /*#__PURE__*/dual(4, (self, key, hash, f) => {\n  const size = {\n    value: self._size\n  };\n  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);\n  return pipe(self, setTree(newRoot, size.value));\n});\n\n/** @internal */\nconst modify = /*#__PURE__*/dual(3, (self, key, f) => modifyAt(self, key, map$1(f)));\n\n/** @internal */\nconst union = /*#__PURE__*/dual(2, (self, that) => {\n  const result = beginMutation(self);\n  forEach(that, (v, k) => set(result, k, v));\n  return endMutation(result);\n});\n\n/** @internal */\nconst remove = /*#__PURE__*/dual(2, (self, key) => modifyAt(self, key, none));\n\n/** @internal */\nconst removeMany = /*#__PURE__*/dual(2, (self, keys) => mutate(self, map => {\n  for (const key of keys) {\n    remove(key)(map);\n  }\n}));\n\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => reduce(self, empty(), (map, value, key) => set(map, key, f(value, key))));\n\n/** @internal */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => reduce(self, empty(), (zero, value, key) => mutate(zero, map => forEach(f(value, key), (value, key) => set(map, key, value)))));\n\n/** @internal */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => reduce(self, void 0, (_, value, key) => f(value, key)));\n\n/** @internal */\nconst reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  const root = self._root;\n  if (root._tag === \"LeafNode\") {\n    return isSome(root.value) ? f(zero, root.value.value, root.key) : zero;\n  }\n  if (root._tag === \"EmptyNode\") {\n    return zero;\n  }\n  const toVisit = [root.children];\n  let children;\n  while (children = toVisit.pop()) {\n    for (let i = 0, len = children.length; i < len;) {\n      const child = children[i++];\n      if (child && !isEmptyNode(child)) {\n        if (child._tag === \"LeafNode\") {\n          if (isSome(child.value)) {\n            zero = f(zero, child.value.value, child.key);\n          }\n        } else {\n          toVisit.push(child.children);\n        }\n      }\n    }\n  }\n  return zero;\n});\n\n/** @internal */\nconst filter = /*#__PURE__*/dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    if (f(a, k)) {\n      set(map, k, a);\n    }\n  }\n}));\n\n/** @internal */\nconst compact = self => filterMap(self, identity);\n\n/** @internal */\nconst filterMap = /*#__PURE__*/dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    const option = f(a, k);\n    if (isSome(option)) {\n      set(map, k, option.value);\n    }\n  }\n}));\n\n/** @internal */\nconst findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  for (const ka of self) {\n    if (predicate(ka[0], ka[1])) {\n      return some(ka);\n    }\n  }\n  return none();\n});\n\nexport { HashMapTypeId, beginMutation, compact, empty, endMutation, filter, filterMap, findFirst, flatMap, forEach, fromIterable, get, getHash, has, hasHash, isEmpty, isHashMap, keys, make, map, modify, modifyAt, modifyHash, mutate, reduce, remove, removeMany, set, setTree, size, union, unsafeGet, values };\n","import { symbol as symbol$1, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../Hash/dist/effect-Hash.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { has as has$1, keys, size as size$1, beginMutation as beginMutation$1, set, remove as remove$1, forEach as forEach$1, reduce as reduce$1, empty as empty$1 } from './HashMap.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isObject } from '../Predicate/dist/effect-Predicate.esm.js';\n\n/** @internal */\nconst HashSetTypeId = /*#__PURE__*/Symbol.for(\"effect/HashSet\");\n\n/** @internal */\n\nconst HashSetProto = {\n  [HashSetTypeId]: HashSetTypeId,\n  [Symbol.iterator]() {\n    return keys(this._keyMap);\n  },\n  [symbol]() {\n    return combine(hash(this._keyMap))(hash(\"HashSet\"));\n  },\n  [symbol$1](that) {\n    if (isHashSet(that)) {\n      return size$1(this._keyMap) === size$1(that._keyMap) && equals(this._keyMap, that._keyMap);\n    }\n    return false;\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"HashSet\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst makeImpl = keyMap => {\n  const set = Object.create(HashSetProto);\n  set._keyMap = keyMap;\n  return set;\n};\n\n/** @internal */\nconst isHashSet = u => isObject(u) && HashSetTypeId in u;\nconst _empty = /*#__PURE__*/makeImpl( /*#__PURE__*/empty$1());\n\n/** @internal */\nconst empty = () => _empty;\n\n/** @internal */\nconst fromIterable = elements => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n\n/** @internal */\nconst make = (...elements) => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n\n/** @internal */\nconst has = /*#__PURE__*/dual(2, (self, value) => has$1(self._keyMap, value));\n\n/** @internal */\nconst some = /*#__PURE__*/dual(2, (self, f) => {\n  let found = false;\n  for (const value of self) {\n    found = f(value);\n    if (found) {\n      break;\n    }\n  }\n  return found;\n});\n\n/** @internal */\nconst every = /*#__PURE__*/dual(2, (self, refinement) => !some(self, a => !refinement(a)));\n\n/** @internal */\nconst isSubset = /*#__PURE__*/dual(2, (self, that) => every(self, value => has(that, value)));\n\n/** @internal */\nconst values = self => keys(self._keyMap);\n\n/** @internal */\nconst size = self => size$1(self._keyMap);\n\n/** @internal */\nconst beginMutation = self => makeImpl(beginMutation$1(self._keyMap));\n\n/** @internal */\nconst endMutation = self => {\n  self._keyMap._editable = false;\n  return self;\n};\n\n/** @internal */\nconst mutate = /*#__PURE__*/dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n\n/** @internal */\nconst add = /*#__PURE__*/dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl(set(value, true)(self._keyMap)));\n\n/** @internal */\nconst remove = /*#__PURE__*/dual(2, (self, value) => self._keyMap._editable ? (remove$1(value)(self._keyMap), self) : makeImpl(remove$1(value)(self._keyMap)));\n\n/** @internal */\nconst difference = /*#__PURE__*/dual(2, (self, that) => mutate(self, set => {\n  for (const value of that) {\n    remove(set, value);\n  }\n}));\n\n/** @internal */\nconst intersection = /*#__PURE__*/dual(2, (self, that) => mutate(empty(), set => {\n  for (const value of that) {\n    if (has(value)(self)) {\n      add(value)(set);\n    }\n  }\n}));\n\n/** @internal */\nconst union = /*#__PURE__*/dual(2, (self, that) => mutate(empty(), set => {\n  forEach(self, value => add(set, value));\n  for (const value of that) {\n    add(set, value);\n  }\n}));\n\n/** @internal */\nconst toggle = /*#__PURE__*/dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    const b = f(a);\n    if (!has(set, b)) {\n      add(set, b);\n    }\n  });\n}));\n\n/** @internal */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    for (const b of f(a)) {\n      if (!has(set, b)) {\n        add(set, b);\n      }\n    }\n  });\n}));\n\n/** @internal */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => forEach$1(self._keyMap, (_, k) => f(k)));\n\n/** @internal */\nconst reduce = /*#__PURE__*/dual(3, (self, zero, f) => reduce$1(self._keyMap, zero, (z, _, a) => f(z, a)));\n\n/** @internal */\nconst filter = /*#__PURE__*/dual(2, (self, f) => {\n  return mutate(empty(), set => {\n    const iterator = values(self);\n    let next;\n    while (!(next = iterator.next()).done) {\n      const value = next.value;\n      if (f(value)) {\n        add(set, value);\n      }\n    }\n  });\n});\n\n/** @internal */\nconst partition = /*#__PURE__*/dual(2, (self, f) => {\n  const iterator = values(self);\n  let next;\n  const right = beginMutation(empty());\n  const left = beginMutation(empty());\n  while (!(next = iterator.next()).done) {\n    const value = next.value;\n    if (f(value)) {\n      add(right, value);\n    } else {\n      add(left, value);\n    }\n  }\n  return [endMutation(left), endMutation(right)];\n});\n\nexport { HashSetTypeId, add, beginMutation, difference, empty, endMutation, every, filter, flatMap, forEach, fromIterable, has, intersection, isHashSet, isSubset, make, makeImpl, map, mutate, partition, reduce, remove, size, some, toggle, union, values };\n","import { isHashMap as isHashMap$1, empty as empty$1, make as make$1, fromIterable as fromIterable$1, isEmpty as isEmpty$1, get as get$1, getHash as getHash$1, unsafeGet as unsafeGet$1, has as has$1, hasHash as hasHash$1, set as set$1, keys as keys$1, values as values$1, size as size$1, beginMutation as beginMutation$1, endMutation as endMutation$1, mutate as mutate$1, modifyAt as modifyAt$1, modifyHash as modifyHash$1, modify as modify$1, union as union$1, remove as remove$1, removeMany as removeMany$1, map as map$1, flatMap as flatMap$1, forEach as forEach$1, reduce as reduce$1, filter as filter$1, compact as compact$1, filterMap as filterMap$1, findFirst as findFirst$1 } from '../../internal/HashMap.esm.js';\nimport { keySet as keySet$1 } from '../../internal/HashMap/keySet.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isHashMap = isHashMap$1;\n\n/**\n * Creates a new `HashMap`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Constructs a new `HashMap` from an array of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Constructs a new `HashMap` from an iterable of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = fromIterable$1;\n\n/**\n * Checks if the `HashMap` contains any entries.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isEmpty = isEmpty$1;\n\n/**\n * Safely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category elements\n */\nconst get = get$1;\n\n/**\n * Lookup the value for the specified key in the `HashMap` using a custom hash.\n *\n * @since 2.0.0\n * @category elements\n */\nconst getHash = getHash$1;\n\n/**\n * Unsafely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeGet = unsafeGet$1;\n\n/**\n * Checks if the specified key has an entry in the `HashMap`.\n *\n * @since 2.0.0\n * @category elements\n */\nconst has = has$1;\n\n/**\n * Checks if the specified key has an entry in the `HashMap` using a custom\n * hash.\n *\n * @since 2.0.0\n * @category elements\n */\nconst hasHash = hasHash$1;\n\n/**\n * Sets the specified key to the specified value using the internal hashing\n * function.\n *\n * @since 2.0.0\n */\nconst set = set$1;\n\n/**\n * Returns an `IterableIterator` of the keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst keys = keys$1;\n\n/**\n * Returns a `HashSet` of keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getter\n */\nconst keySet = keySet$1;\n\n/**\n * Returns an `IterableIterator` of the values within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst values = values$1;\n\n/**\n * Returns the number of entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = size$1;\n\n/**\n * Marks the `HashMap` as mutable.\n *\n * @since 2.0.0\n */\nconst beginMutation = beginMutation$1;\n\n/**\n * Marks the `HashMap` as immutable.\n *\n * @since 2.0.0\n */\nconst endMutation = endMutation$1;\n\n/**\n * Mutates the `HashMap` within the context of the provided function.\n *\n * @since 2.0.0\n */\nconst mutate = mutate$1;\n\n/**\n * Set or remove the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * @since 2.0.0\n */\nconst modifyAt = modifyAt$1;\n\n/**\n * Alter the value of the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * This function will always either update or insert a value into the `HashMap`.\n *\n * @since 2.0.0\n */\nconst modifyHash = modifyHash$1;\n\n/**\n * Updates the value of the specified key within the `HashMap` if it exists.\n *\n * @since 2.0.0\n */\nconst modify = modify$1;\n\n/**\n * Performs a union of this `HashMap` and that `HashMap`.\n *\n * @since 2.0.0\n */\nconst union = union$1;\n\n/**\n * Remove the entry for the specified key in the `HashMap` using the internal\n * hashing function.\n *\n * @since 2.0.0\n */\nconst remove = remove$1;\n\n/**\n * Removes all entries in the `HashMap` which have the specified keys.\n *\n * @since 2.0.0\n */\nconst removeMany = removeMany$1;\n\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * Chains over the entries of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = flatMap$1;\n\n/**\n * Applies the specified function to the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEach = forEach$1;\n\n/**\n * Reduces the specified state over the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduce = reduce$1;\n\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filter = filter$1;\n\n/**\n * Filters out `None` values from a `HashMap` of `Options`s.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst compact = compact$1;\n\n/**\n * Maps over the entries of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filterMap = filterMap$1;\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirst = findFirst$1;\n\nexport { beginMutation, compact, empty, endMutation, filter, filterMap, findFirst, flatMap, forEach, fromIterable, get, getHash, has, hasHash, isEmpty, isHashMap, keySet, keys, make, map, modify, modifyAt, modifyHash, mutate, reduce, remove, removeMany, set, size, union, unsafeGet, values };\n","import { isHashSet as isHashSet$1, empty as empty$1, fromIterable as fromIterable$1, make as make$1, has as has$1, some as some$1, every as every$1, isSubset as isSubset$1, values as values$1, size as size$1, beginMutation as beginMutation$1, endMutation as endMutation$1, mutate as mutate$1, add as add$1, remove as remove$1, difference as difference$1, intersection as intersection$1, union as union$1, toggle as toggle$1, map as map$1, flatMap as flatMap$1, forEach as forEach$1, reduce as reduce$1, filter as filter$1, partition as partition$1 } from '../../internal/HashSet.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isHashSet = isHashSet$1;\n\n/**\n * Creates an empty `HashSet`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Construct a new `HashSet` from a `Collection` of values\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = fromIterable$1;\n\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * @since 2.0.0\n * @category elements\n */\nconst has = has$1;\n\n/**\n * Check if a predicate holds true for some `HashSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst some = some$1;\n\n/**\n * Check if a predicate holds true for every `HashSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst every = every$1;\n\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isSubset = isSubset$1;\n\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst values = values$1;\n\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = size$1;\n\n/**\n * Marks the `HashSet` as mutable.\n *\n * @since 2.0.0\n */\nconst beginMutation = beginMutation$1;\n\n/**\n * Marks the `HashSet` as immutable.\n *\n * @since 2.0.0\n */\nconst endMutation = endMutation$1;\n\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * @since 2.0.0\n */\nconst mutate = mutate$1;\n\n/**\n * Adds a value to the `HashSet`.\n *\n * @since 2.0.0\n */\nconst add = add$1;\n\n/**\n * Removes a value from the `HashSet`.\n *\n * @since 2.0.0\n */\nconst remove = remove$1;\n\n/**\n * Computes the set difference between this `HashSet` and the specified\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 2.0.0\n */\nconst difference = difference$1;\n\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 2.0.0\n */\nconst intersection = intersection$1;\n\n/**\n * Computes the set union `(`self` + `that`)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 2.0.0\n */\nconst union = union$1;\n\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * @since 2.0.0\n */\nconst toggle = toggle$1;\n\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = flatMap$1;\n\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEach = forEach$1;\n\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduce = reduce$1;\n\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filter = filter$1;\n\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * @since 2.0.0\n * @category partitioning\n */\nconst partition = partition$1;\n\nexport { add, beginMutation, difference, empty, endMutation, every, filter, flatMap, forEach, fromIterable, has, intersection, isHashSet, isSubset, make, map, mutate, partition, reduce, remove, size, some, toggle, union, values };\n","import { of, isNonEmpty, headNonEmpty, tailNonEmpty, prepend } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { Structural } from '../Data.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { reduce, has, remove, add } from '../../HashSet/dist/effect-HashSet.esm.js';\n\n/** @internal */\nconst HashSetPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferHashSetPatch\");\nfunction variance(a) {\n  return a;\n}\n\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [HashSetPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n\n/** @internal */\nconst empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\n\n/** @internal */\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Add\"\n});\n\n/** @internal */\nconst makeAdd = value => {\n  const o = Object.create(AddProto);\n  o.value = value;\n  return o;\n};\nconst RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Remove\"\n});\n\n/** @internal */\nconst makeRemove = value => {\n  const o = Object.create(RemoveProto);\n  o.value = value;\n  return o;\n};\n/** @internal */\nconst diff = (oldValue, newValue) => {\n  const [removed, patch] = reduce([oldValue, empty()], ([set, patch], value) => {\n    if (has(value)(set)) {\n      return [remove(value)(set), patch];\n    }\n    return [set, combine(makeAdd(value))(patch)];\n  })(newValue);\n  return reduce(patch, (patch, value) => combine(makeRemove(value))(patch))(removed);\n};\n\n/** @internal */\nconst combine = /*#__PURE__*/dual(2, (self, that) => makeAndThen(self, that));\n\n/** @internal */\nconst patch = /*#__PURE__*/dual(2, (self, oldValue) => {\n  let set = oldValue;\n  let patches = of(self);\n  while (isNonEmpty(patches)) {\n    const head = headNonEmpty(patches);\n    const tail = tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = prepend(head.first)(prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          set = add(head.value)(set);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          set = remove(head.value)(set);\n          patches = tail;\n        }\n    }\n  }\n  return set;\n});\n\nexport { HashSetPatchTypeId, combine, diff, empty, makeAdd, makeAndThen, makeRemove, patch };\n","import { equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual, identity, constant } from '../Function/dist/effect-Function.esm.js';\nimport { empty as empty$1, combine as combine$1, diff as diff$1, patch as patch$1 } from './Differ/ChunkPatch.esm.js';\nimport { empty, combine, diff, patch } from './Differ/ContextPatch.esm.js';\nimport { empty as empty$2, combine as combine$2, diff as diff$2, patch as patch$2 } from './Differ/HashMapPatch.esm.js';\nimport { empty as empty$3, combine as combine$3, diff as diff$3, patch as patch$3 } from './Differ/HashSetPatch.esm.js';\nimport { empty as empty$4, combine as combine$4, diff as diff$4, patch as patch$4 } from './Differ/OrPatch.esm.js';\n\n/** @internal */\nconst DifferTypeId = /*#__PURE__*/Symbol.for(\"effect/Differ\");\n\n/** @internal */\nconst DifferProto = {\n  [DifferTypeId]: {\n    _P: identity,\n    _V: identity\n  }\n};\n\n/** @internal */\nconst make = params => {\n  const differ = Object.create(DifferProto);\n  differ.empty = params.empty;\n  differ.diff = params.diff;\n  differ.combine = params.combine;\n  differ.patch = params.patch;\n  return differ;\n};\n\n/** @internal */\nconst environment = () => make({\n  empty: empty(),\n  combine: (first, second) => combine(second)(first),\n  diff: (oldValue, newValue) => diff(oldValue, newValue),\n  patch: (patch$1, oldValue) => patch(oldValue)(patch$1)\n});\n\n/** @internal */\nconst chunk = differ => make({\n  empty: empty$1(),\n  combine: (first, second) => combine$1(second)(first),\n  diff: (oldValue, newValue) => diff$1({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => patch$1(oldValue, differ)(patch)\n});\n\n/** @internal */\nconst hashMap = differ => make({\n  empty: empty$2(),\n  combine: (first, second) => combine$2(second)(first),\n  diff: (oldValue, newValue) => diff$2({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => patch$2(oldValue, differ)(patch)\n});\n\n/** @internal */\nconst hashSet = () => make({\n  empty: empty$3(),\n  combine: (first, second) => combine$3(second)(first),\n  diff: (oldValue, newValue) => diff$3(oldValue, newValue),\n  patch: (patch, oldValue) => patch$3(oldValue)(patch)\n});\n\n/** @internal */\nconst orElseEither = /*#__PURE__*/dual(2, (self, that) => make({\n  empty: empty$4(),\n  combine: (first, second) => combine$4(first, second),\n  diff: (oldValue, newValue) => diff$4({\n    oldValue,\n    newValue,\n    left: self,\n    right: that\n  }),\n  patch: (patch, oldValue) => patch$4(patch, {\n    oldValue,\n    left: self,\n    right: that\n  })\n}));\n\n/** @internal */\nconst transform = /*#__PURE__*/dual(2, (self, {\n  toNew,\n  toOld\n}) => make({\n  empty: self.empty,\n  combine: (first, second) => self.combine(first, second),\n  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),\n  patch: (patch, oldValue) => toNew(self.patch(patch, toOld(oldValue)))\n}));\n\n/** @internal */\nconst update = () => updateWith((_, a) => a);\n\n/** @internal */\nconst updateWith = f => make({\n  empty: identity,\n  combine: (first, second) => {\n    if (first === identity) {\n      return second;\n    }\n    if (second === identity) {\n      return first;\n    }\n    return a => second(first(a));\n  },\n  diff: (oldValue, newValue) => {\n    if (equals(oldValue, newValue)) {\n      return identity;\n    }\n    return constant(newValue);\n  },\n  patch: (patch, oldValue) => f(oldValue, patch(oldValue))\n});\n\n/** @internal */\nconst zip = /*#__PURE__*/dual(2, (self, that) => make({\n  empty: [self.empty, that.empty],\n  combine: (first, second) => [self.combine(first[0], second[0]), that.combine(first[1], second[1])],\n  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],\n  patch: (patch, oldValue) => [self.patch(patch[0], oldValue[0]), that.patch(patch[1], oldValue[1])]\n}));\n\nexport { DifferProto, DifferTypeId, chunk, environment, hashMap, hashSet, make, orElseEither, transform, update, updateWith, zip };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { DifferTypeId, make as make$1, environment as environment$1, chunk as chunk$1, hashMap as hashMap$1, hashSet as hashSet$1, orElseEither as orElseEither$1, transform as transform$1, update as update$1, updateWith as updateWith$1, zip as zip$1 } from '../../internal/Differ.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nconst TypeId = DifferTypeId;\n\n/**\n * @since 2.0.0\n */\n\n/**\n * An empty patch that describes no changes.\n *\n * @since 2.0.0\n * @category patch\n */\nconst empty = self => self.empty;\n\n/**\n * @since 2.0.0\n * @category patch\n */\nconst diff = /*#__PURE__*/dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));\n\n/**\n * Combines two patches to produce a new patch that describes the updates of\n * the first patch and then the updates of the second patch. The combine\n * operation should be associative. In addition, if the combine operation is\n * commutative then joining multiple fibers concurrently will result in\n * deterministic `FiberRef` values.\n *\n * @since 2.0.0\n * @category patch\n */\nconst combine = /*#__PURE__*/dual(3, (self, first, second) => self.combine(first, second));\n\n/**\n * Applies a patch to an old value to produce a new value that is equal to the\n * old value with the updates described by the patch.\n *\n * @since 2.0.0\n * @category patch\n */\nconst patch = /*#__PURE__*/dual(3, (self, patch, oldValue) => self.patch(patch, oldValue));\n\n/**\n * Constructs a new `Differ`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Constructs a differ that knows how to diff `Env` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst environment = environment$1;\n\n/**\n * Constructs a differ that knows how to diff a `Chunk` of values given a\n * differ that knows how to diff the values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst chunk = chunk$1;\n\n/**\n * Constructs a differ that knows how to diff a `HashMap` of keys and values given\n * a differ that knows how to diff the values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst hashMap = hashMap$1;\n\n/**\n * Constructs a differ that knows how to diff a `HashSet` of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst hashSet = hashSet$1;\n\n/**\n * Combines this differ and the specified differ to produce a differ that\n * knows how to diff the sum of their values.\n *\n * @since 2.0.0\n */\nconst orElseEither = orElseEither$1;\n\n/**\n * Transforms the type of values that this differ knows how to differ using\n * the specified functions that map the new and old value types to each other.\n *\n * @since 2.0.0\n */\nconst transform = transform$1;\n\n/**\n * Constructs a differ that just diffs two values by returning a function that\n * sets the value to the new value. This differ does not support combining\n * multiple updates to the value compositionally and should only be used when\n * there is no compositional way to update them.\n *\n * @since 2.0.0\n */\nconst update = update$1;\n\n/**\n * A variant of `update` that allows specifying the function that will be used\n * to combine old values with new values.\n *\n * @since 2.0.0\n */\nconst updateWith = updateWith$1;\n\n/**\n * Combines this differ and the specified differ to produce a new differ that\n * knows how to diff the product of their values.\n *\n * @since 2.0.0\n */\nconst zip = zip$1;\n\nexport { TypeId, chunk, combine, diff, empty, environment, hashMap, hashSet, make, orElseEither, patch, transform, update, updateWith, zip };\n","import { equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableRef\");\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\nconst MutableRefProto = {\n  [TypeId]: TypeId,\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableRef\",\n      current: toJSON(this.current)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = value => {\n  const ref = Object.create(MutableRefProto);\n  ref.current = value;\n  return ref;\n};\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst compareAndSet = /*#__PURE__*/dual(3, (self, oldValue, newValue) => {\n  if (equals(oldValue, self.current)) {\n    self.current = newValue;\n    return true;\n  }\n  return false;\n});\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nconst decrement = self => update(self, n => n - 1);\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nconst decrementAndGet = self => updateAndGet(self, n => n - 1);\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst get = self => self.current;\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nconst getAndDecrement = self => getAndUpdate(self, n => n - 1);\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nconst getAndIncrement = self => getAndUpdate(self, n => n + 1);\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst getAndSet = /*#__PURE__*/dual(2, (self, value) => {\n  const ret = self.current;\n  self.current = value;\n  return ret;\n});\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst getAndUpdate = /*#__PURE__*/dual(2, (self, f) => getAndSet(self, f(get(self))));\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nconst increment = self => update(self, n => n + 1);\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nconst incrementAndGet = self => updateAndGet(self, n => n + 1);\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst set = /*#__PURE__*/dual(2, (self, value) => {\n  self.current = value;\n  return self;\n});\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst setAndGet = /*#__PURE__*/dual(2, (self, value) => {\n  self.current = value;\n  return self.current;\n});\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst update = /*#__PURE__*/dual(2, (self, f) => set(self, f(get(self))));\n\n/**\n * @since 2.0.0\n * @category general\n */\nconst updateAndGet = /*#__PURE__*/dual(2, (self, f) => setAndGet(self, f(get(self))));\n\n/**\n * @since 2.0.0\n * @category boolean\n */\nconst toggle = self => update(self, _ => !_);\n\nexport { compareAndSet, decrement, decrementAndGet, get, getAndDecrement, getAndIncrement, getAndSet, getAndUpdate, increment, incrementAndGet, make, set, setAndGet, toggle, update, updateAndGet };\n","import { symbol as symbol$1, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { pipe, dual } from '../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { symbol, combine as combine$1, hash } from '../Hash/dist/effect-Hash.esm.js';\nimport { every, reduce, union, make as make$1, empty, size } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { toString, NodeInspectSymbol, toJSON } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { get, set, make as make$2 } from '../MutableRef/dist/effect-MutableRef.esm.js';\nimport { none as none$1, some } from '../Option/dist/effect-Option.esm.js';\n\n/** @internal */\nconst FiberIdSymbolKey = \"effect/FiberId\";\n\n/** @internal */\nconst FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);\n\n/** @internal */\nconst OP_NONE = \"None\";\n\n/** @internal */\n\n/** @internal */\nconst OP_RUNTIME = \"Runtime\";\n\n/** @internal */\n\n/** @internal */\nconst OP_COMPOSITE = \"Composite\";\n\n/** @internal */\n\n/** @internal */\nclass None {\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_NONE;\n  [symbol]() {\n    return pipe(hash(FiberIdSymbolKey), combine$1(hash(this._tag)));\n  }\n  [symbol$1](that) {\n    return isFiberId(that) && that._tag === OP_NONE;\n  }\n  toString() {\n    return toString(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n\n/** @internal */\nclass Runtime {\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_RUNTIME;\n  constructor(id, startTimeMillis) {\n    this.id = id;\n    this.startTimeMillis = startTimeMillis;\n  }\n  [symbol]() {\n    return pipe(hash(FiberIdSymbolKey), combine$1(hash(this._tag)), combine$1(hash(this.id)), combine$1(hash(this.startTimeMillis)));\n  }\n  [symbol$1](that) {\n    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;\n  }\n  toString() {\n    return toString(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      id: this.id,\n      startTimeMillis: this.startTimeMillis\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n\n/** @internal */\nclass Composite {\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_COMPOSITE;\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  [symbol]() {\n    return pipe(hash(FiberIdSymbolKey), combine$1(hash(this._tag)), combine$1(hash(this.left)), combine$1(hash(this.right)));\n  }\n  [symbol$1](that) {\n    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);\n  }\n  toString() {\n    return toString(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      left: toJSON(this.left),\n      right: toJSON(this.right)\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n\n/** @internal */\nconst none = /*#__PURE__*/new None();\n\n/** @internal */\nconst runtime = (id, startTimeMillis) => {\n  return new Runtime(id, startTimeMillis);\n};\n\n/** @internal */\nconst composite = (left, right) => {\n  return new Composite(left, right);\n};\n\n/** @internal */\nconst isFiberId = self => {\n  return typeof self === \"object\" && self != null && FiberIdTypeId in self;\n};\n\n/** @internal */\nconst isNone = self => {\n  return self._tag === OP_NONE || pipe(toSet(self), every(id => isNone(id)));\n};\n\n/** @internal */\nconst isRuntime = self => {\n  return self._tag === OP_RUNTIME;\n};\n\n/** @internal */\nconst isComposite = self => {\n  return self._tag === OP_COMPOSITE;\n};\n\n/** @internal */\nconst combine = /*#__PURE__*/dual(2, (self, that) => {\n  if (self._tag === OP_NONE) {\n    return that;\n  }\n  if (that._tag === OP_NONE) {\n    return self;\n  }\n  return new Composite(self, that);\n});\n\n/** @internal */\nconst combineAll = fiberIds => {\n  return pipe(fiberIds, reduce(none, (a, b) => combine(b)(a)));\n};\n\n/** @internal */\nconst getOrElse = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that : self);\n\n/** @internal */\nconst ids = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return empty();\n      }\n    case OP_RUNTIME:\n      {\n        return make$1(self.id);\n      }\n    case OP_COMPOSITE:\n      {\n        return pipe(ids(self.left), union(ids(self.right)));\n      }\n  }\n};\nconst _fiberCounter = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Fiber/Id/_fiberCounter\"), () => make$2(0));\n\n/** @internal */\nconst make = (id, startTimeSeconds) => {\n  return new Runtime(id, startTimeSeconds);\n};\n\n/** @internal */\nconst threadName = self => {\n  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(\",\");\n  return identifiers;\n};\n\n/** @internal */\nconst toOption = self => {\n  const fiberIds = toSet(self);\n  if (size(fiberIds) === 0) {\n    return none$1();\n  }\n  let first = true;\n  let acc;\n  for (const fiberId of fiberIds) {\n    if (first) {\n      acc = fiberId;\n      first = false;\n    } else {\n      // @ts-expect-error\n      acc = pipe(acc, combine(fiberId));\n    }\n  }\n  // @ts-expect-error\n  return some(acc);\n};\n\n/** @internal */\nconst toSet = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return empty();\n      }\n    case OP_RUNTIME:\n      {\n        return make$1(self);\n      }\n    case OP_COMPOSITE:\n      {\n        return pipe(toSet(self.left), union(toSet(self.right)));\n      }\n  }\n};\n\n/** @internal */\nconst unsafeMake = () => {\n  const id = get(_fiberCounter);\n  pipe(_fiberCounter, set(id + 1));\n  return new Runtime(id, new Date().getTime());\n};\n\nexport { FiberIdTypeId, combine, combineAll, composite, getOrElse, ids, isComposite, isFiberId, isNone, isRuntime, make, none, runtime, threadName, toOption, toSet, unsafeMake };\n","import { FiberIdTypeId as FiberIdTypeId$1, none as none$1, runtime as runtime$1, composite as composite$1, isFiberId as isFiberId$1, isNone as isNone$1, isRuntime as isRuntime$1, isComposite as isComposite$1, combine as combine$1, combineAll as combineAll$1, getOrElse as getOrElse$1, ids as ids$1, make as make$1, threadName as threadName$1, toOption as toOption$1, toSet as toSet$1, unsafeMake as unsafeMake$1 } from '../../internal/fiberId.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst FiberIdTypeId = FiberIdTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst none = none$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst runtime = runtime$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst composite = composite$1;\n\n/**\n * Returns `true` if the specified unknown value is a `FiberId`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isFiberId = isFiberId$1;\n\n/**\n * Returns `true` if the `FiberId` is a `None`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isNone = isNone$1;\n\n/**\n * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isRuntime = isRuntime$1;\n\n/**\n * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isComposite = isComposite$1;\n\n/**\n * Combine two `FiberId`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst combine = combine$1;\n\n/**\n * Combines a set of `FiberId`s into a single `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst combineAll = combineAll$1;\n\n/**\n * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst getOrElse = getOrElse$1;\n\n/**\n * Get the set of identifiers for this `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst ids = ids$1;\n\n/**\n * Creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Creates a string representing the name of the current thread of execution\n * represented by the specified `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst threadName = threadName$1;\n\n/**\n * Convert a `FiberId` into an `Option<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toOption = toOption$1;\n\n/**\n * Convert a `FiberId` into a `HashSet<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toSet = toSet$1;\n\n/**\n * Unsafely creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeMake = unsafeMake$1;\n\nexport { FiberIdTypeId, combine, combineAll, composite, getOrElse, ids, isComposite, isFiberId, isNone, isRuntime, make, none, runtime, threadName, toOption, toSet, unsafeMake };\n","import { fromIterable as fromIterable$1 } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { isLeft } from '../../Either/dist/effect-Either.esm.js';\nimport { symbol as symbol$1, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { mapInput } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual, unsafeCoerce, identity } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, array } from '../../Hash/dist/effect-Hash.esm.js';\nimport { toString, NodeInspectSymbol, toJSON } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { isSome, some as some$1, none } from '../../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isObject } from '../../Predicate/dist/effect-Predicate.esm.js';\nimport { getEquivalence as getEquivalence$1 } from '../../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/**\n * A data type for immutable linked lists representing ordered collections of elements of type `A`.\n *\n * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n *\n * **Performance**\n *\n * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.\n *\n * @since 2.0.0\n */\n\n/**\n * Represents an immutable linked list of elements of type `A`.\n *\n * A `List` is optimal for last-in-first-out (LIFO), stack-like access patterns.\n * If you need another access pattern, for example, random access or FIFO,\n * consider using a collection more suited for that other than `List`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/List\");\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Converts the specified `List` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toReadonlyArray = self => Array.from(self);\n\n/**\n * @category equivalence\n * @since 2.0.0\n */\nconst getEquivalence = isEquivalent => mapInput(getEquivalence$1(isEquivalent), toReadonlyArray);\nconst _equivalence = /*#__PURE__*/getEquivalence(equals);\nconst ConsProto = {\n  [TypeId]: TypeId,\n  _tag: \"Cons\",\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Cons\",\n      values: toReadonlyArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [symbol$1](that) {\n    return isList(that) && this._tag === that._tag && _equivalence(this, that);\n  },\n  [symbol]() {\n    return array(toReadonlyArray(this));\n  },\n  [Symbol.iterator]() {\n    let done = false;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (self._tag === \"Nil\") {\n          done = true;\n          return this.return();\n        }\n        const value = self.head;\n        self = self.tail;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeCons = (head, tail) => {\n  const cons = Object.create(ConsProto);\n  cons.head = head;\n  cons.tail = tail;\n  return cons;\n};\nconst NilProto = {\n  [TypeId]: TypeId,\n  _tag: \"Nil\",\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Nil\"\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [symbol]() {\n    return array(toReadonlyArray(this));\n  },\n  [symbol$1](that) {\n    return isList(that) && this._tag === that._tag;\n  },\n  [Symbol.iterator]() {\n    return {\n      next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst _Nil = /*#__PURE__*/Object.create(NilProto);\n\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isList = u => isObject(u) && TypeId in u;\n\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isNil = self => self._tag === \"Nil\";\n\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isCons = self => self._tag === \"Cons\";\n\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = self => {\n  let these = self;\n  let len = 0;\n  while (!isNil(these)) {\n    len += 1;\n    these = these.tail;\n  }\n  return len;\n};\n\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst nil = () => _Nil;\n\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst cons = (head, tail) => makeCons(head, tail);\n\n/**\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = nil;\n\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst of = value => makeCons(value, _Nil);\n\n/**\n * Constructs a new `List<A>` from the specified `Iterable<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = prefix => {\n  const iterator = prefix[Symbol.iterator]();\n  let next;\n  if ((next = iterator.next()) && !next.done) {\n    const result = makeCons(next.value, _Nil);\n    let curr = result;\n    while ((next = iterator.next()) && !next.done) {\n      const temp = makeCons(next.value, _Nil);\n      curr.tail = temp;\n      curr = temp;\n    }\n    return result;\n  } else {\n    return _Nil;\n  }\n};\n\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = (...elements) => fromIterable(elements);\n\n/**\n * Appends the specified element to the end of the `List`, creating a new `Cons`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst append = /*#__PURE__*/dual(2, (self, element) => appendAllNonEmpty(self, of(element)));\n\n/**\n * Concatentates the specified lists together.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst appendAll = /*#__PURE__*/dual(2, (self, that) => prependAll(that, self));\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst appendAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => appendAll(self, that));\n\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst prepend = /*#__PURE__*/dual(2, (self, element) => cons(element, self));\n\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAll = /*#__PURE__*/dual(2, (self, prefix) => {\n  if (isNil(self)) {\n    return prefix;\n  } else if (isNil(prefix)) {\n    return self;\n  } else {\n    const result = makeCons(prefix.head, self);\n    let curr = result;\n    let that = prefix.tail;\n    while (!isNil(that)) {\n      const temp = makeCons(that.head, self);\n      curr.tail = temp;\n      curr = temp;\n      that = that.tail;\n    }\n    return result;\n  }\n});\n\n/**\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => prependAll(self, that));\n\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst prependAllReversed = /*#__PURE__*/dual(2, (self, prefix) => {\n  let out = self;\n  let pres = prefix;\n  while (isCons(pres)) {\n    out = makeCons(pres.head, out);\n    pres = pres.tail;\n  }\n  return out;\n});\n\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  }\n  if (n >= size(self)) {\n    return _Nil;\n  }\n  let these = self;\n  let i = 0;\n  while (!isNil(these) && i < n) {\n    these = these.tail;\n    i += 1;\n  }\n  return these;\n});\n\n/**\n * Check if a predicate holds true for every `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst every = /*#__PURE__*/dual(2, (self, refinement) => {\n  for (const a of self) {\n    if (!refinement(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n\n/**\n * Check if a predicate holds true for some `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst some = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true;\n    }\n    these = these.tail;\n  }\n  return false;\n});\n\n/**\n * Filters a list using the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => noneIn(self, predicate, false));\n\n// everything seen so far is not included\nconst noneIn = (self, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(self)) {\n      return _Nil;\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped);\n      } else {\n        self = self.tail;\n      }\n    }\n  }\n};\n\n// everything from 'start' is included, if everything from this point is in we can return the origin\n// start otherwise if we discover an element that is out we must create a new partial list.\nconst allIn = (start, remaining, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(remaining)) {\n      return start;\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail;\n      } else {\n        return partialFill(start, remaining, predicate, isFlipped);\n      }\n    }\n  }\n};\n\n// we have seen elements that should be included then one that should be excluded, start building\nconst partialFill = (origStart, firstMiss, predicate, isFlipped) => {\n  const newHead = makeCons(unsafeHead(origStart), _Nil);\n  let toProcess = unsafeTail(origStart);\n  let currentLast = newHead;\n\n  // we know that all elements are :: until at least firstMiss.tail\n  while (!(toProcess === firstMiss)) {\n    const newElem = makeCons(unsafeHead(toProcess), _Nil);\n    currentLast.tail = newElem;\n    currentLast = unsafeCoerce(newElem);\n    toProcess = unsafeCoerce(toProcess.tail);\n  }\n\n  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.\n  // currentLast is the last element in that list.\n\n  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n  let next = firstMiss.tail;\n  let nextToCopy = unsafeCoerce(next); // the next element we would need to copy to our list if we cant share.\n  while (!isNil(next)) {\n    // generally recommended is next.isNonEmpty but this incurs an extra method call.\n    const head = unsafeHead(next);\n    if (predicate(head) !== isFlipped) {\n      next = next.tail;\n    } else {\n      // its not a match - do we have outstanding elements?\n      while (!(nextToCopy === next)) {\n        const newElem = makeCons(unsafeHead(nextToCopy), _Nil);\n        currentLast.tail = newElem;\n        currentLast = newElem;\n        nextToCopy = unsafeCoerce(nextToCopy.tail);\n      }\n      nextToCopy = unsafeCoerce(next.tail);\n      next = next.tail;\n    }\n  }\n\n  // we have remaining elements - they are unchanged attach them to the end\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy;\n  }\n  return newHead;\n};\n\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const bs = [];\n  for (const a of self) {\n    const oa = f(a);\n    if (isSome(oa)) {\n      bs.push(oa.value);\n    }\n  }\n  return fromIterable(bs);\n});\n\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst compact = self => filterMap(self, identity);\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return some$1(these.head);\n    }\n    these = these.tail;\n  }\n  return none();\n});\n\n/**\n * Flat maps a list using the specified function.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  let rest = self;\n  let head = undefined;\n  let tail = undefined;\n  while (!isNil(rest)) {\n    let bs = f(rest.head);\n    while (!isNil(bs)) {\n      const next = makeCons(bs.head, _Nil);\n      if (tail === undefined) {\n        head = next;\n      } else {\n        tail.tail = next;\n      }\n      tail = next;\n      bs = bs.tail;\n    }\n    rest = rest.tail;\n  }\n  if (head === undefined) {\n    return _Nil;\n  }\n  return head;\n});\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMapNonEmpty = flatMap;\n\n/**\n * Applies the specified function to each element of the `List`.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => {\n  let these = self;\n  while (!isNil(these)) {\n    f(these.head);\n    these = these.tail;\n  }\n});\n\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nconst head = self => isNil(self) ? none() : some$1(self.head);\n\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nconst last = self => isNil(self) ? none() : some$1(unsafeLast(self));\n\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst map = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNil(self)) {\n    return self;\n  } else {\n    const head = makeCons(f(self.head), _Nil);\n    let nextHead = head;\n    let rest = self.tail;\n    while (!isNil(rest)) {\n      const next = makeCons(f(rest.head), _Nil);\n      nextHead.tail = next;\n      nextHead = next;\n      rest = rest.tail;\n    }\n    return head;\n  }\n});\n\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a);\n    } else {\n      left.push(a);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    const e = f(a);\n    if (isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = self;\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduceRight = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = reverse(self);\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 2.0.0\n * @category elements\n */\nconst reverse = self => {\n  let result = empty();\n  let these = self;\n  while (!isNil(these)) {\n    result = prepend(result, these.head);\n    these = these.tail;\n  }\n  return result;\n};\n\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nconst tail = self => isNil(self) ? none() : some$1(self.tail);\n\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 2.0.0\n * @category combinators\n */\nconst take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _Nil;\n  }\n  if (n >= size(self)) {\n    return self;\n  }\n  let these = make(unsafeHead(self));\n  let current = unsafeTail(self);\n  for (let i = 1; i < n; i++) {\n    these = makeCons(unsafeHead(current), these);\n    current = unsafeTail(current);\n  }\n  return reverse(these);\n});\n\n/**\n * Converts the specified `List` to a `Chunk`.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst toChunk = self => fromIterable$1(self);\n\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeHead = self => {\n  if (isNil(self)) {\n    throw new Error(\"Expected List to be non-empty\");\n  }\n  return self.head;\n};\n\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeLast = self => {\n  if (isNil(self)) {\n    throw new Error(\"Expected List to be non-empty\");\n  }\n  let these = self;\n  let scout = self.tail;\n  while (!isNil(scout)) {\n    these = scout;\n    scout = scout.tail;\n  }\n  return these.head;\n};\n\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeTail = self => {\n  if (isNil(self)) {\n    throw new Error(\"Expected List to be non-empty\");\n  }\n  return self.tail;\n};\n\nexport { TypeId, append, appendAll, appendAllNonEmpty, compact, cons, drop, empty, every, filter, filterMap, findFirst, flatMap, flatMapNonEmpty, forEach, fromIterable, getEquivalence, head, isCons, isList, isNil, last, make, map, nil, of, partition, partitionMap, prepend, prependAll, prependAllNonEmpty, prependAllReversed, reduce, reduceRight, reverse, size, some, splitAt, tail, take, toChunk, toReadonlyArray, unsafeHead, unsafeLast, unsafeTail };\n","import { right, left } from '../Either/dist/effect-Either.esm.js';\nimport { equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { empty as empty$2, make, reduce as reduce$2, set, get, isEmpty, keys, map } from '../HashMap/dist/effect-HashMap.esm.js';\nimport { of, isCons, cons, reduce as reduce$1, empty as empty$1, unsafeHead, unsafeTail, isNil, appendAll, reverse } from '../List/dist/effect-List.esm.js';\nimport { match } from '../Option/dist/effect-Option.esm.js';\n\n/** @internal */\nconst empty = {\n  _tag: \"Empty\"\n};\n\n/**\n * Combines this collection of blocked requests with the specified collection\n * of blocked requests, in parallel.\n *\n * @internal\n */\nconst par = (self, that) => ({\n  _tag: \"Par\",\n  left: self,\n  right: that\n});\n\n/**\n * Combines this collection of blocked requests with the specified collection\n * of blocked requests, in sequence.\n *\n * @internal\n */\nconst seq = (self, that) => ({\n  _tag: \"Seq\",\n  left: self,\n  right: that\n});\n\n/**\n * Constructs a collection of blocked requests from the specified blocked\n * request and data source.\n *\n * @internal\n */\nconst single = (dataSource, blockedRequest) => ({\n  _tag: \"Single\",\n  dataSource,\n  blockedRequest\n});\n\n/** @internal */\nconst MapRequestResolversReducer = f => ({\n  emptyCase: () => empty,\n  parCase: (left, right) => par(left, right),\n  seqCase: (left, right) => seq(left, right),\n  singleCase: (dataSource, blockedRequest) => single(f(dataSource), blockedRequest)\n});\n/**\n * Transforms all data sources with the specified data source aspect, which\n * can change the environment type of data sources but must preserve the\n * request type of each data source.\n *\n * @internal\n */\nconst mapRequestResolvers = (self, f) => reduce(self, MapRequestResolversReducer(f));\n\n/**\n * Folds over the cases of this collection of blocked requests with the\n * specified functions.\n *\n * @internal\n */\nconst reduce = (self, reducer) => {\n  let input = of(self);\n  let output = empty$1();\n  while (isCons(input)) {\n    const current = input.head;\n    switch (current._tag) {\n      case \"Empty\":\n        {\n          output = cons(right(reducer.emptyCase()), output);\n          input = input.tail;\n          break;\n        }\n      case \"Par\":\n        {\n          output = cons(left({\n            _tag: \"ParCase\"\n          }), output);\n          input = cons(current.left, cons(current.right, input.tail));\n          break;\n        }\n      case \"Seq\":\n        {\n          output = cons(left({\n            _tag: \"SeqCase\"\n          }), output);\n          input = cons(current.left, cons(current.right, input.tail));\n          break;\n        }\n      case \"Single\":\n        {\n          const result = reducer.singleCase(current.dataSource, current.blockedRequest);\n          output = cons(right(result), output);\n          input = input.tail;\n          break;\n        }\n    }\n  }\n  const result = reduce$1(output, empty$1(), (acc, current) => {\n    switch (current._tag) {\n      case \"Left\":\n        {\n          const left = unsafeHead(acc);\n          const right = unsafeHead(unsafeTail(acc));\n          const tail = unsafeTail(unsafeTail(acc));\n          switch (current.left._tag) {\n            case \"ParCase\":\n              {\n                return cons(reducer.parCase(left, right), tail);\n              }\n            case \"SeqCase\":\n              {\n                return cons(reducer.seqCase(left, right), tail);\n              }\n          }\n        }\n      case \"Right\":\n        {\n          return cons(current.right, acc);\n        }\n    }\n  });\n  if (isNil(result)) {\n    throw new Error(\"BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/query/issues\");\n  }\n  return result.head;\n};\n\n/**\n * Flattens a collection of blocked requests into a collection of pipelined\n * and batched requests that can be submitted for execution.\n *\n * @internal\n */\nconst flatten = self => {\n  let current = of(self);\n  let updated = empty$1();\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = reduce$1(current, [parallelCollectionEmpty(), empty$1()], ([parallel, sequential], blockedRequest) => {\n      const [par, seq] = step(blockedRequest);\n      return [parallelCollectionCombine(parallel, par), appendAll(sequential, seq)];\n    });\n    updated = merge(updated, parallel);\n    if (isNil(sequential)) {\n      return reverse(updated);\n    }\n    current = sequential;\n  }\n  throw new Error(\"BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/query/issues\");\n};\n\n/**\n * Takes one step in evaluating a collection of blocked requests, returning a\n * collection of blocked requests that can be performed in parallel and a list\n * of blocked requests that must be performed sequentially after those\n * requests.\n */\nconst step = requests => {\n  let current = requests;\n  let parallel = parallelCollectionEmpty();\n  let stack = empty$1();\n  let sequential = empty$1();\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    switch (current._tag) {\n      case \"Empty\":\n        {\n          if (isNil(stack)) {\n            return [parallel, sequential];\n          }\n          current = stack.head;\n          stack = stack.tail;\n          break;\n        }\n      case \"Par\":\n        {\n          stack = cons(current.right, stack);\n          current = current.left;\n          break;\n        }\n      case \"Seq\":\n        {\n          const left = current.left;\n          const right = current.right;\n          switch (left._tag) {\n            case \"Empty\":\n              {\n                current = right;\n                break;\n              }\n            case \"Par\":\n              {\n                const l = left.left;\n                const r = left.right;\n                current = par(seq(l, right), seq(r, right));\n                break;\n              }\n            case \"Seq\":\n              {\n                const l = left.left;\n                const r = left.right;\n                current = seq(l, seq(r, right));\n                break;\n              }\n            case \"Single\":\n              {\n                current = left;\n                sequential = cons(right, sequential);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Single\":\n        {\n          parallel = parallelCollectionCombine(parallel, parallelCollectionMake(current.dataSource, current.blockedRequest));\n          if (isNil(stack)) {\n            return [parallel, sequential];\n          }\n          current = stack.head;\n          stack = stack.tail;\n          break;\n        }\n    }\n  }\n  throw new Error(\"BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/query/issues\");\n};\n\n/**\n * Merges a collection of requests that must be executed sequentially with a\n * collection of requests that can be executed in parallel. If the collections\n * are both from the same single data source then the requests can be\n * pipelined while preserving ordering guarantees.\n */\nconst merge = (sequential, parallel) => {\n  if (isNil(sequential)) {\n    return of(parallelCollectionToSequentialCollection(parallel));\n  }\n  if (parallelCollectionIsEmpty(parallel)) {\n    return sequential;\n  }\n  const seqHeadKeys = sequentialCollectionKeys(sequential.head);\n  const parKeys = parallelCollectionKeys(parallel);\n  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {\n    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);\n  }\n  return cons(parallelCollectionToSequentialCollection(parallel), sequential);\n};\n\n//\n// circular\n//\n\n/** @internal */\nconst EntryTypeId = /*#__PURE__*/Symbol.for(\"effect/RequestBlock/Entry\");\n\n/** @internal */\nclass EntryImpl {\n  [EntryTypeId] = blockedRequestVariance;\n  constructor(request, result, listeners, ownerId, state) {\n    this.request = request;\n    this.result = result;\n    this.listeners = listeners;\n    this.ownerId = ownerId;\n    this.state = state;\n  }\n}\n\n/** @internal */\nconst blockedRequestVariance = {\n  _R: _ => _\n};\n\n/** @internal */\nconst isEntry = u => {\n  return typeof u === \"object\" && u != null && EntryTypeId in u;\n};\n\n/** @internal */\nconst makeEntry = options => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);\n\n/** @internal */\nconst RequestBlockParallelTypeId = /*#__PURE__*/Symbol.for(\"effect/RequestBlock/RequestBlockParallel\");\nconst parallelVariance = {\n  _R: _ => _\n};\nclass ParallelImpl {\n  [RequestBlockParallelTypeId] = parallelVariance;\n  constructor(map) {\n    this.map = map;\n  }\n}\n\n/** @internal */\nconst parallelCollectionEmpty = () => new ParallelImpl(empty$2());\n\n/** @internal */\nconst parallelCollectionMake = (dataSource, blockedRequest) => new ParallelImpl(make([dataSource, Array.of(blockedRequest)]));\n\n/** @internal */\nconst parallelCollectionCombine = (self, that) => new ParallelImpl(reduce$2(self.map, that.map, (map, value, key) => set(map, key, match(get(map, key), {\n  onNone: () => value,\n  onSome: a => [...a, ...value]\n}))));\n\n/** @internal */\nconst parallelCollectionIsEmpty = self => isEmpty(self.map);\n\n/** @internal */\nconst parallelCollectionKeys = self => Array.from(keys(self.map));\n\n/** @internal */\nconst parallelCollectionToSequentialCollection = self => sequentialCollectionMake(map(self.map, x => Array.of(x)));\n\n/** @internal */\nconst SequentialCollectionTypeId = /*#__PURE__*/Symbol.for(\"effect/RequestBlock/RequestBlockSequential\");\n\n/** @internal */\nconst sequentialVariance = {\n  _R: _ => _\n};\nclass SequentialImpl {\n  [SequentialCollectionTypeId] = sequentialVariance;\n  constructor(map) {\n    this.map = map;\n  }\n}\n\n/** @internal */\nconst sequentialCollectionMake = map => new SequentialImpl(map);\n\n/** @internal */\nconst sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce$2(that.map, self.map, (map, value, key) => set(map, key, match(get(map, key), {\n  onNone: () => [],\n  onSome: a => [...a, ...value]\n}))));\n\n/** @internal */\nconst sequentialCollectionKeys = self => Array.from(keys(self.map));\n\n/** @internal */\nconst sequentialCollectionToChunk = self => Array.from(self.map);\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\nexport { EntryTypeId, MapRequestResolversReducer, RequestBlockParallelTypeId, SequentialCollectionTypeId, empty, flatten, isEntry, makeEntry, mapRequestResolvers, par, parallelCollectionCombine, parallelCollectionEmpty, parallelCollectionIsEmpty, parallelCollectionKeys, parallelCollectionMake, parallelCollectionToSequentialCollection, reduce, seq, sequentialCollectionCombine, sequentialCollectionKeys, sequentialCollectionMake, sequentialCollectionToChunk, single };\n","/** @internal */\nconst OP_DIE = \"Die\";\n\n/** @internal */\n\n/** @internal */\nconst OP_EMPTY = \"Empty\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FAIL = \"Fail\";\n\n/** @internal */\n\n/** @internal */\nconst OP_INTERRUPT = \"Interrupt\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PARALLEL = \"Parallel\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SEQUENTIAL = \"Sequential\";\n\n/** @internal */\n\nexport { OP_DIE, OP_EMPTY, OP_FAIL, OP_INTERRUPT, OP_PARALLEL, OP_SEQUENTIAL };\n","import { reverse, empty as empty$1, prepend, of, isNonEmpty, appendAll, headNonEmpty, head, isEmpty as isEmpty$1 } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { left, right } from '../Either/dist/effect-Either.esm.js';\nimport { equals, symbol as symbol$1 } from '../Equal/dist/effect-Equal.esm.js';\nimport { ids } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { pipe, dual, identity, constTrue, constFalse } from '../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../Hash/dist/effect-Hash.esm.js';\nimport { empty as empty$2, add, make, flatMap as flatMap$1, map as map$2, union, size as size$1 } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { toJSON, NodeInspectSymbol } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { none, some, isSome, map as map$1, isNone, match as match$1, getOrUndefined } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { reduce as reduce$1 } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\nimport { OP_EMPTY, OP_FAIL, OP_DIE, OP_INTERRUPT, OP_PARALLEL, OP_SEQUENTIAL } from './opCodes/cause.esm.js';\n\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n/** @internal */\nconst CauseSymbolKey = \"effect/Cause\";\n\n/** @internal */\nconst CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);\n\n/** @internal */\nconst variance = {\n  _E: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [symbol]() {\n    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))));\n  },\n  [symbol$1](that) {\n    return isCause(that) && causeEquals(this, that);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toJSON() {\n    switch (this._tag) {\n      case \"Empty\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag\n        };\n      case \"Die\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          defect: toJSON(this.defect)\n        };\n      case \"Interrupt\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          fiberId: this.fiberId.toJSON()\n        };\n      case \"Fail\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          failure: toJSON(this.error)\n        };\n      case \"Sequential\":\n      case \"Parallel\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          errors: toJSON(prettyErrors(this))\n        };\n    }\n  },\n  toString() {\n    return pretty(this);\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst empty = /*#__PURE__*/(() => {\n  const o = /*#__PURE__*/Object.create(proto);\n  o._tag = OP_EMPTY;\n  return o;\n})();\n\n/** @internal */\nconst fail = error => {\n  const o = Object.create(proto);\n  o._tag = OP_FAIL;\n  o.error = error;\n  return o;\n};\n\n/** @internal */\nconst die = defect => {\n  const o = Object.create(proto);\n  o._tag = OP_DIE;\n  o.defect = defect;\n  return o;\n};\n\n/** @internal */\nconst interrupt = fiberId => {\n  const o = Object.create(proto);\n  o._tag = OP_INTERRUPT;\n  o.fiberId = fiberId;\n  return o;\n};\n\n/** @internal */\nconst parallel = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OP_PARALLEL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n\n/** @internal */\nconst sequential = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OP_SEQUENTIAL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst isCause = u => typeof u === \"object\" && u != null && CauseTypeId in u;\n\n/** @internal */\nconst isEmptyType = self => self._tag === OP_EMPTY;\n\n/** @internal */\nconst isFailType = self => self._tag === OP_FAIL;\n\n/** @internal */\nconst isDieType = self => self._tag === OP_DIE;\n\n/** @internal */\nconst isInterruptType = self => self._tag === OP_INTERRUPT;\n\n/** @internal */\nconst isSequentialType = self => self._tag === OP_SEQUENTIAL;\n\n/** @internal */\nconst isParallelType = self => self._tag === OP_PARALLEL;\n\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst size = self => reduceWithContext(self, void 0, SizeCauseReducer);\n\n/** @internal */\nconst isEmpty = self => {\n  if (self._tag === OP_EMPTY) {\n    return true;\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OP_EMPTY:\n        {\n          return some(acc);\n        }\n      case OP_DIE:\n      case OP_FAIL:\n      case OP_INTERRUPT:\n        {\n          return some(false);\n        }\n      default:\n        {\n          return none();\n        }\n    }\n  });\n};\n\n/** @internal */\nconst isFailure = self => isSome(failureOption(self));\n\n/** @internal */\nconst isDie = self => isSome(dieOption(self));\n\n/** @internal */\nconst isInterrupted = self => isSome(interruptOption(self));\n\n/** @internal */\nconst isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);\n\n/** @internal */\nconst failures = self => reverse(reduce(self, empty$1(), (list, cause) => cause._tag === OP_FAIL ? some(pipe(list, prepend(cause.error))) : none()));\n\n/** @internal */\nconst defects = self => reverse(reduce(self, empty$1(), (list, cause) => cause._tag === OP_DIE ? some(pipe(list, prepend(cause.defect))) : none()));\n\n/** @internal */\nconst interruptors = self => reduce(self, empty$2(), (set, cause) => cause._tag === OP_INTERRUPT ? some(pipe(set, add(cause.fiberId))) : none());\n\n/** @internal */\nconst failureOption = self => find(self, cause => cause._tag === OP_FAIL ? some(cause.error) : none());\n\n/** @internal */\nconst failureOrCause = self => {\n  const option = failureOption(self);\n  switch (option._tag) {\n    case \"None\":\n      {\n        // no `E` inside this `Cause`, so it can be safely cast to `never`\n        return right(self);\n      }\n    case \"Some\":\n      {\n        return left(option.value);\n      }\n  }\n};\n\n/** @internal */\nconst dieOption = self => find(self, cause => cause._tag === OP_DIE ? some(cause.defect) : none());\n\n/** @internal */\nconst flipCauseOption = self => match(self, {\n  onEmpty: some(empty),\n  onFail: failureOption => pipe(failureOption, map$1(fail)),\n  onDie: defect => some(die(defect)),\n  onInterrupt: fiberId => some(interrupt(fiberId)),\n  onSequential: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(sequential(left.value, right.value));\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    return none();\n  },\n  onParallel: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(parallel(left.value, right.value));\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    return none();\n  }\n});\n\n/** @internal */\nconst interruptOption = self => find(self, cause => cause._tag === OP_INTERRUPT ? some(cause.fiberId) : none());\n\n/** @internal */\nconst keepDefects = self => match(self, {\n  onEmpty: none(),\n  onFail: () => none(),\n  onDie: defect => some(die(defect)),\n  onInterrupt: () => none(),\n  onSequential: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(sequential(left.value, right.value));\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    return none();\n  },\n  onParallel: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(parallel(left.value, right.value));\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    return none();\n  }\n});\n\n/** @internal */\nconst keepDefectsAndElectFailures = self => match(self, {\n  onEmpty: none(),\n  onFail: failure => some(die(failure)),\n  onDie: defect => some(die(defect)),\n  onInterrupt: () => none(),\n  onSequential: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(sequential(left.value, right.value));\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    return none();\n  },\n  onParallel: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(parallel(left.value, right.value));\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    return none();\n  }\n});\n\n/** @internal */\nconst linearize = self => match(self, {\n  onEmpty: empty$2(),\n  onFail: error => make(fail(error)),\n  onDie: defect => make(die(defect)),\n  onInterrupt: fiberId => make(interrupt(fiberId)),\n  onSequential: (leftSet, rightSet) => pipe(leftSet, flatMap$1(leftCause => pipe(rightSet, map$2(rightCause => sequential(leftCause, rightCause))))),\n  onParallel: (leftSet, rightSet) => pipe(leftSet, flatMap$1(leftCause => pipe(rightSet, map$2(rightCause => parallel(leftCause, rightCause)))))\n});\n\n/** @internal */\nconst stripFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: () => empty,\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: sequential,\n  onParallel: parallel\n});\n\n/** @internal */\nconst electFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: failure => die(failure),\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: (left, right) => sequential(left, right),\n  onParallel: (left, right) => parallel(left, right)\n});\n\n/** @internal */\nconst stripSomeDefects = /*#__PURE__*/dual(2, (self, pf) => match(self, {\n  onEmpty: some(empty),\n  onFail: error => some(fail(error)),\n  onDie: defect => {\n    const option = pf(defect);\n    return isSome(option) ? none() : some(die(defect));\n  },\n  onInterrupt: fiberId => some(interrupt(fiberId)),\n  onSequential: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(sequential(left.value, right.value));\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    return none();\n  },\n  onParallel: (left, right) => {\n    if (isSome(left) && isSome(right)) {\n      return some(parallel(left.value, right.value));\n    }\n    if (isSome(left) && isNone(right)) {\n      return some(left.value);\n    }\n    if (isNone(left) && isSome(right)) {\n      return some(right.value);\n    }\n    return none();\n  }\n}));\n\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst as = /*#__PURE__*/dual(2, (self, error) => map(self, () => error));\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, e => fail(f(e))));\n\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {\n  onEmpty: empty,\n  onFail: error => f(error),\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: (left, right) => sequential(left, right),\n  onParallel: (left, right) => parallel(left, right)\n}));\n\n/** @internal */\nconst flatten = self => flatMap(self, identity);\n\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst contains = /*#__PURE__*/dual(2, (self, that) => {\n  if (that._tag === OP_EMPTY || self === that) {\n    return true;\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return some(accumulator || causeEquals(cause, that));\n  });\n});\n\n/** @internal */\nconst causeEquals = (left, right) => {\n  let leftStack = of(left);\n  let rightStack = of(right);\n  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = pipe(headNonEmpty(leftStack), reduce([empty$2(), empty$1()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return some([pipe(parallel, union(par)), pipe(sequential, appendAll(seq))]);\n    }));\n    const [rightParallel, rightSequential] = pipe(headNonEmpty(rightStack), reduce([empty$2(), empty$1()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return some([pipe(parallel, union(par)), pipe(sequential, appendAll(seq))]);\n    }));\n    if (!equals(leftParallel, rightParallel)) {\n      return false;\n    }\n    leftStack = leftSequential;\n    rightStack = rightSequential;\n  }\n  return true;\n};\n\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = cause => {\n  return flattenCauseLoop(of(cause), empty$1());\n};\n\n/** @internal */\nconst flattenCauseLoop = (causes, flattened) => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = pipe(causes, reduce$1([empty$2(), empty$1()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return [pipe(parallel, union(par)), pipe(sequential, appendAll(seq))];\n    }));\n    const updated = size$1(parallel) > 0 ? pipe(flattened, prepend(parallel)) : flattened;\n    if (isEmpty$1(sequential)) {\n      return reverse(updated);\n    }\n    causes = sequential;\n    flattened = updated;\n  }\n  throw new Error(\"BUG: Cause.flattenCauseLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n\n// -----------------------------------------------------------------------------\n// Squashing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst squash = self => {\n  return squashWith(identity)(self);\n};\n\n/** @internal */\nconst squashWith = /*#__PURE__*/dual(2, (self, f) => {\n  const option = pipe(self, failureOption, map$1(f));\n  switch (option._tag) {\n    case \"None\":\n      {\n        return pipe(defects(self), head, match$1({\n          onNone: () => {\n            const interrupts = Array.from(interruptors(self)).flatMap(fiberId => Array.from(ids(fiberId)).map(id => `#${id}`));\n            return InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0);\n          },\n          onSome: identity\n        }));\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n});\n\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst find = /*#__PURE__*/dual(2, (self, pf) => {\n  const stack = [self];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    const option = pf(item);\n    switch (option._tag) {\n      case \"None\":\n        {\n          switch (item._tag) {\n            case OP_SEQUENTIAL:\n            case OP_PARALLEL:\n              {\n                stack.push(item.right);\n                stack.push(item.left);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Some\":\n        {\n          return option;\n        }\n    }\n  }\n  return none();\n});\n\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));\n\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = self => {\n  let cause = self;\n  const stack = [];\n  let _parallel = empty$2();\n  let _sequential = empty$1();\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OP_EMPTY:\n        {\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OP_FAIL:\n        {\n          if (stack.length === 0) {\n            return [pipe(_parallel, add(cause.error)), _sequential];\n          }\n          _parallel = pipe(_parallel, add(cause.error));\n          cause = stack.pop();\n          break;\n        }\n      case OP_DIE:\n        {\n          if (stack.length === 0) {\n            return [pipe(_parallel, add(cause.defect)), _sequential];\n          }\n          _parallel = pipe(_parallel, add(cause.defect));\n          cause = stack.pop();\n          break;\n        }\n      case OP_INTERRUPT:\n        {\n          if (stack.length === 0) {\n            return [pipe(_parallel, add(cause.fiberId)), _sequential];\n          }\n          _parallel = pipe(_parallel, add(cause.fiberId));\n          cause = stack.pop();\n          break;\n        }\n      case OP_SEQUENTIAL:\n        {\n          switch (cause.left._tag) {\n            case OP_EMPTY:\n              {\n                cause = cause.right;\n                break;\n              }\n            case OP_SEQUENTIAL:\n              {\n                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OP_PARALLEL:\n              {\n                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));\n                break;\n              }\n            default:\n              {\n                _sequential = pipe(_sequential, prepend(cause.right));\n                cause = cause.left;\n                break;\n              }\n          }\n          break;\n        }\n      case OP_PARALLEL:\n        {\n          stack.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n    }\n  }\n  throw new Error(\"BUG: Cause.evaluateCauseLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst SizeCauseReducer = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n};\n\n/** @internal */\nconst IsInterruptedOnlyCauseReducer = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n};\n\n/** @internal */\nconst FilterCauseReducer = predicate => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  }\n});\n\n/** @internal */\n\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\";\nconst OP_PARALLEL_CASE = \"ParallelCase\";\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onDie,\n  onEmpty,\n  onFail,\n  onInterrupt,\n  onParallel,\n  onSequential\n}) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => onEmpty,\n    failCase: (_, error) => onFail(error),\n    dieCase: (_, defect) => onDie(defect),\n    interruptCase: (_, fiberId) => onInterrupt(fiberId),\n    sequentialCase: (_, left, right) => onSequential(left, right),\n    parallelCase: (_, left, right) => onParallel(left, right)\n  });\n});\n\n/** @internal */\nconst reduce = /*#__PURE__*/dual(3, (self, zero, pf) => {\n  let accumulator = zero;\n  let cause = self;\n  const causes = [];\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause);\n    accumulator = isSome(option) ? option.value : accumulator;\n    switch (cause._tag) {\n      case OP_SEQUENTIAL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OP_PARALLEL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      default:\n        {\n          cause = undefined;\n          break;\n        }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop();\n    }\n  }\n  return accumulator;\n});\n\n/** @internal */\nconst reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const cause = input.pop();\n    switch (cause._tag) {\n      case OP_EMPTY:\n        {\n          output.push(right(reducer.emptyCase(context)));\n          break;\n        }\n      case OP_FAIL:\n        {\n          output.push(right(reducer.failCase(context, cause.error)));\n          break;\n        }\n      case OP_DIE:\n        {\n          output.push(right(reducer.dieCase(context, cause.defect)));\n          break;\n        }\n      case OP_INTERRUPT:\n        {\n          output.push(right(reducer.interruptCase(context, cause.fiberId)));\n          break;\n        }\n      case OP_SEQUENTIAL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(left({\n            _tag: OP_SEQUENTIAL_CASE\n          }));\n          break;\n        }\n      case OP_PARALLEL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(left({\n            _tag: OP_PARALLEL_CASE\n          }));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case OP_SEQUENTIAL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.sequentialCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_PARALLEL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.parallelCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/io/issues\");\n  }\n  return accumulator.pop();\n});\n\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n\nconst makeException = (proto, tag) => {\n  const _tag = {\n    value: tag,\n    enumerable: true\n  };\n  const protoWithToString = {\n    ...proto,\n    toString() {\n      return `${this._tag}: ${this.message}`;\n    }\n  };\n  return message => Object.create(protoWithToString, {\n    _tag,\n    message: {\n      value: message,\n      enumerable: true\n    }\n  });\n};\n\n/** @internal */\nconst RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/RuntimeException\");\n\n/** @internal */\nconst RuntimeException = /*#__PURE__*/makeException({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\");\n\n/** @internal */\nconst isRuntimeException = u => {\n  return typeof u === \"object\" && u != null && RuntimeExceptionTypeId in u;\n};\n\n/** @internal */\nconst InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/InterruptedException\");\n\n/** @internal */\nconst InterruptedException = /*#__PURE__*/makeException({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\");\n\n/** @internal */\nconst isInterruptedException = u => {\n  return typeof u === \"object\" && u != null && InterruptedExceptionTypeId in u;\n};\n\n/** @internal */\nconst IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/IllegalArgument\");\n\n/** @internal */\nconst IllegalArgumentException = /*#__PURE__*/makeException({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\");\n\n/** @internal */\nconst isIllegalArgumentException = u => {\n  return typeof u === \"object\" && u != null && IllegalArgumentExceptionTypeId in u;\n};\n\n/** @internal */\nconst NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/NoSuchElement\");\n\n/** @internal */\nconst NoSuchElementException = /*#__PURE__*/makeException({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\");\n\n/** @internal */\nconst isNoSuchElementException = u => {\n  return typeof u === \"object\" && u != null && NoSuchElementExceptionTypeId in u;\n};\n\n/** @internal */\nconst InvalidPubSubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/InvalidPubSubCapacityException\");\n\n/** @internal */\nconst InvalidPubSubCapacityException = /*#__PURE__*/makeException({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\");\n\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n\nconst filterStack = stack => {\n  const lines = stack.split(\"\\n\");\n  const out = [];\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].includes(\"EffectPrimitive\") || lines[i].includes(\"Generator.next\") || lines[i].includes(\"FiberRuntime\")) {\n      return out.join(\"\\n\");\n    } else {\n      out.push(lines[i]);\n    }\n  }\n  return out.join(\"\\n\");\n};\n\n/** @internal */\nconst pretty = cause => {\n  if (isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\";\n  }\n  const final = prettyErrors(cause).map(e => {\n    let message = e.message;\n    if (e.stack) {\n      message += `\\r\\n${filterStack(e.stack)}`;\n    }\n    if (e.span) {\n      let current = e.span;\n      let i = 0;\n      while (current && current._tag === \"Span\" && i < 10) {\n        message += `\\r\\n    at ${current.name}`;\n        current = getOrUndefined(current.parent);\n        i++;\n      }\n    }\n    return message;\n  }).join(\"\\r\\n\");\n  return final;\n};\nclass PrettyError {\n  constructor(message, stack, span) {\n    this.message = message;\n    this.stack = stack;\n    this.span = span;\n  }\n  toJSON() {\n    const out = {\n      message: this.message\n    };\n    if (this.stack) {\n      out.stack = this.stack;\n    }\n    if (this.span) {\n      out.span = this.span;\n    }\n    return out;\n  }\n}\n\n/**\n * A utility function for generating human-readable error messages from a generic error of type `unknown`.\n *\n * Rules:\n *\n * 1) If the input `u` is already a string, it's considered a message, and \"Error\" is added as a prefix.\n * 2) If `u` has a user-defined `toString()` method, it uses that method and adds \"Error\" as a prefix.\n * 3) If `u` is an object and its only (optional) properties are \"name\", \"message\", or \"_tag\", it constructs\n *    an error message based on those properties.\n * 4) Otherwise, it uses `JSON.stringify` to produce a string representation and uses it as the error message,\n *   with \"Error\" added as a prefix.\n *\n * @internal\n */\nconst prettyErrorMessage = u => {\n  // 1)\n  if (typeof u === \"string\") {\n    return `Error: ${u}`;\n  }\n  // 2)\n  if (typeof u === \"object\" && u != null && \"toString\" in u && typeof u[\"toString\"] === \"function\" && u[\"toString\"] !== Object.prototype.toString) {\n    return u[\"toString\"]();\n  }\n  // 3)\n  return `Error: ${JSON.stringify(u)}`;\n};\nconst spanSymbol = /*#__PURE__*/Symbol.for(\"effect/SpanAnnotation\");\nconst defaultRenderError = error => {\n  const span = typeof error === \"object\" && error !== null && spanSymbol in error && error[spanSymbol];\n  if (typeof error === \"object\" && error !== null && error instanceof Error) {\n    return new PrettyError(prettyErrorMessage(error), error.stack?.split(\"\\n\").filter(_ => _.match(/at (.*)/)).join(\"\\n\"), span);\n  }\n  return new PrettyError(prettyErrorMessage(error), void 0, span);\n};\n\n/** @internal */\nconst prettyErrors = cause => reduceWithContext(cause, void 0, {\n  emptyCase: () => [],\n  dieCase: (_, unknownError) => {\n    return [defaultRenderError(unknownError)];\n  },\n  failCase: (_, error) => {\n    return [defaultRenderError(error)];\n  },\n  interruptCase: () => [],\n  parallelCase: (_, l, r) => [...l, ...r],\n  sequentialCase: (_, l, r) => [...l, ...r]\n});\n\nexport { CauseTypeId, IllegalArgumentException, IllegalArgumentExceptionTypeId, InterruptedException, InterruptedExceptionTypeId, InvalidPubSubCapacityException, InvalidPubSubCapacityExceptionTypeId, NoSuchElementException, NoSuchElementExceptionTypeId, RuntimeException, RuntimeExceptionTypeId, as, contains, defects, die, dieOption, electFailures, empty, fail, failureOption, failureOrCause, failures, filter, find, flatMap, flatten, flipCauseOption, interrupt, interruptOption, interruptors, isCause, isDie, isDieType, isEmpty, isEmptyType, isFailType, isFailure, isIllegalArgumentException, isInterruptType, isInterrupted, isInterruptedException, isInterruptedOnly, isNoSuchElementException, isParallelType, isRuntimeException, isSequentialType, keepDefects, keepDefectsAndElectFailures, linearize, map, match, parallel, pretty, prettyErrorMessage, prettyErrors, reduce, reduceWithContext, sequential, size, squash, squashWith, stripFailures, stripSomeDefects };\n","/** @internal */\nconst OP_STATE_PENDING = \"Pending\";\n\n/** @internal */\n\n/** @internal */\nconst OP_STATE_DONE = \"Done\";\n\n/** @internal */\n\nexport { OP_STATE_DONE, OP_STATE_PENDING };\n","import { OP_STATE_PENDING, OP_STATE_DONE } from './opCodes/deferred.esm.js';\n\n/** @internal */\nconst DeferredSymbolKey = \"effect/Deferred\";\n\n/** @internal */\nconst DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);\n\n/** @internal */\nconst deferredVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst pending = joiners => {\n  return {\n    _tag: OP_STATE_PENDING,\n    joiners\n  };\n};\n\n/** @internal */\nconst done = effect => {\n  return {\n    _tag: OP_STATE_DONE,\n    effect\n  };\n};\n\nexport { DeferredTypeId, deferredVariance, done, pending };\n","import { dual } from '../Function/dist/effect-Function.esm.js';\n\n/** @internal */\nconst BIT_MASK = 0xff;\n\n/** @internal */\nconst BIT_SHIFT = 0x08;\n\n/** @internal */\nconst active = patch => patch & BIT_MASK;\n\n/** @internal */\nconst enabled = patch => patch >> BIT_SHIFT & BIT_MASK;\n\n/** @internal */\nconst make = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);\n\n/** @internal */\nconst empty = /*#__PURE__*/make(0, 0);\n\n/** @internal */\nconst enable = flag => make(flag, flag);\n\n/** @internal */\nconst disable = flag => make(flag, 0);\n\n/** @internal */\nconst isEmpty = patch => patch === 0;\n\n/** @internal */\nconst isActive = /*#__PURE__*/dual(2, (self, flag) => (active(self) & flag) !== 0);\n\n/** @internal */\nconst isEnabled = /*#__PURE__*/dual(2, (self, flag) => (enabled(self) & flag) !== 0);\n\n/** @internal */\nconst isDisabled = /*#__PURE__*/dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);\n\n/** @internal */\nconst exclude = /*#__PURE__*/dual(2, (self, flag) => make(active(self) & ~flag, enabled(self)));\n\n/** @internal */\nconst both = /*#__PURE__*/dual(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)));\n\n/** @internal */\nconst either = /*#__PURE__*/dual(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)));\n\n/** @internal */\nconst andThen = /*#__PURE__*/dual(2, (self, that) => self | that);\n\n/** @internal */\nconst inverse = patch => make(enabled(patch), invert(active(patch)));\n\n/** @internal */\nconst invert = n => ~n >>> 0 & BIT_MASK;\n\nexport { active, andThen, both, disable, either, empty, enable, enabled, exclude, inverse, invert, isActive, isDisabled, isEmpty, isEnabled, make };\n","import { make as make$2 } from '../Differ/dist/effect-Differ.esm.js';\nimport { dual } from '../Function/dist/effect-Function.esm.js';\nimport { active, enabled, make as make$1, invert, empty, andThen } from './runtimeFlagsPatch.esm.js';\n\n/** @internal */\nconst None = 0;\n\n/** @internal */\nconst Interruption = 1 << 0;\n\n/** @internal */\nconst OpSupervision = 1 << 1;\n\n/** @internal */\nconst RuntimeMetrics = 1 << 2;\n\n/** @internal */\nconst WindDown = 1 << 4;\n\n/** @internal */\nconst CooperativeYielding = 1 << 5;\n\n/** @internal */\nconst allFlags = [None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];\nconst print = flag => {\n  switch (flag) {\n    case CooperativeYielding:\n      {\n        return \"CooperativeYielding\";\n      }\n    case WindDown:\n      {\n        return \"WindDown\";\n      }\n    case RuntimeMetrics:\n      {\n        return \"RuntimeMetrics\";\n      }\n    case OpSupervision:\n      {\n        return \"OpSupervision\";\n      }\n    case Interruption:\n      {\n        return \"Interruption\";\n      }\n    case None:\n      {\n        return \"None\";\n      }\n  }\n};\n\n/** @internal */\nconst cooperativeYielding = self => isEnabled(self, CooperativeYielding);\n\n/** @internal */\nconst disable = /*#__PURE__*/dual(2, (self, flag) => self & ~flag);\n\n/** @internal */\nconst disableAll = /*#__PURE__*/dual(2, (self, flags) => self & ~flags);\n\n/** @internal */\nconst enable = /*#__PURE__*/dual(2, (self, flag) => self | flag);\n\n/** @internal */\nconst enableAll = /*#__PURE__*/dual(2, (self, flags) => self | flags);\n\n/** @internal */\nconst interruptible = self => interruption(self) && !windDown(self);\n\n/** @internal */\nconst interruption = self => isEnabled(self, Interruption);\n\n/** @internal */\nconst isDisabled = /*#__PURE__*/dual(2, (self, flag) => !isEnabled(self, flag));\n\n/** @internal */\nconst isEnabled = /*#__PURE__*/dual(2, (self, flag) => (self & flag) !== 0);\n\n/** @internal */\nconst make = (...flags) => flags.reduce((a, b) => a | b, 0);\n\n/** @internal */\nconst none = /*#__PURE__*/make(None);\n\n/** @internal */\nconst opSupervision = self => isEnabled(self, OpSupervision);\n\n/** @internal */\nconst render = self => {\n  const active = [];\n  allFlags.forEach(flag => {\n    if (isEnabled(self, flag)) {\n      active.push(`${print(flag)}`);\n    }\n  });\n  return `RuntimeFlags(${active.join(\", \")})`;\n};\n\n/** @internal */\nconst runtimeMetrics = self => isEnabled(self, RuntimeMetrics);\n\n/** @internal */\nconst toSet = self => new Set(allFlags.filter(flag => isEnabled(self, flag)));\nconst windDown = self => isEnabled(self, WindDown);\n\n// circular with RuntimeFlagsPatch\n\n/** @internal */\nconst enabledSet = self => toSet(active(self) & enabled(self));\n\n/** @internal */\nconst disabledSet = self => toSet(active(self) & ~enabled(self));\n\n/** @internal */\nconst diff = /*#__PURE__*/dual(2, (self, that) => make$1(self ^ that, that));\n\n/** @internal */\nconst patch = /*#__PURE__*/dual(2, (self, patch) => self & (invert(active(patch)) | enabled(patch)) | active(patch) & enabled(patch));\n\n/** @internal */\nconst renderPatch = self => {\n  const enabled = Array.from(enabledSet(self)).map(flag => print(flag)).join(\", \");\n  const disabled = Array.from(disabledSet(self)).map(flag => print(flag)).join(\", \");\n  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;\n};\n\n/** @internal */\nconst differ = /*#__PURE__*/make$2({\n  empty: empty,\n  diff: (oldValue, newValue) => diff(oldValue, newValue),\n  combine: (first, second) => andThen(second)(first),\n  patch: (_patch, oldValue) => patch(oldValue, _patch)\n});\n\nexport { CooperativeYielding, Interruption, None, OpSupervision, RuntimeMetrics, WindDown, allFlags, cooperativeYielding, diff, differ, disable, disableAll, disabledSet, enable, enableAll, enabledSet, interruptible, interruption, isDisabled, isEnabled, make, none, opSupervision, patch, render, renderPatch, runtimeMetrics, toSet, windDown };\n","import { enabledSet as enabledSet$1, disabledSet as disabledSet$1, renderPatch } from '../../internal/runtimeFlags.esm.js';\nimport { empty as empty$1, make as make$1, enable as enable$1, disable as disable$1, isEmpty as isEmpty$1, isActive as isActive$1, isEnabled as isEnabled$1, isDisabled as isDisabled$1, andThen as andThen$1, both as both$1, either as either$1, exclude as exclude$1, inverse as inverse$1 } from '../../internal/runtimeFlagsPatch.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The empty `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst enable = enable$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst disable = disable$1;\n\n/**\n * Returns `true` if the specified `RuntimeFlagsPatch` is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isEmpty = isEmpty$1;\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as active.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isActive = isActive$1;\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as enabled.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isEnabled = isEnabled$1;\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as disabled.\n *\n * @since 2.0.0\n * @category elements\n */\nconst isDisabled = isDisabled$1;\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n * `RuntimeFlag`, `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nconst includes = isActive$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n * followed by `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nconst andThen = andThen$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n * and `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nconst both = both$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n * patch or `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nconst either = either$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n * `RuntimeFlag` from the set of `RuntimeFlags`.\n *\n * @category utils\n * @since 2.0.0\n */\nconst exclude = exclude$1;\n\n/**\n * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\n * specified by the provided `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst inverse = inverse$1;\n\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * enabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst enabledSet = enabledSet$1;\n\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * disabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst disabledSet = disabledSet$1;\n\n/**\n * Renders the provided `RuntimeFlagsPatch` to a string.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst render = renderPatch;\n\nexport { andThen, both, disable, disabledSet, either, empty, enable, enabledSet, exclude, includes, inverse, isActive, isDisabled, isEmpty, isEnabled, make, render };\n","import { unsafeHead, make, empty as empty$6, fromIterable, isNonEmpty, reverse, headNonEmpty, of, prepend, tailNonEmpty } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { empty as empty$1, merge } from '../Context/dist/effect-Context.esm.js';\nimport { update, hashSet, environment } from '../Differ/dist/effect-Differ.esm.js';\nimport { isRight, left, right } from '../Either/dist/effect-Either.esm.js';\nimport { symbol, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { none } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { dual, pipe, identity } from '../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { symbol as symbol$1, random, hash } from '../Hash/dist/effect-Hash.esm.js';\nimport { empty as empty$2 } from '../HashMap/dist/effect-HashMap.esm.js';\nimport { empty as empty$4 } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { toJSON, toString, NodeInspectSymbol } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { reduce, empty, par, seq, single } from './blockedRequests.esm.js';\nimport { failureOrCause, die as die$1, fail as fail$1, failures, defects, electFailures, interrupt as interrupt$1, isInterruptedOnly, interruptors, keepDefectsAndElectFailures, empty as empty$5, isInterrupted, parallel, sequential, map as map$1, RuntimeException } from './cause.esm.js';\nimport { DeferredTypeId, deferredVariance, pending, done } from './deferred.esm.js';\nimport { OP_STATE_PENDING, OP_STATE_DONE } from './opCodes/deferred.esm.js';\nimport { OP_SUCCESS, OP_FAILURE, OP_WITH_RUNTIME, OP_ON_FAILURE, OP_ON_SUCCESS, OP_ON_SUCCESS_AND_FAILURE, OP_UPDATE_RUNTIME_FLAGS, OP_SYNC, OP_WHILE, OP_YIELD, OP_REVERT_FLAGS, OP_ASYNC } from './opCodes/effect.esm.js';\nimport { Interruption, interruption, differ } from './runtimeFlags.esm.js';\nimport { empty as empty$3, isCons } from '../List/dist/effect-List.esm.js';\nimport { make as make$1, get, set } from '../MutableRef/dist/effect-MutableRef.esm.js';\nimport { getOrElse, getOrThrow, some, none as none$1, match } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { reduce as reduce$1, fromIterable as fromIterable$1 } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\nimport { enable, disable } from '../RuntimeFlagsPatch/dist/effect-RuntimeFlagsPatch.esm.js';\n\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n/** @internal */\nconst EffectErrorSymbolKey = \"effect/EffectError\";\n\n/** @internal */\nconst EffectErrorTypeId = /*#__PURE__*/Symbol.for(EffectErrorSymbolKey);\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst isEffectError = u => typeof u === \"object\" && u != null && EffectErrorTypeId in u;\n\n/** @internal */\nconst makeEffectError = cause => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n});\n\n/**\n * @internal\n */\nconst blocked = (blockedRequests, _continue) => {\n  const effect = new EffectPrimitive(\"Blocked\");\n  effect.i0 = blockedRequests;\n  effect.i1 = _continue;\n  return effect;\n};\n\n/**\n * @internal\n */\nconst runRequestBlock = blockedRequests => {\n  const effect = new EffectPrimitive(\"RunBlocked\");\n  effect.i0 = blockedRequests;\n  return effect;\n};\n\n/** @internal */\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"effect/Effect\");\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nclass RevertFlags {\n  _op = OP_REVERT_FLAGS;\n  constructor(patch, op) {\n    this.patch = patch;\n    this.op = op;\n  }\n}\n\n/** @internal */\nclass EffectPrimitive {\n  i0 = undefined;\n  i1 = undefined;\n  i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n  }\n  [symbol](that) {\n    return this === that;\n  }\n  [symbol$1]() {\n    return random(this);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      i0: toJSON(this.i0),\n      i1: toJSON(this.i1),\n      i2: toJSON(this.i2)\n    };\n  }\n  toString() {\n    return toString(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveFailure {\n  i0 = undefined;\n  i1 = undefined;\n  i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n    // @ts-expect-error\n    this._tag = _op;\n  }\n  [symbol](that) {\n    return this === that;\n  }\n  [symbol$1]() {\n    return random(this);\n  }\n  get cause() {\n    return this.i0;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: this.cause.toJSON()\n    };\n  }\n  toString() {\n    return toString(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveSuccess {\n  i0 = undefined;\n  i1 = undefined;\n  i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n    // @ts-expect-error\n    this._tag = _op;\n  }\n  [symbol](that) {\n    return this === that;\n  }\n  [symbol$1]() {\n    return random(this);\n  }\n  get value() {\n    return this.i0;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    };\n  }\n  toString() {\n    return toString(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst isEffect = u => typeof u === \"object\" && u != null && EffectTypeId in u;\n\n/* @internal */\nconst withFiberRuntime = withRuntime => {\n  const effect = new EffectPrimitive(OP_WITH_RUNTIME);\n  effect.i0 = withRuntime;\n  return effect;\n};\n\n/* @internal */\nconst acquireUseRelease = /*#__PURE__*/dual(3, (acquire, use, release) => uninterruptibleMask(restore => flatMap(acquire, a => flatMap(exit(suspend(() => restore(step(use(a))))), exit => {\n  if (exit._tag === \"Success\" && exit.value._op === \"Blocked\") {\n    const value = exit.value;\n    return blocked(value.i0, acquireUseRelease(succeed(a), () => value.i1, release));\n  }\n  const flat = exitFlatten(exit);\n  return suspend(() => release(a, flat)).pipe(matchCauseEffect({\n    onFailure: cause => {\n      switch (flat._tag) {\n        case OP_FAILURE:\n          {\n            return failCause(parallel(flat.i0, cause));\n          }\n        case OP_SUCCESS:\n          {\n            return failCause(cause);\n          }\n      }\n    },\n    onSuccess: () => flat\n  }));\n}))));\n\n/* @internal */\nconst as = /*#__PURE__*/dual(2, (self, value) => flatMap(self, () => succeed(value)));\n\n/* @internal */\nconst asUnit = self => as(self, void 0);\n\n/* @internal */\nconst async = (register, blockingOn = none) => suspend(() => {\n  let cancelerRef = undefined;\n  let controllerRef = undefined;\n  const effect = new EffectPrimitive(OP_ASYNC);\n  if (register.length !== 1) {\n    const controller = new AbortController();\n    controllerRef = controller;\n    effect.i0 = resume => {\n      cancelerRef = register(resume, controller.signal);\n    };\n  } else {\n    effect.i0 = resume => {\n      // @ts-expect-error\n      cancelerRef = register(resume);\n    };\n  }\n  effect.i1 = blockingOn;\n  return onInterrupt(effect, () => {\n    if (controllerRef) {\n      controllerRef.abort();\n    }\n    return cancelerRef ?? unit;\n  });\n});\n\n/* @internal */\nconst asyncEither = (register, blockingOn = none) => async(resume => {\n  const result = register(resume);\n  if (isRight(result)) {\n    resume(result.right);\n  } else {\n    return result.left;\n  }\n}, blockingOn);\n\n/* @internal */\nconst catchAllCause = /*#__PURE__*/dual(2, (self, f) => {\n  const effect = new EffectPrimitive(OP_ON_FAILURE);\n  effect.i0 = self;\n  effect.i1 = f;\n  return effect;\n});\n\n/* @internal */\nconst catchAll = /*#__PURE__*/dual(2, (self, f) => matchEffect(self, {\n  onFailure: f,\n  onSuccess: succeed\n}));\n\n/**\n * @macro identity\n * @internal\n */\nconst unified = f => (...args) => f(...args);\n\n/* @internal */\nconst catchIf = /*#__PURE__*/dual(3, (self, predicate, f) => catchAllCause(self, cause => {\n  const either = failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return predicate(either.left) ? f(either.left) : failCause(cause);\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n}));\n\n/* @internal */\nconst catchSome = /*#__PURE__*/dual(2, (self, pf) => catchAllCause(self, cause => {\n  const either = failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return pipe(pf(either.left), getOrElse(() => failCause(cause)));\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n}));\n\n/* @internal */\nconst checkInterruptible = f => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));\nconst spanSymbol = /*#__PURE__*/Symbol.for(\"effect/SpanAnnotation\");\nconst originalSymbol = /*#__PURE__*/Symbol.for(\"effect/OriginalAnnotation\");\n\n/* @internal */\nconst originalInstance = obj => {\n  if (typeof obj === \"object\" && obj !== null && originalSymbol in obj) {\n    // @ts-expect-error\n    return obj[originalSymbol];\n  }\n  return obj;\n};\n\n/* @internal */\nconst capture = (obj, span) => {\n  if (isCons(span)) {\n    const head = span.head;\n    if (head._tag === \"Span\") {\n      return new Proxy(obj, {\n        has(target, p) {\n          return p === spanSymbol || p === originalSymbol || p in target;\n        },\n        get(target, p) {\n          if (p === spanSymbol) {\n            return head;\n          }\n          if (p === originalSymbol) {\n            return obj;\n          }\n          // @ts-expect-error\n          return target[p];\n        }\n      });\n    }\n  }\n  return obj;\n};\n\n/* @internal */\nconst die = defect => typeof defect === \"object\" && defect !== null && !(spanSymbol in defect) ? withFiberRuntime(fiber => failCause(die$1(capture(defect, fiber.getFiberRef(currentTracerSpan))))) : failCause(die$1(defect));\n\n/* @internal */\nconst dieMessage = message => failCauseSync(() => die$1(RuntimeException(message)));\n\n/* @internal */\nconst dieSync = evaluate => flatMap(sync(evaluate), die);\n\n/* @internal */\nconst either = self => matchEffect(self, {\n  onFailure: e => succeed(left(e)),\n  onSuccess: a => succeed(right(a))\n});\n\n/* @internal */\nconst context = () => suspend(() => fiberRefGet(currentContext));\n\n/* @internal */\nconst contextWithEffect = f => flatMap(context(), f);\n\n/* @internal */\nconst exit = self => matchCause(self, {\n  onFailure: exitFailCause,\n  onSuccess: exitSucceed\n});\n\n/* @internal */\nconst fail = error => typeof error === \"object\" && error !== null && !(spanSymbol in error) ? withFiberRuntime(fiber => failCause(fail$1(capture(error, fiber.getFiberRef(currentTracerSpan))))) : failCause(fail$1(error));\n\n/* @internal */\nconst failSync = evaluate => flatMap(sync(evaluate), fail);\n\n/* @internal */\nconst failCause = cause => {\n  const effect = new EffectPrimitiveFailure(OP_FAILURE);\n  effect.i0 = cause;\n  return effect;\n};\n\n/* @internal */\nconst failCauseSync = evaluate => flatMap(sync(evaluate), failCause);\n\n/* @internal */\nconst fiberId = /*#__PURE__*/withFiberRuntime(state => succeed(state.id()));\n\n/* @internal */\nconst fiberIdWith = f => withFiberRuntime(state => f(state.id()));\n\n/* @internal */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  const effect = new EffectPrimitive(OP_ON_SUCCESS);\n  effect.i0 = self;\n  effect.i1 = f;\n  return effect;\n});\n\n/* @internal */\nconst step = self => {\n  const effect = new EffectPrimitive(\"OnStep\");\n  effect.i0 = self;\n  effect.i1 = exitSucceed;\n  return effect;\n};\n\n/* @internal */\nconst flatMapStep = (self, f) => {\n  const effect = new EffectPrimitive(\"OnStep\");\n  effect.i0 = self;\n  effect.i1 = f;\n  return effect;\n};\n\n/* @internal */\nconst flatten = self => flatMap(self, identity);\n\n/* @internal */\nconst flip = self => matchEffect(self, {\n  onFailure: succeed,\n  onSuccess: fail\n});\n\n/* @internal */\nconst matchCause = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchCauseEffect(self, {\n  onFailure: cause => succeed(onFailure(cause)),\n  onSuccess: a => succeed(onSuccess(a))\n}));\n\n/* @internal */\nconst matchCauseEffect = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);\n  effect.i0 = self;\n  effect.i1 = onFailure;\n  effect.i2 = onSuccess;\n  return effect;\n});\n\n/* @internal */\nconst matchEffect = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const failures$1 = failures(cause);\n    const defects$1 = defects(cause);\n    if (defects$1.length > 0) {\n      return failCause(electFailures(cause));\n    }\n    if (failures$1.length > 0) {\n      return onFailure(unsafeHead(failures$1));\n    }\n    return failCause(cause);\n  },\n  onSuccess\n}));\n\n/* @internal */\nconst forEachSequential = /*#__PURE__*/dual(2, (self, f) => suspend(() => {\n  const arr = fromIterable$1(self);\n  const ret = new Array(arr.length);\n  let i = 0;\n  return as(whileLoop({\n    while: () => i < arr.length,\n    body: () => f(arr[i], i),\n    step: b => {\n      ret[i++] = b;\n    }\n  }), ret);\n}));\n\n/* @internal */\nconst forEachSequentialDiscard = /*#__PURE__*/dual(2, (self, f) => suspend(() => {\n  const arr = fromIterable$1(self);\n  let i = 0;\n  return whileLoop({\n    while: () => i < arr.length,\n    body: () => f(arr[i], i),\n    step: () => {\n      i++;\n    }\n  });\n}));\n\n/* @internal */\nconst if_ = /*#__PURE__*/dual(args => typeof args[0] === \"boolean\" || isEffect(args[0]), (self, {\n  onFalse,\n  onTrue\n}) => typeof self === \"boolean\" ? self ? onTrue : onFalse : flatMap(self, unified(b => b ? onTrue : onFalse)));\n\n/* @internal */\nconst interrupt = /*#__PURE__*/flatMap(fiberId, fiberId => interruptWith(fiberId));\n\n/* @internal */\nconst interruptWith = fiberId => failCause(interrupt$1(fiberId));\n\n/* @internal */\nconst interruptible = self => {\n  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = enable(Interruption);\n  const _continue = orBlock => {\n    if (orBlock._tag === \"Blocked\") {\n      return blocked(orBlock.i0, interruptible(orBlock.i1));\n    } else {\n      return orBlock;\n    }\n  };\n  effect.i1 = () => flatMapStep(self, _continue);\n  return effect;\n};\n\n/* @internal */\nconst interruptibleMask = f => {\n  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = enable(Interruption);\n  const _continue = step => {\n    if (step._op === \"Blocked\") {\n      return blocked(step.i0, interruptible(step.i1));\n    }\n    return step;\n  };\n  effect.i1 = oldFlags => interruption(oldFlags) ? step(f(interruptible)) : step(f(uninterruptible));\n  return flatMap(effect, _continue);\n};\n\n/* @internal */\nconst intoDeferred = /*#__PURE__*/dual(2, (self, deferred) => uninterruptibleMask(restore => flatMap(exit(restore(self)), exit => deferredDone(deferred, exit))));\n\n/* @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => sync(() => f(a))));\n\n/* @internal */\nconst mapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchEffect(self, {\n  onFailure: e => failSync(() => onFailure(e)),\n  onSuccess: a => sync(() => onSuccess(a))\n}));\n\n/* @internal */\nconst mapError = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return failSync(() => f(either.left));\n        }\n      case \"Right\":\n        {\n          return failCause(either.right);\n        }\n    }\n  },\n  onSuccess: succeed\n}));\n\n/* @internal */\nconst onError = /*#__PURE__*/dual(2, (self, cleanup) => onExit(self, unified(exit => exitIsSuccess(exit) ? unit : cleanup(exit.i0))));\n\n/* @internal */\nconst onExit = /*#__PURE__*/dual(2, (self, cleanup) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {\n  onFailure: cause1 => {\n    const result = exitFailCause(cause1);\n    return matchCauseEffect(cleanup(result), {\n      onFailure: cause2 => exitFailCause(sequential(cause1, cause2)),\n      onSuccess: () => result\n    });\n  },\n  onSuccess: success => {\n    const result = exitSucceed(success);\n    return zipRight(cleanup(result), result);\n  }\n})));\n\n/* @internal */\nconst onInterrupt = /*#__PURE__*/dual(2, (self, cleanup) => onExit(self, exitMatch({\n  onFailure: cause => isInterruptedOnly(cause) ? asUnit(cleanup(interruptors(cause))) : unit,\n  onSuccess: () => unit\n})));\n\n/* @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => attemptOrElse(self, that, succeed));\n\n/* @internal */\nconst orDie = self => orDieWith(self, identity);\n\n/* @internal */\nconst orDieWith = /*#__PURE__*/dual(2, (self, f) => matchEffect(self, {\n  onFailure: e => die(f(e)),\n  onSuccess: succeed\n}));\n\n/* @internal */\nconst partitionMap = (elements, f) => fromIterable$1(elements).reduceRight(([lefts, rights], current) => {\n  const either = f(current);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [[either.left, ...lefts], rights];\n      }\n    case \"Right\":\n      {\n        return [lefts, [either.right, ...rights]];\n      }\n  }\n}, [new Array(), new Array()]);\n\n/* @internal */\nconst provideContext = /*#__PURE__*/dual(2, (self, context) => fiberRefLocally(currentContext, context)(self));\n\n/* @internal */\nconst provideSomeContext = /*#__PURE__*/dual(2, (self, context) => fiberRefLocallyWith(currentContext, parent => merge(parent, context))(self));\n\n/* @internal */\nconst mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithEffect(context => provideContext(self, f(context))));\n\n/* @internal */\nconst runtimeFlags = /*#__PURE__*/withFiberRuntime((_, status) => succeed(status.runtimeFlags));\n\n/* @internal */\nconst succeed = value => {\n  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);\n  effect.i0 = value;\n  return effect;\n};\n\n/* @internal */\nconst suspend = effect => flatMap(sync(effect), identity);\n\n/* @internal */\nconst sync = evaluate => {\n  const effect = new EffectPrimitive(OP_SYNC);\n  effect.i0 = evaluate;\n  return effect;\n};\n\n/* @internal */\nconst tap = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => as(f(a), a)));\n\n/* @internal */\nconst transplant = f => withFiberRuntime(state => {\n  const scopeOverride = state.getFiberRef(currentForkScopeOverride);\n  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));\n  return f(fiberRefLocally(currentForkScopeOverride, some(scope)));\n});\n\n/* @internal */\nconst attemptOrElse = /*#__PURE__*/dual(3, (self, that, onSuccess) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const defects$1 = defects(cause);\n    if (defects$1.length > 0) {\n      return failCause(getOrThrow(keepDefectsAndElectFailures(cause)));\n    }\n    return that();\n  },\n  onSuccess\n}));\n\n/* @internal */\nconst uninterruptible = self => {\n  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = disable(Interruption);\n  effect.i1 = () => flatMapStep(self, _continue);\n  const _continue = orBlock => {\n    if (orBlock._tag === \"Blocked\") {\n      return blocked(orBlock.i0, uninterruptible(orBlock.i1));\n    } else {\n      return orBlock;\n    }\n  };\n  return effect;\n};\n\n/* @internal */\nconst uninterruptibleMask = f => {\n  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = disable(Interruption);\n  const _continue = step => {\n    if (step._op === \"Blocked\") {\n      return blocked(step.i0, uninterruptible(step.i1));\n    }\n    return step;\n  };\n  effect.i1 = oldFlags => interruption(oldFlags) ? step(f(interruptible)) : step(f(uninterruptible));\n  return flatMap(effect, _continue);\n};\n\n/* @internal */\nconst unit = /*#__PURE__*/succeed(void 0);\n\n/* @internal */\nconst updateRuntimeFlags = patch => {\n  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = patch;\n  effect.i1 = void 0;\n  return effect;\n};\n\n/* @internal */\nconst whenEffect = /*#__PURE__*/dual(2, (self, predicate) => flatMap(predicate, b => {\n  if (b) {\n    return pipe(self, map(some));\n  }\n  return succeed(none$1());\n}));\n\n/* @internal */\nconst whileLoop = options => {\n  const effect = new EffectPrimitive(OP_WHILE);\n  effect.i0 = options.while;\n  effect.i1 = options.body;\n  effect.i2 = options.step;\n  return effect;\n};\n\n/* @internal */\nconst withConcurrency = /*#__PURE__*/dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));\n\n/* @internal */\nconst withRequestBatching = /*#__PURE__*/dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));\n\n/* @internal */\nconst withRuntimeFlags = /*#__PURE__*/dual(2, (self, update) => {\n  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = update;\n  effect.i1 = () => self;\n  return effect;\n});\n\n/** @internal */\nconst withTracerTiming = /*#__PURE__*/dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled));\n\n/* @internal */\nconst yieldNow = options => {\n  const effect = new EffectPrimitive(OP_YIELD);\n  return typeof options?.priority !== \"undefined\" ? withSchedulingPriority(options.priority)(effect) : effect;\n};\n\n/* @internal */\nconst zip = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => map(that, b => [a, b])));\n\n/* @internal */\nconst zipLeft = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => as(that, a)));\n\n/* @internal */\nconst zipRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));\n\n/* @internal */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, a => map(that, b => f(a, b))));\n\n/* @internal */\nconst never = /*#__PURE__*/asyncEither(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1);\n  return left(sync(() => clearInterval(interval)));\n});\n\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n\n/* @internal */\nconst interruptFiber = self => flatMap(fiberId, fiberId => pipe(self, interruptAsFiber(fiberId)));\n\n/* @internal */\nconst interruptAsFiber = /*#__PURE__*/dual(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await()));\n\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst logLevelAll = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelFatal = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelError = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelWarning = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelInfo = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelDebug = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelTrace = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst logLevelNone = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];\n\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\";\n\n/** @internal */\nconst FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);\n\n/** @internal */\nconst fiberRefVariance = {\n  _A: _ => _\n};\n\n/* @internal */\nconst fiberRefGet = self => fiberRefModify(self, a => [a, a]);\n\n/* @internal */\nconst fiberRefGetAndSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, v => [v, value]));\n\n/* @internal */\nconst fiberRefGetAndUpdate = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => [v, f(v)]));\n\n/* @internal */\nconst fiberRefGetAndUpdateSome = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => [v, getOrElse(pf(v), () => v)]));\n\n/* @internal */\nconst fiberRefGetWith = /*#__PURE__*/dual(2, (self, f) => flatMap(fiberRefGet(self), f));\n\n/* @internal */\nconst fiberRefSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, () => [void 0, value]));\n\n/* @internal */\nconst fiberRefDelete = self => withFiberRuntime(state => {\n  state.unsafeDeleteFiberRef(self);\n  return unit;\n});\n\n/* @internal */\nconst fiberRefReset = self => fiberRefSet(self, self.initial);\n\n/* @internal */\nconst fiberRefModify = /*#__PURE__*/dual(2, (self, f) => withFiberRuntime(state => {\n  const [b, a] = f(state.getFiberRef(self));\n  state.setFiberRef(self, a);\n  return succeed(b);\n}));\n\n/* @internal */\nconst fiberRefModifySome = (self, def, f) => fiberRefModify(self, v => getOrElse(f(v), () => [def, v]));\n\n/* @internal */\nconst fiberRefUpdate = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => [void 0, f(v)]));\n\n/* @internal */\nconst fiberRefUpdateSome = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => [void 0, getOrElse(pf(v), () => v)]));\n\n/* @internal */\nconst fiberRefUpdateAndGet = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => {\n  const result = f(v);\n  return [result, result];\n}));\n\n/* @internal */\nconst fiberRefUpdateSomeAndGet = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => {\n  const result = getOrElse(pf(v), () => v);\n  return [result, result];\n}));\n\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\";\n\n/** @internal */\nconst RequestResolverTypeId = /*#__PURE__*/Symbol.for(RequestResolverSymbolKey);\nconst dataSourceVariance = {\n  _R: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\nclass RequestResolverImpl {\n  [RequestResolverTypeId] = dataSourceVariance;\n  constructor(runAll, target) {\n    this.runAll = runAll;\n    this.target = target;\n    this.runAll = runAll;\n  }\n  [symbol$1]() {\n    return this.target ? hash(this.target) : random(this);\n  }\n  [symbol](that) {\n    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;\n  }\n  identified(...ids) {\n    return new RequestResolverImpl(this.runAll, fromIterable(ids));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst isRequestResolver = u => typeof u === \"object\" && u != null && RequestResolverTypeId in u;\n\n// end\n\n/** @internal */\nconst resolverLocally = /*#__PURE__*/dual(3, (use, self, value) => new RequestResolverImpl(requests => fiberRefLocally(use.runAll(requests), self, value), make(\"Locally\", use, self, value)));\n\n/** @internal */\nconst requestBlockLocally = (self, ref, value) => reduce(self, LocallyReducer(ref, value));\nconst LocallyReducer = (ref, value) => ({\n  emptyCase: () => empty,\n  parCase: (left, right) => par(left, right),\n  seqCase: (left, right) => seq(left, right),\n  singleCase: (dataSource, blockedRequest) => single(resolverLocally(dataSource, ref, value), blockedRequest)\n});\n\n/* @internal */\nconst fiberRefLocally = /*#__PURE__*/dual(3, (use, self, value) => flatMap(acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => step(use), oldValue => fiberRefSet(self, oldValue)), res => {\n  if (res._op === \"Blocked\") {\n    return blocked(res.i0, fiberRefLocally(res.i1, self, value));\n  }\n  return res;\n}));\n\n/* @internal */\nconst fiberRefLocallyWith = /*#__PURE__*/dual(3, (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(use, self, f(a))));\n\n/** @internal */\nconst fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {\n  differ: update(),\n  fork: options?.fork ?? identity,\n  join: options?.join\n});\n\n/** @internal */\nconst fiberRefUnsafeMakeHashSet = initial => {\n  const differ = hashSet();\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n\n/** @internal */\nconst fiberRefUnsafeMakeContext = initial => {\n  const differ = environment();\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n\n/** @internal */\nconst fiberRefUnsafeMakePatch = (initial, options) => ({\n  [FiberRefTypeId]: fiberRefVariance,\n  initial,\n  diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),\n  combine: (first, second) => options.differ.combine(first, second),\n  patch: patch => oldValue => options.differ.patch(patch, oldValue),\n  fork: options.fork,\n  join: options.join ?? ((_, n) => n),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n\n/** @internal */\nconst fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, {\n  differ: differ,\n  fork: differ.empty\n});\n\n/** @internal */\nconst currentContext = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentContext\"), () => fiberRefUnsafeMakeContext(empty$1()));\n\n/** @internal */\nconst currentSchedulingPriority = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"), () => fiberRefUnsafeMake(0));\n\n/** @internal */\nconst currentMaxOpsBeforeYield = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"), () => fiberRefUnsafeMake(2048));\n\n/** @internal */\nconst currentLogAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogAnnotation\"), () => fiberRefUnsafeMake(empty$2()));\n\n/** @internal */\nconst currentLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogLevel\"), () => fiberRefUnsafeMake(logLevelInfo));\n\n/** @internal */\nconst currentLogSpan = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogSpan\"), () => fiberRefUnsafeMake(empty$3()));\n\n/** @internal */\nconst withSchedulingPriority = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));\n\n/** @internal */\nconst withMaxOpsBeforeYield = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));\n\n/** @internal */\nconst currentConcurrency = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentConcurrency\"), () => fiberRefUnsafeMake(\"unbounded\"));\n\n/**\n * @internal\n */\nconst currentRequestBatching = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentRequestBatching\"), () => fiberRefUnsafeMake(true));\n\n/** @internal */\nconst currentUnhandledErrorLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"), () => fiberRefUnsafeMake(some(logLevelDebug)));\n\n/** @internal */\nconst withUnhandledErrorLogLevel = /*#__PURE__*/dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));\n\n/** @internal */\nconst currentMetricLabels = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentMetricLabels\"), () => fiberRefUnsafeMakeHashSet(empty$4()));\n\n/* @internal */\nconst metricLabels = /*#__PURE__*/fiberRefGet(currentMetricLabels);\n\n/** @internal */\nconst currentForkScopeOverride = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"), () => fiberRefUnsafeMake(none$1(), {\n  fork: () => none$1(),\n  join: (parent, _) => parent\n}));\n\n/** @internal */\nconst currentInterruptedCause = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentInterruptedCause\"), () => fiberRefUnsafeMake(empty$5, {\n  fork: () => empty$5,\n  join: (parent, _) => parent\n}));\n\n/** @internal */\nconst currentTracerSpan = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpan\"), () => fiberRefUnsafeMake(empty$3()));\n\n/** @internal */\nconst currentTracerTimingEnabled = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerTiming\"), () => fiberRefUnsafeMake(true));\n\n/** @internal */\nconst currentTracerSpanAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"), () => fiberRefUnsafeMake(empty$2()));\n\n/** @internal */\nconst currentTracerSpanLinks = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"), () => fiberRefUnsafeMake(empty$6()));\n\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst ScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/Scope\");\n\n/** @internal */\nconst CloseableScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/CloseableScope\");\n\n/* @internal */\nconst scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asUnit(finalizer));\n\n/* @internal */\nconst scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);\n\n/* @internal */\nconst scopeClose = (self, exit) => self.close(exit);\n\n/* @internal */\nconst scopeFork = (self, strategy) => self.fork(strategy);\n\n// -----------------------------------------------------------------------------\n// ReleaseMap\n// -----------------------------------------------------------------------------\n\n/** @internal */\n/** @internal */\n/* @internal */\nconst releaseMapAdd = /*#__PURE__*/dual(2, (self, finalizer) => map(releaseMapAddIfOpen(self, finalizer), match({\n  onNone: () => () => unit,\n  onSome: key => exit => releaseMapRelease(key, exit)(self)\n})));\n\n/* @internal */\nconst releaseMapRelease = /*#__PURE__*/dual(3, (self, key, exit) => suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return unit;\n      }\n    case \"Running\":\n      {\n        const finalizer = self.state.finalizers.get(key);\n        self.state.finalizers.delete(key);\n        if (finalizer != null) {\n          return self.state.update(finalizer)(exit);\n        }\n        return unit;\n      }\n  }\n}));\n\n/* @internal */\nconst releaseMapAddIfOpen = /*#__PURE__*/dual(2, (self, finalizer) => suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        self.state.nextKey += 1;\n        return as(finalizer(self.state.exit), none$1());\n      }\n    case \"Running\":\n      {\n        const key = self.state.nextKey;\n        self.state.finalizers.set(key, finalizer);\n        self.state.nextKey += 1;\n        return succeed(some(key));\n      }\n  }\n}));\n\n/* @internal */\nconst releaseMapMake = /*#__PURE__*/sync(() => ({\n  state: {\n    _tag: \"Running\",\n    nextKey: 0,\n    finalizers: new Map(),\n    update: identity\n  }\n}));\n\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst exitIsExit = u => isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\");\n\n/** @internal */\nconst exitIsFailure = self => self._tag === \"Failure\";\n\n/** @internal */\nconst exitIsSuccess = self => self._tag === \"Success\";\n\n/** @internal */\nconst exitIsInterrupted = self => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return isInterrupted(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return false;\n      }\n  }\n};\n\n/** @internal */\nconst exitAs = /*#__PURE__*/dual(2, (self, value) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return exitFailCause(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return exitSucceed(value);\n      }\n  }\n});\n\n/** @internal */\nconst exitAsUnit = self => exitAs(self, void 0);\n\n/** @internal */\nconst exitCauseOption = self => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return some(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return none$1();\n      }\n  }\n};\n\n/** @internal */\nconst exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);\n\n/** @internal */\nconst exitDie = defect => exitFailCause(die$1(defect));\n\n/** @internal */\nconst exitExists = /*#__PURE__*/dual(2, (self, predicate) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return false;\n      }\n    case OP_SUCCESS:\n      {\n        return predicate(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitFail = error => exitFailCause(fail$1(error));\n\n/** @internal */\nconst exitFailCause = cause => {\n  const effect = new EffectPrimitiveFailure(OP_FAILURE);\n  effect.i0 = cause;\n  return effect;\n};\n\n/** @internal */\nconst exitFlatMap = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return exitFailCause(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return f(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitFlatMapEffect = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.i0));\n      }\n    case OP_SUCCESS:\n      {\n        return f(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitFlatten = self => pipe(self, exitFlatMap(identity));\n\n/** @internal */\nconst exitForEachEffect = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.i0));\n      }\n    case OP_SUCCESS:\n      {\n        return exit(f(self.i0));\n      }\n  }\n});\n\n/** @internal */\nconst exitFromEither = either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return exitFail(either.left);\n      }\n    case \"Right\":\n      {\n        return exitSucceed(either.right);\n      }\n  }\n};\n\n/** @internal */\nconst exitFromOption = option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return exitFail(void 0);\n      }\n    case \"Some\":\n      {\n        return exitSucceed(option.value);\n      }\n  }\n};\n\n/** @internal */\nconst exitGetOrElse = /*#__PURE__*/dual(2, (self, orElse) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return orElse(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return self.i0;\n      }\n  }\n});\n\n/** @internal */\nconst exitInterrupt = fiberId => exitFailCause(interrupt$1(fiberId));\n\n/** @internal */\nconst exitMap = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return exitFailCause(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return exitSucceed(f(self.i0));\n      }\n  }\n});\n\n/** @internal */\nconst exitMapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return exitFailCause(pipe(self.i0, map$1(onFailure)));\n      }\n    case OP_SUCCESS:\n      {\n        return exitSucceed(onSuccess(self.i0));\n      }\n  }\n});\n\n/** @internal */\nconst exitMapError = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return exitFailCause(pipe(self.i0, map$1(f)));\n      }\n    case OP_SUCCESS:\n      {\n        return exitSucceed(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitMapErrorCause = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return exitFailCause(f(self.i0));\n      }\n    case OP_SUCCESS:\n      {\n        return exitSucceed(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitMatch = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return onFailure(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return onSuccess(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitMatchEffect = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        return onFailure(self.i0);\n      }\n    case OP_SUCCESS:\n      {\n        return onSuccess(self.i0);\n      }\n  }\n});\n\n/** @internal */\nconst exitSucceed = value => {\n  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);\n  effect.i0 = value;\n  return effect;\n};\n\n/** @internal */\nconst exitUnit = /*#__PURE__*/exitSucceed(void 0);\n\n/** @internal */\nconst exitZip = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, a2) => [a, a2],\n  onFailure: sequential\n}));\n\n/** @internal */\nconst exitZipLeft = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, _) => a,\n  onFailure: sequential\n}));\n\n/** @internal */\nconst exitZipRight = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (_, a2) => a2,\n  onFailure: sequential\n}));\n\n/** @internal */\nconst exitZipPar = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, a2) => [a, a2],\n  onFailure: parallel\n}));\n\n/** @internal */\nconst exitZipParLeft = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, _) => a,\n  onFailure: parallel\n}));\n\n/** @internal */\nconst exitZipParRight = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (_, a2) => a2,\n  onFailure: parallel\n}));\n\n/** @internal */\nconst exitZipWith = /*#__PURE__*/dual(3, (self, that, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OP_FAILURE:\n      {\n        switch (that._tag) {\n          case OP_SUCCESS:\n            {\n              return exitFailCause(self.i0);\n            }\n          case OP_FAILURE:\n            {\n              return exitFailCause(onFailure(self.i0, that.i0));\n            }\n        }\n      }\n    case OP_SUCCESS:\n      {\n        switch (that._tag) {\n          case OP_SUCCESS:\n            {\n              return exitSucceed(onSuccess(self.i0, that.i0));\n            }\n          case OP_FAILURE:\n            {\n              return exitFailCause(that.i0);\n            }\n        }\n      }\n  }\n});\nconst exitCollectAllInternal = (exits, combineCauses) => {\n  const list = fromIterable(exits);\n  if (!isNonEmpty(list)) {\n    return none$1();\n  }\n  return pipe(tailNonEmpty(list), reduce$1(pipe(headNonEmpty(list), exitMap(of)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {\n    onSuccess: (list, value) => pipe(list, prepend(value)),\n    onFailure: combineCauses\n  }))), exitMap(reverse), exitMap(chunk => Array.from(chunk)), some);\n};\n\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst deferredUnsafeMake = fiberId => ({\n  [DeferredTypeId]: deferredVariance,\n  state: make$1(pending([])),\n  blockingOn: fiberId,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n\n/* @internal */\nconst deferredMake = () => flatMap(fiberId, id => deferredMakeAs(id));\n\n/* @internal */\nconst deferredMakeAs = fiberId => sync(() => deferredUnsafeMake(fiberId));\n\n/* @internal */\nconst deferredAwait = self => asyncEither(k => {\n  const state = get(self.state);\n  switch (state._tag) {\n    case OP_STATE_DONE:\n      {\n        return right(state.effect);\n      }\n    case OP_STATE_PENDING:\n      {\n        pipe(self.state, set(pending([k, ...state.joiners])));\n        return left(deferredInterruptJoiner(self, k));\n      }\n  }\n}, self.blockingOn);\n\n/* @internal */\nconst deferredComplete = /*#__PURE__*/dual(2, (self, effect) => intoDeferred(effect, self));\n\n/* @internal */\nconst deferredCompleteWith = /*#__PURE__*/dual(2, (self, effect) => sync(() => {\n  const state = get(self.state);\n  switch (state._tag) {\n    case OP_STATE_DONE:\n      {\n        return false;\n      }\n    case OP_STATE_PENDING:\n      {\n        pipe(self.state, set(done(effect)));\n        for (let i = 0; i < state.joiners.length; i++) {\n          state.joiners[i](effect);\n        }\n        return true;\n      }\n  }\n}));\n\n/* @internal */\nconst deferredDone = /*#__PURE__*/dual(2, (self, exit) => deferredCompleteWith(self, exit));\n\n/* @internal */\nconst deferredFail = /*#__PURE__*/dual(2, (self, error) => deferredCompleteWith(self, fail(error)));\n\n/* @internal */\nconst deferredFailSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)));\n\n/* @internal */\nconst deferredFailCause = /*#__PURE__*/dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));\n\n/* @internal */\nconst deferredFailCauseSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)));\n\n/* @internal */\nconst deferredDie = /*#__PURE__*/dual(2, (self, defect) => deferredCompleteWith(self, die(defect)));\n\n/* @internal */\nconst deferredDieSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)));\n\n/* @internal */\nconst deferredInterrupt = self => flatMap(fiberId, fiberId => deferredCompleteWith(self, interruptWith(fiberId)));\n\n/* @internal */\nconst deferredInterruptWith = /*#__PURE__*/dual(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)));\n\n/* @internal */\nconst deferredIsDone = self => sync(() => get(self.state)._tag === OP_STATE_DONE);\n\n/* @internal */\nconst deferredPoll = self => sync(() => {\n  const state = get(self.state);\n  switch (state._tag) {\n    case OP_STATE_DONE:\n      {\n        return some(state.effect);\n      }\n    case OP_STATE_PENDING:\n      {\n        return none$1();\n      }\n  }\n});\n\n/* @internal */\nconst deferredSucceed = /*#__PURE__*/dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));\n\n/* @internal */\nconst deferredSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)));\n\n/** @internal */\nconst deferredUnsafeDone = (self, effect) => {\n  const state = get(self.state);\n  if (state._tag === OP_STATE_PENDING) {\n    pipe(self.state, set(done(effect)));\n    for (let i = state.joiners.length - 1; i >= 0; i--) {\n      state.joiners[i](effect);\n    }\n  }\n};\nconst deferredInterruptJoiner = (self, joiner) => sync(() => {\n  const state = get(self.state);\n  if (state._tag === OP_STATE_PENDING) {\n    pipe(self.state, set(pending(state.joiners.filter(j => j !== joiner))));\n  }\n});\n\nexport { CloseableScopeTypeId, EffectErrorTypeId, EffectTypeId, FiberRefTypeId, RequestResolverImpl, RequestResolverTypeId, RevertFlags, ScopeTypeId, acquireUseRelease, allLogLevels, as, asUnit, async, asyncEither, attemptOrElse, blocked, catchAll, catchAllCause, catchIf, catchSome, checkInterruptible, context, contextWithEffect, currentConcurrency, currentContext, currentForkScopeOverride, currentInterruptedCause, currentLogAnnotations, currentLogLevel, currentLogSpan, currentMaxOpsBeforeYield, currentMetricLabels, currentRequestBatching, currentSchedulingPriority, currentTracerSpan, currentTracerSpanAnnotations, currentTracerSpanLinks, currentTracerTimingEnabled, currentUnhandledErrorLogLevel, deferredAwait, deferredComplete, deferredCompleteWith, deferredDie, deferredDieSync, deferredDone, deferredFail, deferredFailCause, deferredFailCauseSync, deferredFailSync, deferredInterrupt, deferredInterruptWith, deferredIsDone, deferredMake, deferredMakeAs, deferredPoll, deferredSucceed, deferredSync, deferredUnsafeDone, deferredUnsafeMake, die, dieMessage, dieSync, either, exit, exitAs, exitAsUnit, exitCauseOption, exitCollectAll, exitDie, exitExists, exitFail, exitFailCause, exitFlatMap, exitFlatMapEffect, exitFlatten, exitForEachEffect, exitFromEither, exitFromOption, exitGetOrElse, exitInterrupt, exitIsExit, exitIsFailure, exitIsInterrupted, exitIsSuccess, exitMap, exitMapBoth, exitMapError, exitMapErrorCause, exitMatch, exitMatchEffect, exitSucceed, exitUnit, exitZip, exitZipLeft, exitZipPar, exitZipParLeft, exitZipParRight, exitZipRight, exitZipWith, fail, failCause, failCauseSync, failSync, fiberId, fiberIdWith, fiberRefDelete, fiberRefGet, fiberRefGetAndSet, fiberRefGetAndUpdate, fiberRefGetAndUpdateSome, fiberRefGetWith, fiberRefLocally, fiberRefLocallyWith, fiberRefModify, fiberRefModifySome, fiberRefReset, fiberRefSet, fiberRefUnsafeMake, fiberRefUnsafeMakeContext, fiberRefUnsafeMakeHashSet, fiberRefUnsafeMakePatch, fiberRefUnsafeMakeRuntimeFlags, fiberRefUpdate, fiberRefUpdateAndGet, fiberRefUpdateSome, fiberRefUpdateSomeAndGet, flatMap, flatMapStep, flatten, flip, forEachSequential, forEachSequentialDiscard, if_, interrupt, interruptAsFiber, interruptFiber, interruptWith, interruptible, interruptibleMask, intoDeferred, isEffect, isEffectError, isRequestResolver, logLevelAll, logLevelDebug, logLevelError, logLevelFatal, logLevelInfo, logLevelNone, logLevelTrace, logLevelWarning, makeEffectError, map, mapBoth, mapError, mapInputContext, matchCause, matchCauseEffect, matchEffect, metricLabels, never, onError, onExit, onInterrupt, orDie, orDieWith, orElse, originalInstance, partitionMap, provideContext, provideSomeContext, releaseMapAdd, releaseMapAddIfOpen, releaseMapMake, releaseMapRelease, requestBlockLocally, resolverLocally, runRequestBlock, runtimeFlags, scopeAddFinalizer, scopeAddFinalizerExit, scopeClose, scopeFork, step, succeed, suspend, sync, tap, transplant, unified, uninterruptible, uninterruptibleMask, unit, updateRuntimeFlags, whenEffect, whileLoop, withConcurrency, withFiberRuntime, withMaxOpsBeforeYield, withRequestBatching, withRuntimeFlags, withSchedulingPriority, withTracerTiming, withUnhandledErrorLogLevel, yieldNow, zip, zipLeft, zipRight, zipWith };\n","import { symbol as symbol$1 } from '../../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, structure } from '../../Hash/dist/effect-Hash.esm.js';\nimport { toString, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { some, none } from '../../Option/dist/effect-Option.esm.js';\nimport { make as make$1, between as between$1, mapInput, min as min$1, max as max$1, clamp as clamp$1 } from '../../Order/dist/effect-Order.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isNumber, isBigInt } from '../../Predicate/dist/effect-Predicate.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Duration\");\nconst bigint1e3 = /*#__PURE__*/BigInt(1_000);\nconst bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\nconst DURATION_REGEX = /^(-?\\d+(?:\\.\\d+)?)\\s+(nanos|micros|millis|seconds|minutes|hours|days|weeks)$/;\n\n/**\n * @since 2.0.0\n */\nconst decode = input => {\n  if (isDuration(input)) {\n    return input;\n  } else if (isNumber(input)) {\n    return millis(input);\n  } else if (isBigInt(input)) {\n    return nanos(input);\n  } else {\n    DURATION_REGEX.lastIndex = 0; // Reset the lastIndex before each use\n    const match = DURATION_REGEX.exec(input);\n    if (match) {\n      const [_, valueStr, unit] = match;\n      const value = Number(valueStr);\n      switch (unit) {\n        case \"nanos\":\n          return nanos(BigInt(valueStr));\n        case \"micros\":\n          return micros(BigInt(valueStr));\n        case \"millis\":\n          return millis(value);\n        case \"seconds\":\n          return seconds(value);\n        case \"minutes\":\n          return minutes(value);\n        case \"hours\":\n          return hours(value);\n        case \"days\":\n          return days(value);\n        case \"weeks\":\n          return weeks(value);\n      }\n    }\n  }\n  throw new Error(\"Invalid duration input\");\n};\nconst zeroValue = {\n  _tag: \"Millis\",\n  millis: 0\n};\nconst infinityValue = {\n  _tag: \"Infinity\"\n};\nconst DurationProto = {\n  [TypeId]: TypeId,\n  [symbol]() {\n    return structure(this.value);\n  },\n  [symbol$1](that) {\n    return isDuration(that) && equals(this, that);\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    switch (this.value._tag) {\n      case \"Millis\":\n        return {\n          _id: \"Duration\",\n          _tag: \"Millis\",\n          millis: this.value.millis\n        };\n      case \"Nanos\":\n        return {\n          _id: \"Duration\",\n          _tag: \"Nanos\",\n          hrtime: toHrTime(this)\n        };\n      case \"Infinity\":\n        return {\n          _id: \"Duration\",\n          _tag: \"Infinity\"\n        };\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst make = input => {\n  const duration = Object.create(DurationProto);\n  if (isNumber(input)) {\n    if (isNaN(input) || input < 0) {\n      duration.value = zeroValue;\n    } else if (!Number.isFinite(input)) {\n      duration.value = infinityValue;\n    } else if (!Number.isInteger(input)) {\n      duration.value = {\n        _tag: \"Nanos\",\n        nanos: BigInt(Math.round(input * 1_000_000))\n      };\n    } else {\n      duration.value = {\n        _tag: \"Millis\",\n        millis: input\n      };\n    }\n  } else if (input < BigInt(0)) {\n    duration.value = zeroValue;\n  } else {\n    duration.value = {\n      _tag: \"Nanos\",\n      nanos: input\n    };\n  }\n  return duration;\n};\n\n/**\n * @since 2.0.0\n * @category guards\n */\nconst isDuration = u => typeof u === \"object\" && u !== null && TypeId in u;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst zero = /*#__PURE__*/make(0);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst infinity = /*#__PURE__*/make(Infinity);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst nanos = nanos => make(nanos);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst micros = micros => make(micros * bigint1e3);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst millis = millis => make(millis);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst seconds = seconds => make(seconds * 1000);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst minutes = minutes => make(minutes * 60_000);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst hours = hours => make(hours * 3_600_000);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst days = days => make(days * 86_400_000);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst weeks = weeks => make(weeks * 604_800_000);\n\n/**\n * @since 2.0.0\n * @category getters\n */\nconst toMillis = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return Infinity;\n    case \"Nanos\":\n      return Number(_self.value.nanos) / 1_000_000;\n    case \"Millis\":\n      return _self.value.millis;\n  }\n};\n\n/**\n * @since 2.0.0\n * @category getters\n */\nconst toSeconds = self => toMillis(self) / 1_000;\n\n/**\n * Get the duration in nanoseconds as a bigint.\n *\n * If the duration is infinite, returns `Option.none()`\n *\n * @since 2.0.0\n * @category getters\n */\nconst toNanos = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return none();\n    case \"Nanos\":\n      return some(_self.value.nanos);\n    case \"Millis\":\n      return some(BigInt(Math.round(_self.value.millis * 1_000_000)));\n  }\n};\n\n/**\n * Get the duration in nanoseconds as a bigint.\n *\n * If the duration is infinite, it throws an error.\n *\n * @since 2.0.0\n * @category getters\n */\nconst unsafeToNanos = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      throw new Error(\"Cannot convert infinite duration to nanos\");\n    case \"Nanos\":\n      return _self.value.nanos;\n    case \"Millis\":\n      return BigInt(Math.round(_self.value.millis * 1_000_000));\n  }\n};\n\n/**\n * @since 2.0.0\n * @category getters\n */\nconst toHrTime = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return [Infinity, 0];\n    case \"Nanos\":\n      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];\n    case \"Millis\":\n      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1_000_000)];\n  }\n};\n\n/**\n * @since 2.0.0\n * @category pattern matching\n */\nconst match = /*#__PURE__*/dual(2, (self, options) => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Nanos\":\n      return options.onNanos(_self.value.nanos);\n    case \"Infinity\":\n      return options.onMillis(Infinity);\n    case \"Millis\":\n      return options.onMillis(_self.value.millis);\n  }\n});\n\n/**\n * @since 2.0.0\n * @category pattern matching\n */\nconst matchWith = /*#__PURE__*/dual(3, (self, that, options) => {\n  const _self = decode(self);\n  const _that = decode(that);\n  if (_self.value._tag === \"Infinity\" || _that.value._tag === \"Infinity\") {\n    return options.onMillis(toMillis(_self), toMillis(_that));\n  } else if (_self.value._tag === \"Nanos\" || _that.value._tag === \"Nanos\") {\n    const selfNanos = _self.value._tag === \"Nanos\" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1_000_000));\n    const thatNanos = _that.value._tag === \"Nanos\" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1_000_000));\n    return options.onNanos(selfNanos, thatNanos);\n  }\n  return options.onMillis(_self.value.millis, _that.value.millis);\n});\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Order = /*#__PURE__*/make$1((self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,\n  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0\n}));\n\n/**\n * Checks if a `Duration` is between a `minimum` and `maximum` value.\n *\n * @category predicates\n * @since 2.0.0\n */\nconst between = /*#__PURE__*/between$1( /*#__PURE__*/mapInput(Order, decode));\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Equivalence = (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self === that,\n  onNanos: (self, that) => self === that\n});\nconst _min = /*#__PURE__*/min$1(Order);\n\n/**\n * @since 2.0.0\n */\nconst min = /*#__PURE__*/dual(2, (self, that) => _min(decode(self), decode(that)));\nconst _max = /*#__PURE__*/max$1(Order);\n\n/**\n * @since 2.0.0\n */\nconst max = /*#__PURE__*/dual(2, (self, that) => _max(decode(self), decode(that)));\nconst _clamp = /*#__PURE__*/clamp$1(Order);\n\n/**\n * @since 2.0.0\n */\nconst clamp = /*#__PURE__*/dual(3, (self, minimum, maximum) => _clamp(decode(self), decode(minimum), decode(maximum)));\n\n/**\n * @since 2.0.0\n * @category math\n */\nconst times = /*#__PURE__*/dual(2, (self, times) => match(self, {\n  onMillis: millis => make(millis * times),\n  onNanos: nanos => make(nanos * BigInt(times))\n}));\n\n/**\n * @since 2.0.0\n * @category math\n */\nconst sum = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => make(self + that),\n  onNanos: (self, that) => make(self + that)\n}));\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nconst lessThan = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self < that,\n  onNanos: (self, that) => self < that\n}));\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nconst lessThanOrEqualTo = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self <= that,\n  onNanos: (self, that) => self <= that\n}));\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nconst greaterThan = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self > that,\n  onNanos: (self, that) => self > that\n}));\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nconst greaterThanOrEqualTo = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self >= that,\n  onNanos: (self, that) => self >= that\n}));\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nconst equals = /*#__PURE__*/dual(2, (self, that) => Equivalence(decode(self), decode(that)));\n\nexport { Equivalence, Order, between, clamp, days, decode, equals, greaterThan, greaterThanOrEqualTo, hours, infinity, isDuration, lessThan, lessThanOrEqualTo, match, matchWith, max, micros, millis, min, minutes, nanos, seconds, sum, times, toHrTime, toMillis, toNanos, toSeconds, unsafeToNanos, weeks, zero };\n","/**\n * Bun currently has a bug where `setTimeout` doesn't behave correctly with a 0ms delay.\n *\n * @see https://github.com/oven-sh/bun/issues/3333\n */\n\n/** @internal */\nconst isBun = typeof process === \"undefined\" ? false : !!process?.isBun;\n\n/** @internal */\nconst clear = isBun ? id => clearInterval(id) : id => clearTimeout(id);\n\n/** @internal */\nconst set = isBun ? (fn, ms) => {\n  const id = setInterval(() => {\n    fn();\n    clearInterval(id);\n  }, ms);\n  return id;\n} : (fn, ms) => setTimeout(fn, ms);\n\nexport { clear, set };\n","import { Tag } from '../Context/dist/effect-Context.esm.js';\nimport { toMillis } from '../Duration/dist/effect-Duration.esm.js';\nimport { left } from '../Either/dist/effect-Either.esm.js';\nimport { constFalse } from '../Function/dist/effect-Function.esm.js';\nimport { sync, succeed, asyncEither, unit, asUnit } from './core.esm.js';\nimport { set, clear } from './timeout.esm.js';\n\n/** @internal */\nconst ClockSymbolKey = \"effect/Clock\";\n\n/** @internal */\nconst ClockTypeId = /*#__PURE__*/Symbol.for(ClockSymbolKey);\n\n/** @internal */\nconst clockTag = /*#__PURE__*/Tag(ClockTypeId);\n\n/** @internal */\nconst MAX_TIMER_MILLIS = 2 ** 31 - 1;\n\n/** @internal */\nconst globalClockScheduler = {\n  unsafeSchedule(task, duration) {\n    const millis = toMillis(duration);\n    // If the duration is greater than the value allowable by the JS timer\n    // functions, treat the value as an infinite duration\n    if (millis > MAX_TIMER_MILLIS) {\n      return constFalse;\n    }\n    let completed = false;\n    const handle = set(() => {\n      completed = true;\n      task();\n    }, millis);\n    return () => {\n      clear(handle);\n      return !completed;\n    };\n  }\n};\nconst performanceNowNanos = /*#__PURE__*/function () {\n  const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);\n  if (typeof performance === \"undefined\") {\n    return () => BigInt(Date.now()) * bigint1e6;\n  }\n  const origin = \"timeOrigin\" in performance && typeof performance.timeOrigin === \"number\" ? /*#__PURE__*/BigInt( /*#__PURE__*/Math.round(performance.timeOrigin * 1_000_000)) : /*#__PURE__*/BigInt( /*#__PURE__*/Date.now()) * bigint1e6;\n  return () => origin + BigInt(Math.round(performance.now() * 1_000_000));\n}();\nconst processOrPerformanceNow = /*#__PURE__*/function () {\n  const processHrtime = typeof process === \"object\" && \"hrtime\" in process && typeof process.hrtime.bigint === \"function\" ? process.hrtime : undefined;\n  if (!processHrtime) {\n    return performanceNowNanos;\n  }\n  const origin = /*#__PURE__*/performanceNowNanos() - /*#__PURE__*/processHrtime.bigint();\n  return () => origin + processHrtime.bigint();\n}();\n\n/** @internal */\nclass ClockImpl {\n  [ClockTypeId] = ClockTypeId;\n  unsafeCurrentTimeMillis() {\n    return Date.now();\n  }\n  unsafeCurrentTimeNanos() {\n    return processOrPerformanceNow();\n  }\n  currentTimeMillis = sync(() => this.unsafeCurrentTimeMillis());\n  currentTimeNanos = sync(() => this.unsafeCurrentTimeNanos());\n  scheduler() {\n    return succeed(globalClockScheduler);\n  }\n  sleep(duration) {\n    return asyncEither(cb => {\n      const canceler = globalClockScheduler.unsafeSchedule(() => cb(unit), duration);\n      return left(asUnit(sync(canceler)));\n    });\n  }\n}\n\n/** @internal */\nconst make = () => new ClockImpl();\n\nexport { ClockTypeId, MAX_TIMER_MILLIS, clockTag, globalClockScheduler, make };\n","/** @internal */\n\n/** @internal */\nconst OP_AND = \"And\";\n\n/** @internal */\n\n/** @internal */\nconst OP_OR = \"Or\";\n\n/** @internal */\n\n/** @internal */\nconst OP_INVALID_DATA = \"InvalidData\";\n\n/** @internal */\n\n/** @internal */\nconst OP_MISSING_DATA = \"MissingData\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SOURCE_UNAVAILABLE = \"SourceUnavailable\";\n\n/** @internal */\n\n/** @internal */\nconst OP_UNSUPPORTED = \"Unsupported\";\n\nexport { OP_AND, OP_INVALID_DATA, OP_MISSING_DATA, OP_OR, OP_SOURCE_UNAVAILABLE, OP_UNSUPPORTED };\n","import { right, left } from '../Either/dist/effect-Either.esm.js';\nimport { pipe, dual, constFalse, constTrue } from '../Function/dist/effect-Function.esm.js';\nimport { OP_AND, OP_OR, OP_INVALID_DATA, OP_MISSING_DATA, OP_SOURCE_UNAVAILABLE, OP_UNSUPPORTED } from './opCodes/configError.esm.js';\nimport { join } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nconst ConfigErrorSymbolKey = \"effect/ConfigError\";\n\n/** @internal */\nconst ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);\n\n/** @internal */\nconst proto = {\n  [ConfigErrorTypeId]: ConfigErrorTypeId\n};\n\n/** @internal */\nconst And = (self, that) => {\n  const error = Object.create(proto);\n  error._tag = OP_AND;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} and ${this.right}`;\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst Or = (self, that) => {\n  const error = Object.create(proto);\n  error._tag = OP_OR;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} or ${this.right}`;\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst InvalidData = (path, message, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._tag = OP_INVALID_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, join(options.pathDelim));\n      return `(Invalid data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst MissingData = (path, message, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._tag = OP_MISSING_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, join(options.pathDelim));\n      return `(Missing data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst SourceUnavailable = (path, message, cause, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._tag = OP_SOURCE_UNAVAILABLE;\n  error.path = path;\n  error.message = message;\n  error.cause = cause;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, join(options.pathDelim));\n      return `(Source unavailable at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst Unsupported = (path, message, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._tag = OP_UNSUPPORTED;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, join(options.pathDelim));\n      return `(Unsupported operation at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst isConfigError = u => typeof u === \"object\" && u != null && ConfigErrorTypeId in u;\n\n/** @internal */\nconst isAnd = self => self._tag === OP_AND;\n\n/** @internal */\nconst isOr = self => self._tag === OP_OR;\n\n/** @internal */\nconst isInvalidData = self => self._tag === OP_INVALID_DATA;\n\n/** @internal */\nconst isMissingData = self => self._tag === OP_MISSING_DATA;\n\n/** @internal */\nconst isSourceUnavailable = self => self._tag === OP_SOURCE_UNAVAILABLE;\n\n/** @internal */\nconst isUnsupported = self => self._tag === OP_UNSUPPORTED;\n\n/** @internal */\nconst prefixed = /*#__PURE__*/dual(2, (self, prefix) => {\n  switch (self._tag) {\n    case OP_AND:\n      {\n        return And(prefixed(prefix)(self.left), prefixed(prefix)(self.right));\n      }\n    case OP_OR:\n      {\n        return Or(prefixed(prefix)(self.left), prefixed(prefix)(self.right));\n      }\n    case OP_INVALID_DATA:\n      {\n        return InvalidData([...prefix, ...self.path], self.message);\n      }\n    case OP_MISSING_DATA:\n      {\n        return MissingData([...prefix, ...self.path], self.message);\n      }\n    case OP_SOURCE_UNAVAILABLE:\n      {\n        return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);\n      }\n    case OP_UNSUPPORTED:\n      {\n        return Unsupported([...prefix, ...self.path], self.message);\n      }\n  }\n});\n\n/** @internal */\nconst IsMissingDataOnlyReducer = {\n  andCase: (_, left, right) => left && right,\n  orCase: (_, left, right) => left && right,\n  invalidDataCase: constFalse,\n  missingDataCase: constTrue,\n  sourceUnavailableCase: constFalse,\n  unsupportedCase: constFalse\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const error = input.pop();\n    switch (error._tag) {\n      case OP_AND:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(left({\n            _tag: \"AndCase\"\n          }));\n          break;\n        }\n      case OP_OR:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(left({\n            _tag: \"OrCase\"\n          }));\n          break;\n        }\n      case OP_INVALID_DATA:\n        {\n          output.push(right(reducer.invalidDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OP_MISSING_DATA:\n        {\n          output.push(right(reducer.missingDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OP_SOURCE_UNAVAILABLE:\n        {\n          output.push(right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));\n          break;\n        }\n      case OP_UNSUPPORTED:\n        {\n          output.push(right(reducer.unsupportedCase(context, error.path, error.message)));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case \"AndCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.andCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case \"OrCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.orCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/io/issues\");\n  }\n  return accumulator.pop();\n});\n\n/** @internal */\nconst isMissingDataOnly = self => reduceWithContext(self, void 0, IsMissingDataOnlyReducer);\n\nexport { And, ConfigErrorTypeId, InvalidData, MissingData, Or, SourceUnavailable, Unsupported, isAnd, isConfigError, isInvalidData, isMissingData, isMissingDataOnly, isOr, isSourceUnavailable, isUnsupported, prefixed, proto, reduceWithContext };\n","/** @internal */\n\n/** @internal */\nconst OP_CONSTANT = \"Constant\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FAIL = \"Fail\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FALLBACK = \"Fallback\";\n\n/** @internal */\n\n/** @internal */\nconst OP_DESCRIBED = \"Described\";\n\n/** @internal */\n\n/** @internal */\nconst OP_LAZY = \"Lazy\";\n\n/** @internal */\n\n/** @internal */\nconst OP_MAP_OR_FAIL = \"MapOrFail\";\n\n/** @internal */\n\n/** @internal */\nconst OP_NESTED = \"Nested\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PRIMITIVE = \"Primitive\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SEQUENCE = \"Sequence\";\n\n/** @internal */\n\n/** @internal */\nconst OP_HASHMAP = \"HashMap\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ZIP_WITH = \"ZipWith\";\n\nexport { OP_CONSTANT, OP_DESCRIBED, OP_FAIL, OP_FALLBACK, OP_HASHMAP, OP_LAZY, OP_MAP_OR_FAIL, OP_NESTED, OP_PRIMITIVE, OP_SEQUENCE, OP_ZIP_WITH };\n","import { toReadonlyArray, unsafeFromArray } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { isMissingDataOnly } from '../ConfigError/dist/effect-ConfigError.esm.js';\nimport { left, right } from '../Either/dist/effect-Either.esm.js';\nimport { pipe, dual, constTrue } from '../Function/dist/effect-Function.esm.js';\nimport { fromIterable } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { Unsupported, InvalidData, MissingData } from './configError.esm.js';\nimport { fromString } from './configSecret.esm.js';\nimport { allLogLevels } from './core.esm.js';\nimport { OP_FAIL, OP_MAP_OR_FAIL, OP_NESTED, OP_FALLBACK, OP_PRIMITIVE, OP_SEQUENCE, OP_CONSTANT, OP_LAZY, OP_HASHMAP, OP_DESCRIBED, OP_ZIP_WITH } from './opCodes/config.esm.js';\nimport { some, none } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst ConfigSymbolKey = \"effect/Config\";\n\n/** @internal */\nconst ConfigTypeId = /*#__PURE__*/Symbol.for(ConfigSymbolKey);\n\n/** @internal */\n\n/** @internal */\nconst configVariance = {\n  _A: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [ConfigTypeId]: configVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst boolean = name => {\n  const config = primitive(\"a boolean property\", text => {\n    switch (text) {\n      case \"true\":\n      case \"yes\":\n      case \"on\":\n      case \"1\":\n        {\n          return right(true);\n        }\n      case \"false\":\n      case \"no\":\n      case \"off\":\n      case \"0\":\n        {\n          return right(false);\n        }\n      default:\n        {\n          const error = InvalidData([], `Expected a boolean value, but received ${text}`);\n          return left(error);\n        }\n    }\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n\n/** @internal */\nconst array = (config, name) => {\n  return pipe(chunk(config, name), map(toReadonlyArray));\n};\n\n/** @internal */\nconst chunk = (config, name) => {\n  return map(name === undefined ? repeat(config) : nested(name)(repeat(config)), unsafeFromArray);\n};\n\n/** @internal */\nconst date = name => {\n  const config = primitive(\"a date property\", text => {\n    const result = Date.parse(text);\n    if (Number.isNaN(result)) {\n      return left(InvalidData([], `Expected a date value but received ${text}`));\n    }\n    return right(new Date(result));\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n\n/** @internal */\nconst fail = message => {\n  const fail = Object.create(proto);\n  fail._tag = OP_FAIL;\n  fail.message = message;\n  fail.parse = () => left(Unsupported([], message));\n  return fail;\n};\n\n/** @internal */\nconst number = name => {\n  const config = primitive(\"a number property\", text => {\n    const result = Number.parseFloat(text);\n    if (Number.isNaN(result)) {\n      return left(InvalidData([], `Expected an number value but received ${text}`));\n    }\n    return right(result);\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n\n/** @internal */\nconst integer = name => {\n  const config = primitive(\"an integer property\", text => {\n    const result = Number.parseInt(text, 10);\n    if (Number.isNaN(result)) {\n      return left(InvalidData([], `Expected an integer value but received ${text}`));\n    }\n    return right(result);\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n\n/** @internal */\nconst logLevel = name => {\n  const config = mapOrFail(string(), value => {\n    const label = value.toUpperCase();\n    const level = allLogLevels.find(level => level.label === label);\n    return level === undefined ? left(InvalidData([], `Expected a log level, but found: ${value}`)) : right(level);\n  });\n  return name === undefined ? config : nested(config, name);\n};\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => mapOrFail(self, a => right(f(a))));\n\n/** @internal */\nconst mapAttempt = /*#__PURE__*/dual(2, (self, f) => mapOrFail(self, a => {\n  try {\n    return right(f(a));\n  } catch (error) {\n    return left(InvalidData([], error instanceof Error ? error.message : `${error}`));\n  }\n}));\n\n/** @internal */\nconst mapOrFail = /*#__PURE__*/dual(2, (self, f) => {\n  const mapOrFail = Object.create(proto);\n  mapOrFail._tag = OP_MAP_OR_FAIL;\n  mapOrFail.original = self;\n  mapOrFail.mapOrFail = f;\n  return mapOrFail;\n});\n\n/** @internal */\nconst missingError = name => {\n  return self => {\n    return MissingData([], `Expected ${self.description} with name ${name}`);\n  };\n};\n\n/** @internal */\nconst nested = /*#__PURE__*/dual(2, (self, name) => {\n  const nested = Object.create(proto);\n  nested._tag = OP_NESTED;\n  nested.name = name;\n  nested.config = self;\n  return nested;\n});\n\n/** @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => {\n  const fallback = Object.create(proto);\n  fallback._tag = OP_FALLBACK;\n  fallback.first = self;\n  fallback.second = suspend(that);\n  fallback.condition = constTrue;\n  return fallback;\n});\n\n/** @internal */\nconst orElseIf = /*#__PURE__*/dual(2, (self, options) => {\n  const fallback = Object.create(proto);\n  fallback._tag = OP_FALLBACK;\n  fallback.first = self;\n  fallback.second = suspend(options.orElse);\n  fallback.condition = options.if;\n  return fallback;\n});\n\n/** @internal */\nconst option = self => {\n  return pipe(self, map(some), orElseIf({\n    orElse: () => succeed(none()),\n    if: isMissingDataOnly\n  }));\n};\n\n/** @internal */\nconst primitive = (description, parse) => {\n  const primitive = Object.create(proto);\n  primitive._tag = OP_PRIMITIVE;\n  primitive.description = description;\n  primitive.parse = parse;\n  return primitive;\n};\n\n/** @internal */\nconst repeat = self => {\n  const repeat = Object.create(proto);\n  repeat._tag = OP_SEQUENCE;\n  repeat.config = self;\n  return repeat;\n};\n\n/** @internal */\nconst secret = name => {\n  const config = primitive(\"a secret property\", text => right(fromString(text)));\n  return name === undefined ? config : nested(name)(config);\n};\n\n/** @internal */\nconst hashSet = (config, name) => {\n  const newConfig = map(chunk(config), fromIterable);\n  return name === undefined ? newConfig : nested(name)(newConfig);\n};\n\n/** @internal */\nconst string = name => {\n  const config = primitive(\"a text property\", right);\n  return name === undefined ? config : nested(name)(config);\n};\nconst all = arg => {\n  if (Array.isArray(arg)) {\n    return tuple(arg);\n  } else if (Symbol.iterator in arg) {\n    return tuple([...arg]);\n  }\n  return struct(arg);\n};\nconst struct = r => {\n  const entries = Object.entries(r);\n  let result = pipe(entries[0][1], map(value => ({\n    [entries[0][0]]: value\n  })));\n  if (entries.length === 1) {\n    return result;\n  }\n  const rest = entries.slice(1);\n  for (const [key, config] of rest) {\n    result = pipe(result, zipWith(config, (record, value) => ({\n      ...record,\n      [key]: value\n    })));\n  }\n  return result;\n};\n\n/** @internal */\nconst succeed = value => {\n  const constant = Object.create(proto);\n  constant._tag = OP_CONSTANT;\n  constant.value = value;\n  constant.parse = () => right(value);\n  return constant;\n};\n\n/** @internal */\nconst suspend = config => {\n  const lazy = Object.create(proto);\n  lazy._tag = OP_LAZY;\n  lazy.config = config;\n  return lazy;\n};\n\n/** @internal */\nconst sync = value => {\n  return suspend(() => succeed(value()));\n};\n\n/** @internal */\nconst hashMap = (config, name) => {\n  const table = Object.create(proto);\n  table._tag = OP_HASHMAP;\n  table.valueConfig = config;\n  return name === undefined ? table : nested(name)(table);\n};\n\n/** @internal */\nconst isConfig = u => typeof u === \"object\" && u != null && ConfigTypeId in u;\n\n/** @internal */\nconst tuple = tuple => {\n  if (tuple.length === 0) {\n    return succeed([]);\n  }\n  if (tuple.length === 1) {\n    return map(tuple[0], x => [x]);\n  }\n  let result = map(tuple[0], x => [x]);\n  for (let i = 1; i < tuple.length; i++) {\n    const config = tuple[i];\n    result = pipe(result, zipWith(config, (tuple, value) => [...tuple, value]));\n  }\n  return result;\n};\n\n/**\n * @internal\n */\nconst unwrap = wrapped => {\n  if (isConfig(wrapped)) {\n    return wrapped;\n  }\n  return struct(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap(a)])));\n};\n\n/** @internal */\nconst validate = /*#__PURE__*/dual(2, (self, {\n  message,\n  validation\n}) => mapOrFail(self, a => {\n  if (validation(a)) {\n    return right(a);\n  }\n  return left(InvalidData([], message));\n}));\n\n/** @internal */\nconst withDefault = /*#__PURE__*/dual(2, (self, def) => orElseIf(self, {\n  orElse: () => succeed(def),\n  if: isMissingDataOnly\n}));\n\n/** @internal */\nconst withDescription = /*#__PURE__*/dual(2, (self, description) => {\n  const described = Object.create(proto);\n  described._tag = OP_DESCRIBED;\n  described.config = self;\n  described.description = description;\n  return described;\n});\n\n/** @internal */\nconst zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n\n/** @internal */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OP_ZIP_WITH;\n  zipWith.left = self;\n  zipWith.right = that;\n  zipWith.zip = f;\n  return zipWith;\n});\n\nexport { ConfigTypeId, all, array, boolean, chunk, date, fail, hashMap, hashSet, integer, isConfig, logLevel, map, mapAttempt, mapOrFail, missingError, nested, number, option, orElse, orElseIf, primitive, repeat, secret, string, succeed, suspend, sync, unwrap, validate, withDefault, withDescription, zip, zipWith };\n","import { left, right } from '../../Either/dist/effect-Either.esm.js';\nimport { dual, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { MissingData } from '../configError.esm.js';\nimport { of, isCons, cons } from '../../List/dist/effect-List.esm.js';\nimport { contains } from '../../Option/dist/effect-Option.esm.js';\nimport { head, tailNonEmpty, prepend, map } from '../../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nconst empty = {\n  _tag: \"Empty\"\n};\n\n/** @internal */\nconst andThen = /*#__PURE__*/dual(2, (self, that) => ({\n  _tag: \"AndThen\",\n  first: self,\n  second: that\n}));\n\n/** @internal */\nconst mapName = /*#__PURE__*/dual(2, (self, f) => andThen(self, {\n  _tag: \"MapName\",\n  f\n}));\n\n/** @internal */\nconst nested = /*#__PURE__*/dual(2, (self, name) => andThen(self, {\n  _tag: \"Nested\",\n  name\n}));\n\n/** @internal */\nconst unnested = /*#__PURE__*/dual(2, (self, name) => andThen(self, {\n  _tag: \"Unnested\",\n  name\n}));\n\n/** @internal */\nconst patch = /*#__PURE__*/dual(2, (path, patch) => {\n  let input = of(patch);\n  let output = path;\n  while (isCons(input)) {\n    const patch = input.head;\n    switch (patch._tag) {\n      case \"Empty\":\n        {\n          input = input.tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          input = cons(patch.first, cons(patch.second, input.tail));\n          break;\n        }\n      case \"MapName\":\n        {\n          output = map(output, patch.f);\n          input = input.tail;\n          break;\n        }\n      case \"Nested\":\n        {\n          output = prepend(output, patch.name);\n          input = input.tail;\n          break;\n        }\n      case \"Unnested\":\n        {\n          const containsName = pipe(head(output), contains(patch.name));\n          if (containsName) {\n            output = tailNonEmpty(output);\n            input = input.tail;\n          } else {\n            return left(MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));\n          }\n          break;\n        }\n    }\n  }\n  return right(output);\n});\n\nexport { andThen, empty, mapName, nested, patch, unnested };\n","import { Tag } from '../Context/dist/effect-Context.esm.js';\nimport { isLeft, isRight, merge, right, left } from '../Either/dist/effect-Either.esm.js';\nimport { pipe, dual } from '../Function/dist/effect-Function.esm.js';\nimport { empty as empty$2, fromIterable as fromIterable$1 } from '../HashMap/dist/effect-HashMap.esm.js';\nimport { union, fromIterable } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { missingError } from './config.esm.js';\nimport { MissingData, Or, And, prefixed } from './configError.esm.js';\nimport { empty as empty$1, patch, mapName, nested as nested$1, unnested as unnested$1 } from './configProvider/pathPatch.esm.js';\nimport { flatMap, fail, succeed, suspend, forEachSequential, map, catchAll, sync, either, mapBoth, mapError, zip as zip$1 } from './core.esm.js';\nimport { OP_ZIP_WITH, OP_HASHMAP, OP_SEQUENCE, OP_PRIMITIVE, OP_NESTED, OP_MAP_OR_FAIL, OP_LAZY, OP_FALLBACK, OP_FAIL, OP_DESCRIBED, OP_CONSTANT } from './opCodes/config.esm.js';\nimport { constantCase as constantCase$1, kebabCase as kebabCase$1, lowerCase as lowerCase$1, snakeCase as snakeCase$1, upperCase as upperCase$1 } from './string-utils.esm.js';\nimport { Order } from '../Number/dist/effect-Number.esm.js';\nimport { match, getOrElse, flatMap as flatMap$1, some, none, all } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { head, empty, append, flatten, of, last, reduce, reduceRight, sort, flatMap as flatMap$2, make as make$1, unsafeGet, join, map as map$1, zip, fromIterable as fromIterable$2, unfold } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\nconst concat = (l, r) => [...l, ...r];\n\n/** @internal */\nconst ConfigProviderSymbolKey = \"effect/ConfigProvider\";\n\n/** @internal */\nconst ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);\n\n/** @internal */\nconst configProviderTag = /*#__PURE__*/Tag(ConfigProviderTypeId);\n\n/** @internal */\nconst FlatConfigProviderSymbolKey = \"effect/ConfigProviderFlat\";\n\n/** @internal */\nconst FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);\n\n/** @internal */\nconst make = options => ({\n  [ConfigProviderTypeId]: ConfigProviderTypeId,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  ...options\n});\n\n/** @internal */\nconst makeFlat = options => ({\n  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,\n  patch: options.patch,\n  load: (path, config, split = true) => options.load(path, config, split),\n  enumerateChildren: options.enumerateChildren\n});\n\n/** @internal */\nconst fromFlat = flat => make({\n  load: config => flatMap(fromFlatLoop(flat, empty(), config, false), chunk => match(head(chunk), {\n    onNone: () => fail(MissingData(empty(), `Expected a single value having structure: ${config}`)),\n    onSome: succeed\n  })),\n  flattened: flat\n});\n\n/** @internal */\nconst fromEnv = (config = {}) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({}, {\n    pathDelim: \"_\",\n    seqDelim: \",\"\n  }, config);\n  const makePathString = path => pipe(path, join(pathDelim));\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const getEnv = () => typeof process !== \"undefined\" && \"env\" in process && typeof process.env === \"object\" ? process.env : {};\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const current = getEnv();\n    const valueOpt = pathString in current ? some(current[pathString]) : none();\n    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));\n  };\n  const enumerateChildren = path => sync(() => {\n    const current = getEnv();\n    const keys = Object.keys(current);\n    const keyPaths = Array.from(keys).map(value => unmakePathString(value.toUpperCase()));\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = pipe(path, unsafeGet(i));\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat({\n    load,\n    enumerateChildren,\n    patch: empty$1\n  }));\n};\n\n/** @internal */\nconst fromMap = (map, config = {}) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({\n    seqDelim: \",\",\n    pathDelim: \".\"\n  }, config);\n  const makePathString = path => pipe(path, join(pathDelim));\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const mapWithIndexSplit = splitIndexInKeys(map, str => Array.from(unmakePathString(str)), makePathString);\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const valueOpt = mapWithIndexSplit.has(pathString) ? some(mapWithIndexSplit.get(pathString)) : none();\n    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the provided map`)), flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));\n  };\n  const enumerateChildren = path => sync(() => {\n    const keyPaths = Array.from(mapWithIndexSplit.keys()).map(unmakePathString);\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = pipe(path, unsafeGet(i));\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat({\n    load,\n    enumerateChildren,\n    patch: empty$1\n  }));\n};\nconst extend = (leftDef, rightDef, left, right) => {\n  const leftPad = unfold(left.length, index => index >= right.length ? none() : some([leftDef(index), index + 1]));\n  const rightPad = unfold(right.length, index => index >= left.length ? none() : some([rightDef(index), index + 1]));\n  const leftExtension = concat(left, leftPad);\n  const rightExtension = concat(right, rightPad);\n  return [leftExtension, rightExtension];\n};\nconst fromFlatLoop = (flat, prefix, config, split) => {\n  const op = config;\n  switch (op._tag) {\n    case OP_CONSTANT:\n      {\n        return succeed(of(op.value));\n      }\n    case OP_DESCRIBED:\n      {\n        return suspend(() => fromFlatLoop(flat, prefix, op.config, split));\n      }\n    case OP_FAIL:\n      {\n        return fail(MissingData(prefix, op.message));\n      }\n    case OP_FALLBACK:\n      {\n        return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll(error1 => {\n          if (op.condition(error1)) {\n            return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll(error2 => fail(Or(error1, error2))));\n          }\n          return fail(error1);\n        }));\n      }\n    case OP_LAZY:\n      {\n        return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));\n      }\n    case OP_MAP_OR_FAIL:\n      {\n        return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap(forEachSequential(a => pipe(op.mapOrFail(a), mapError(prefixed(prefix)))))));\n      }\n    case OP_NESTED:\n      {\n        return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));\n      }\n    case OP_PRIMITIVE:\n      {\n        return pipe(patch(prefix, flat.patch), flatMap(prefix => pipe(flat.load(prefix, op, split), flatMap(values => {\n          if (values.length === 0) {\n            const name = pipe(last(prefix), getOrElse(() => \"<n/a>\"));\n            return fail(missingError(name));\n          }\n          return succeed(values);\n        }))));\n      }\n    case OP_SEQUENCE:\n      {\n        return pipe(patch(prefix, flat.patch), flatMap(patchedPrefix => pipe(flat.enumerateChildren(patchedPrefix), flatMap(indicesFrom), flatMap(indices => {\n          if (indices.length === 0) {\n            return suspend(() => map(fromFlatLoop(flat, patchedPrefix, op.config, true), of));\n          }\n          return pipe(forEachSequential(indices, index => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map(chunkChunk => {\n            const flattened = flatten(chunkChunk);\n            if (flattened.length === 0) {\n              return of(empty());\n            }\n            return of(flattened);\n          }));\n        }))));\n      }\n    case OP_HASHMAP:\n      {\n        return suspend(() => pipe(patch(prefix, flat.patch), flatMap(prefix => pipe(flat.enumerateChildren(prefix), flatMap(keys => {\n          return pipe(keys, forEachSequential(key => fromFlatLoop(flat, concat(prefix, of(key)), op.valueConfig, split)), map(values => {\n            if (values.length === 0) {\n              return of(empty$2());\n            }\n            const matrix = values.map(x => Array.from(x));\n            return pipe(transpose(matrix), map$1(values => fromIterable$1(zip(fromIterable$2(keys), values))));\n          }));\n        })))));\n      }\n    case OP_ZIP_WITH:\n      {\n        return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either, flatMap(left => pipe(fromFlatLoop(flat, prefix, op.right, split), either, flatMap(right$1 => {\n          if (isLeft(left) && isLeft(right$1)) {\n            return fail(And(left.left, right$1.left));\n          }\n          if (isLeft(left) && isRight(right$1)) {\n            return fail(left.left);\n          }\n          if (isRight(left) && isLeft(right$1)) {\n            return fail(right$1.left);\n          }\n          if (isRight(left) && isRight(right$1)) {\n            const path = pipe(prefix, join(\".\"));\n            const fail = fromFlatLoopFail(prefix, path);\n            const [lefts, rights] = extend(fail, fail, pipe(left.right, map$1(right)), pipe(right$1.right, map$1(right)));\n            return pipe(lefts, zip(rights), forEachSequential(([left, right]) => pipe(zip$1(left, right), map(([left, right]) => op.zip(left, right)))));\n          }\n          throw new Error(\"BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n        })))));\n      }\n  }\n};\nconst fromFlatLoopFail = (prefix, path) => index => left(MissingData(prefix, `The element at index ${index} in a sequence at path \"${path}\" was missing`));\n\n/** @internal */\nconst mapInputPath = /*#__PURE__*/dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));\nconst mapInputPathFlat = (self, f) => makeFlat({\n  load: (path, config, split = true) => self.load(path, config, split),\n  enumerateChildren: path => self.enumerateChildren(path),\n  patch: mapName(self.patch, f)\n});\n\n/** @internal */\nconst nested = /*#__PURE__*/dual(2, (self, name) => fromFlat(makeFlat({\n  load: (path, config) => self.flattened.load(path, config, true),\n  enumerateChildren: path => self.flattened.enumerateChildren(path),\n  patch: nested$1(self.flattened.patch, name)\n})));\n\n/** @internal */\nconst unnested = /*#__PURE__*/dual(2, (self, name) => fromFlat(makeFlat({\n  load: (path, config) => self.flattened.load(path, config, true),\n  enumerateChildren: path => self.flattened.enumerateChildren(path),\n  patch: unnested$1(self.flattened.patch, name)\n})));\n\n/** @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));\nconst orElseFlat = (self, that) => makeFlat({\n  load: (path, config, split) => pipe(patch(path, self.patch), flatMap(patch => self.load(patch, config, split)), catchAll(error1 => pipe(sync(that), flatMap(that => pipe(patch(path, that.patch), flatMap(patch => that.load(patch, config, split)), catchAll(error2 => fail(Or(error1, error2)))))))),\n  enumerateChildren: path => pipe(patch(path, self.patch), flatMap(patch => self.enumerateChildren(patch)), either, flatMap(left => pipe(sync(that), flatMap(that => pipe(patch(path, that.patch), flatMap(patch => that.enumerateChildren(patch)), either, flatMap(right => {\n    if (isLeft(left) && isLeft(right)) {\n      return fail(And(left.left, right.left));\n    }\n    if (isLeft(left) && isRight(right)) {\n      return succeed(right.right);\n    }\n    if (isRight(left) && isLeft(right)) {\n      return succeed(left.right);\n    }\n    if (isRight(left) && isRight(right)) {\n      return succeed(pipe(left.right, union(right.right)));\n    }\n    throw new Error(\"BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/io/issues\");\n  })))))),\n  patch: empty$1\n});\n\n/** @internal */\nconst constantCase = self => mapInputPath(self, constantCase$1);\n\n/** @internal */\nconst kebabCase = self => mapInputPath(self, kebabCase$1);\n\n/** @internal */\nconst lowerCase = self => mapInputPath(self, lowerCase$1);\n\n/** @internal */\nconst snakeCase = self => mapInputPath(self, snakeCase$1);\n\n/** @internal */\nconst upperCase = self => mapInputPath(self, upperCase$1);\n\n/** @internal */\nconst within = /*#__PURE__*/dual(3, (self, path, f) => {\n  const unnest = reduce(path, self, (provider, name) => unnested(provider, name));\n  const nest = reduceRight(path, f(unnest), (provider, name) => nested(provider, name));\n  return orElse(nest, () => self);\n});\nconst splitPathString = (text, delim) => {\n  const split = text.split(new RegExp(`\\\\s*${escapeRegex(delim)}\\\\s*`));\n  return split;\n};\nconst parsePrimitive = (text, path, primitive, delimiter, split) => {\n  if (!split) {\n    return pipe(primitive.parse(text), map(of), mapError(prefixed(path)));\n  }\n  return pipe(splitPathString(text, delimiter), forEachSequential(char => primitive.parse(char.trim())), mapError(prefixed(path)));\n};\nconst transpose = array => {\n  return Object.keys(array[0]).map(column => array.map(row => row[column]));\n};\nconst escapeRegex = string => {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\nconst indicesFrom = quotedIndices => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({\n  onFailure: () => empty(),\n  onSuccess: sort(Order)\n}), either, map(merge));\nconst STR_INDEX_REGEX = /(^.+)(\\[(\\d+)\\])$/;\nconst QUOTED_INDEX_REGEX = /^(\\[(\\d+)\\])$/;\nconst parseQuotedIndex = str => {\n  const match = str.match(QUOTED_INDEX_REGEX);\n  if (match !== null) {\n    const matchedIndex = match[2];\n    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some(matchedIndex) : none(), flatMap$1(parseInteger));\n  }\n  return none();\n};\nconst splitIndexInKeys = (map, unmakePathString, makePathString) => {\n  const newMap = new Map();\n  for (const [pathString, value] of map) {\n    const keyWithIndex = pipe(unmakePathString(pathString), flatMap$2(key => match(splitIndexFrom(key), {\n      onNone: () => of(key),\n      onSome: ([key, index]) => make$1(key, `[${index}]`)\n    })));\n    newMap.set(makePathString(keyWithIndex), value);\n  }\n  return newMap;\n};\nconst splitIndexFrom = key => {\n  const match = key.match(STR_INDEX_REGEX);\n  if (match !== null) {\n    const matchedString = match[1];\n    const matchedIndex = match[3];\n    const optionalString = matchedString !== undefined && matchedString.length > 0 ? some(matchedString) : none();\n    const optionalIndex = pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some(matchedIndex) : none(), flatMap$1(parseInteger));\n    return all([optionalString, optionalIndex]);\n  }\n  return none();\n};\nconst parseInteger = str => {\n  const parsedIndex = Number.parseInt(str);\n  return Number.isNaN(parsedIndex) ? none() : some(parsedIndex);\n};\n\nexport { ConfigProviderTypeId, FlatConfigProviderTypeId, configProviderTag, constantCase, fromEnv, fromFlat, fromMap, kebabCase, lowerCase, make, makeFlat, mapInputPath, nested, orElse, snakeCase, unnested, upperCase, within };\n","import { Tag } from '../../Context/dist/effect-Context.esm.js';\nimport { sync } from '../core.esm.js';\n\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Console\");\n\n/** @internal */\nconst consoleTag = /*#__PURE__*/Tag(TypeId);\n\n/** @internal */\nconst defaultConsole = {\n  [TypeId]: TypeId,\n  assert(condition, ...args) {\n    return sync(() => {\n      console.assert(condition, ...args);\n    });\n  },\n  clear: /*#__PURE__*/sync(() => {\n    console.clear();\n  }),\n  count(label) {\n    return sync(() => {\n      console.count(label);\n    });\n  },\n  countReset(label) {\n    return sync(() => {\n      console.countReset(label);\n    });\n  },\n  debug(...args) {\n    return sync(() => {\n      console.debug(...args);\n    });\n  },\n  dir(item, options) {\n    return sync(() => {\n      console.dir(item, options);\n    });\n  },\n  dirxml(...args) {\n    return sync(() => {\n      console.dirxml(...args);\n    });\n  },\n  error(...args) {\n    return sync(() => {\n      console.error(...args);\n    });\n  },\n  group(options) {\n    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));\n  },\n  groupEnd: /*#__PURE__*/sync(() => {\n    console.groupEnd();\n  }),\n  info(...args) {\n    return sync(() => {\n      console.info(...args);\n    });\n  },\n  log(...args) {\n    return sync(() => {\n      console.log(...args);\n    });\n  },\n  table(tabularData, properties) {\n    return sync(() => {\n      console.table(tabularData, properties);\n    });\n  },\n  time(label) {\n    return sync(() => console.time(label));\n  },\n  timeEnd(label) {\n    return sync(() => console.timeEnd(label));\n  },\n  timeLog(label, ...args) {\n    return sync(() => {\n      console.timeLog(label, ...args);\n    });\n  },\n  trace(...args) {\n    return sync(() => {\n      console.trace(...args);\n    });\n  },\n  warn(...args) {\n    return sync(() => {\n      console.warn(...args);\n    });\n  },\n  unsafe: console\n};\n\nexport { TypeId, consoleTag, defaultConsole };\n","import { fromIterable } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { Tag } from '../Context/dist/effect-Context.esm.js';\nimport { pipe } from '../Function/dist/effect-Function.esm.js';\nimport { sync, map, suspend, flatMap, forEachSequentialDiscard, as } from './core.esm.js';\nimport { PCGRandom } from '../Utils/dist/effect-Utils.esm.js';\n\n/** @internal */\nconst RandomSymbolKey = \"effect/Random\";\n\n/** @internal */\nconst RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);\n\n/** @internal */\nconst randomTag = /*#__PURE__*/Tag(RandomTypeId);\n/** @internal */\nclass RandomImpl {\n  [RandomTypeId] = RandomTypeId;\n  constructor(seed) {\n    this.seed = seed;\n    this.PRNG = new PCGRandom(seed);\n  }\n  next() {\n    return sync(() => this.PRNG.number());\n  }\n  nextBoolean() {\n    return map(this.next(), n => n > 0.5);\n  }\n  nextInt() {\n    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));\n  }\n  nextRange(min, max) {\n    return map(this.next(), n => (max - min) * n + min);\n  }\n  nextIntBetween(min, max) {\n    return sync(() => this.PRNG.integer(max - min) + min);\n  }\n  shuffle(elements) {\n    return shuffleWith(elements, n => this.nextIntBetween(0, n + 1));\n  }\n}\nconst shuffleWith = (elements, nextIntBounded) => {\n  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap(buffer => {\n    const numbers = [];\n    for (let i = buffer.length; i >= 2; i = i - 1) {\n      numbers.push(i);\n    }\n    return pipe(numbers, forEachSequentialDiscard(n => pipe(nextIntBounded(n), map(k => swap(buffer, n - 1, k)))), as(fromIterable(buffer)));\n  })));\n};\nconst swap = (buffer, index1, index2) => {\n  const tmp = buffer[index1];\n  buffer[index1] = buffer[index2];\n  buffer[index2] = tmp;\n  return buffer;\n};\nconst make = seed => new RandomImpl(seed);\n\nexport { RandomTypeId, make, randomTag };\n","import { Tag, empty } from '../Context/dist/effect-Context.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { incrementAndGet, make as make$1 } from '../MutableRef/dist/effect-MutableRef.esm.js';\n\n/**\n * @since 2.0.0\n */\n/** @internal */\nconst TracerTypeId = /*#__PURE__*/Symbol.for(\"effect/Tracer\");\n\n/** @internal */\nconst make = options => ({\n  [TracerTypeId]: TracerTypeId,\n  ...options\n});\n\n/** @internal */\nconst tracerTag = /*#__PURE__*/Tag( /*#__PURE__*/Symbol.for(\"effect/Tracer\"));\nconst ids = /*#__PURE__*/globalValue(\"effect/Tracer/SpanId.ids\", () => make$1(0));\n\n/** @internal */\nclass NativeSpan {\n  _tag = \"Span\";\n  traceId = \"native\";\n  events = [];\n  constructor(name, parent, context, links, sampled, startTime) {\n    this.name = name;\n    this.parent = parent;\n    this.context = context;\n    this.links = links;\n    this.sampled = sampled;\n    this.startTime = startTime;\n    this.status = {\n      _tag: \"Started\",\n      startTime\n    };\n    this.attributes = new Map();\n    this.spanId = `span${incrementAndGet(ids)}`;\n  }\n  end = (endTime, exit) => {\n    this.status = {\n      _tag: \"Ended\",\n      endTime,\n      exit,\n      startTime: this.status.startTime\n    };\n  };\n  attribute = (key, value) => {\n    this.attributes.set(key, value);\n  };\n  event = (name, startTime, attributes) => {\n    this.events.push([name, startTime, attributes ?? {}]);\n  };\n}\n\n/** @internal */\nconst nativeTracer = /*#__PURE__*/make({\n  span: (name, parent, context, links, sampled, startTime) => new NativeSpan(name, parent, context, links, sampled, startTime),\n  context: f => f()\n});\n\n/** @internal */\nconst externalSpan = options => ({\n  _tag: \"ExternalSpan\",\n  spanId: options.spanId,\n  traceId: options.traceId,\n  sampled: options.sampled ?? true,\n  context: options.context ?? empty()\n});\n\nexport { NativeSpan, TracerTypeId, externalSpan, make, nativeTracer, tracerTag };\n","import { add, empty, get } from '../Context/dist/effect-Context.esm.js';\nimport { decode } from '../Duration/dist/effect-Duration.esm.js';\nimport { pipe, dual } from '../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { clockTag, make as make$1 } from './clock.esm.js';\nimport { configProviderTag, fromEnv } from './configProvider.esm.js';\nimport { fiberRefUnsafeMakeContext, fiberRefGetWith, fiberRefLocallyWith } from './core.esm.js';\nimport { consoleTag, defaultConsole } from './defaultServices/console.esm.js';\nimport { randomTag, make } from './random.esm.js';\nimport { tracerTag, nativeTracer } from './tracer.esm.js';\n\n/** @internal */\nconst liveServices = /*#__PURE__*/pipe( /*#__PURE__*/empty(), /*#__PURE__*/add(clockTag, /*#__PURE__*/make$1()), /*#__PURE__*/add(consoleTag, defaultConsole), /*#__PURE__*/add(randomTag, /*#__PURE__*/make( /*#__PURE__*/Math.random() * 4294967296 >>> 0)), /*#__PURE__*/add(configProviderTag, /*#__PURE__*/fromEnv()), /*#__PURE__*/add(tracerTag, nativeTracer));\n\n/**\n * The `FiberRef` holding the default `Effect` services.\n *\n * @since 2.0.0\n * @category fiberRefs\n */\nconst currentServices = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/DefaultServices/currentServices\"), () => fiberRefUnsafeMakeContext(liveServices));\n\n// circular with Clock\n\n/** @internal */\nconst sleep = duration => {\n  const decodedDuration = decode(duration);\n  return clockWith(clock => clock.sleep(decodedDuration));\n};\n\n/** @internal */\nconst clockWith = f => fiberRefGetWith(currentServices, services => f(get(services, clockTag)));\n\n/** @internal */\nconst currentTimeMillis = /*#__PURE__*/clockWith(clock => clock.currentTimeMillis);\n\n/** @internal */\nconst currentTimeNanos = /*#__PURE__*/clockWith(clock => clock.currentTimeNanos);\n\n/** @internal */\nconst withClock = /*#__PURE__*/dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add(clockTag, value))(effect));\n\n// circular with ConfigProvider\n\n/** @internal */\nconst withConfigProvider = /*#__PURE__*/dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add(configProviderTag, value))(effect));\n\n/** @internal */\nconst configProviderWith = f => fiberRefGetWith(currentServices, services => f(get(services, configProviderTag)));\n\n/** @internal */\nconst config = config => configProviderWith(_ => _.load(config));\n\n// circular with Random\n\n/** @internal */\nconst randomWith = f => fiberRefGetWith(currentServices, services => f(get(services, randomTag)));\n\n/** @internal */\nconst next = /*#__PURE__*/randomWith(random => random.next());\n\n/** @internal */\nconst nextInt = /*#__PURE__*/randomWith(random => random.nextInt());\n\n/** @internal */\nconst nextBoolean = /*#__PURE__*/randomWith(random => random.nextBoolean());\n\n/** @internal */\nconst nextRange = (min, max) => randomWith(random => random.nextRange(min, max));\n\n/** @internal */\nconst nextIntBetween = (min, max) => randomWith(random => random.nextIntBetween(min, max));\n\n/** @internal */\nconst shuffle = elements => randomWith(random => random.shuffle(elements));\n\n// circular with Tracer\n\n/** @internal */\nconst tracerWith = f => fiberRefGetWith(currentServices, services => f(get(services, tracerTag)));\n\n/** @internal */\nconst withTracer = /*#__PURE__*/dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add(tracerTag, value))(effect));\n\nexport { clockWith, config, configProviderWith, currentServices, currentTimeMillis, currentTimeNanos, liveServices, next, nextBoolean, nextInt, nextIntBetween, nextRange, randomWith, shuffle, sleep, tracerWith, withClock, withConfigProvider, withTracer };\n","import { ClockTypeId as ClockTypeId$1, make as make$1, clockTag } from '../../internal/clock.esm.js';\nimport { sleep as sleep$1, currentTimeMillis as currentTimeMillis$1, currentTimeNanos as currentTimeNanos$1, clockWith as clockWith$1 } from '../../internal/defaultServices.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst ClockTypeId = ClockTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * Represents a time-based clock which provides functionality related to time\n * and scheduling.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst sleep = sleep$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst currentTimeMillis = currentTimeMillis$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst currentTimeNanos = currentTimeNanos$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst clockWith = clockWith$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst Clock = clockTag;\n\nexport { Clock, ClockTypeId, clockWith, currentTimeMillis, currentTimeNanos, make, sleep };\n","import { equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { fromIterable } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { forEachSequentialDiscard, fiberRefSet } from './core.esm.js';\nimport { none, some, getOrElse } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { headNonEmpty, prepend, tailNonEmpty, empty as empty$1, isEmptyReadonlyArray, isNonEmptyReadonlyArray, of } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nfunction unsafeMake(fiberRefLocals) {\n  return new FiberRefsImpl(fiberRefLocals);\n}\n\n/** @internal */\nfunction empty() {\n  return unsafeMake(new Map());\n}\n\n/** @internal */\nconst FiberRefsSym = /*#__PURE__*/Symbol.for(\"effect/FiberRefs\");\n\n/** @internal */\nclass FiberRefsImpl {\n  [FiberRefsSym] = FiberRefsSym;\n  constructor(locals) {\n    this.locals = locals;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {\n  const ref = _ref;\n  let parentStack = _parentStack;\n  let childStack = _childStack;\n  let childModified = _childModified;\n  let ret = undefined;\n  while (ret === undefined) {\n    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {\n      const parentFiberId = headNonEmpty(parentStack)[0];\n      const parentAncestors = tailNonEmpty(parentStack);\n      const childFiberId = headNonEmpty(childStack)[0];\n      const childRefValue = headNonEmpty(childStack)[1];\n      const childAncestors = tailNonEmpty(childStack);\n      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {\n        childStack = childAncestors;\n        childModified = true;\n      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {\n        parentStack = parentAncestors;\n      } else {\n        if (parentFiberId.id < childFiberId.id) {\n          childStack = childAncestors;\n          childModified = true;\n        } else if (parentFiberId.id > childFiberId.id) {\n          parentStack = parentAncestors;\n        } else {\n          ret = [childRefValue, childModified];\n        }\n      }\n    } else {\n      ret = [ref.initial, true];\n    }\n  }\n  return ret;\n};\n\n/** @internal */\nconst joinAs = /*#__PURE__*/dual(3, (self, fiberId, that) => {\n  const parentFiberRefs = new Map(self.locals);\n  for (const [fiberRef, childStack] of that.locals) {\n    const childValue = headNonEmpty(childStack)[1];\n    if (!equals(headNonEmpty(childStack)[0], fiberId)) {\n      if (!parentFiberRefs.has(fiberRef)) {\n        if (equals(childValue, fiberRef.initial)) {\n          continue;\n        }\n        parentFiberRefs.set(fiberRef, [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]);\n        continue;\n      }\n      const parentStack = parentFiberRefs.get(fiberRef);\n      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);\n      if (wasModified) {\n        const patch = fiberRef.diff(ancestor, childValue);\n        const oldValue = headNonEmpty(parentStack)[1];\n        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));\n        if (!equals(oldValue, newValue)) {\n          let newStack;\n          const parentFiberId = headNonEmpty(parentStack)[0];\n          if (equals(parentFiberId, fiberId)) {\n            newStack = prepend([parentFiberId, newValue])(tailNonEmpty(parentStack));\n          } else {\n            newStack = prepend([fiberId, newValue])(parentStack);\n          }\n          parentFiberRefs.set(fiberRef, newStack);\n        }\n      }\n    }\n  }\n  return new FiberRefsImpl(new Map(parentFiberRefs));\n});\n\n/** @internal */\nconst forkAs = /*#__PURE__*/dual(2, (self, childId) => {\n  const map = new Map();\n  for (const [fiberRef, stack] of self.locals.entries()) {\n    const oldValue = headNonEmpty(stack)[1];\n    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);\n    if (equals(oldValue, newValue)) {\n      map.set(fiberRef, stack);\n    } else {\n      map.set(fiberRef, prepend([childId, newValue])(stack));\n    }\n  }\n  return new FiberRefsImpl(map);\n});\n\n/** @internal */\nconst fiberRefs = self => fromIterable(self.locals.keys());\n\n/** @internal */\nconst setAll = self => forEachSequentialDiscard(fiberRefs(self), fiberRef => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));\n\n/** @internal */\nconst delete_ = /*#__PURE__*/dual(2, (self, fiberRef) => {\n  const locals = new Map(self.locals);\n  locals.delete(fiberRef);\n  return new FiberRefsImpl(locals);\n});\n\n/** @internal */\nconst get = /*#__PURE__*/dual(2, (self, fiberRef) => {\n  if (!self.locals.has(fiberRef)) {\n    return none();\n  }\n  return some(headNonEmpty(self.locals.get(fiberRef))[1]);\n});\n\n/** @internal */\nconst getOrDefault = /*#__PURE__*/dual(2, (self, fiberRef) => pipe(get(self, fiberRef), getOrElse(() => fiberRef.initial)));\n\n/** @internal */\nconst updatedAs = /*#__PURE__*/dual(2, (self, {\n  fiberId,\n  fiberRef,\n  value\n}) => {\n  const oldStack = self.locals.has(fiberRef) ? self.locals.get(fiberRef) : empty$1();\n  let newStack;\n  if (isEmptyReadonlyArray(oldStack)) {\n    newStack = of([fiberId, value]);\n  } else {\n    const [currentId, currentValue] = headNonEmpty(oldStack);\n    if (equals(currentId, fiberId)) {\n      if (equals(currentValue, value)) {\n        return self;\n      } else {\n        newStack = prepend([fiberId, value])(tailNonEmpty(oldStack));\n      }\n    } else {\n      newStack = prepend([fiberId, value])(oldStack);\n    }\n  }\n  const locals = new Map(self.locals);\n  return new FiberRefsImpl(locals.set(fiberRef, newStack));\n});\n\nexport { FiberRefsImpl, FiberRefsSym, delete_, empty, fiberRefs, forkAs, get, getOrDefault, joinAs, setAll, unsafeMake, updatedAs };\n","import { FiberRefsSym as FiberRefsSym$1, delete_ as delete_$1, fiberRefs as fiberRefs$1, forkAs as forkAs$1, get as get$1, getOrDefault as getOrDefault$1, joinAs as joinAs$1, setAll as setAll$1, updatedAs as updatedAs$1, unsafeMake as unsafeMake$1, empty as empty$1 } from '../../internal/fiberRefs.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst FiberRefsSym = FiberRefsSym$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * `FiberRefs` is a data type that represents a collection of `FiberRef` values.\n *\n * This allows safely propagating `FiberRef` values across fiber boundaries, for\n * example between an asynchronous producer and consumer.\n *\n * @since 2.0.0\n * @category models\n */\n\nconst delete_ = delete_$1;\n\n/**\n * Returns a set of each `FiberRef` in this collection.\n *\n * @since 2.0.0\n * @category getters\n */\nconst fiberRefs = fiberRefs$1;\n\n/**\n * Forks this collection of fiber refs as the specified child fiber id. This\n * will potentially modify the value of the fiber refs, as determined by the\n * individual fiber refs that make up the collection.\n *\n * @since 2.0.0\n * @category utils\n */\nconst forkAs = forkAs$1;\n\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or `None` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst get = get$1;\n\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or the `initial` value of the `FiberRef` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst getOrDefault = getOrDefault$1;\n\n/**\n * Joins this collection of fiber refs to the specified collection, as the\n * specified fiber id. This will perform diffing and merging to ensure\n * preservation of maximum information from both child and parent refs.\n *\n * @since 2.0.0\n * @category utils\n */\nconst joinAs = joinAs$1;\n\n/**\n * Set each ref to either its value or its default.\n *\n * @since 2.0.0\n * @category utils\n */\nconst setAll = setAll$1;\n\n/**\n * Updates the value of the specified `FiberRef` using the provided `FiberId`\n *\n * @since 2.0.0\n * @category utils\n */\nconst updatedAs = updatedAs$1;\n\n/**\n * Note: it will not copy the provided Map, make sure to provide a fresh one.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeMake = unsafeMake$1;\n\n/**\n * The empty collection of `FiberRef` values.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst empty = empty$1;\n\nexport { FiberRefsSym, delete_ as delete, empty, fiberRefs, forkAs, get, getOrDefault, joinAs, setAll, unsafeMake, updatedAs };\n","import { equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { getOrDefault, updatedAs, delete_ } from '../fiberRefs.esm.js';\nimport { headNonEmpty, isNonEmptyReadonlyArray, tailNonEmpty, prepend, of } from '../../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nconst OP_EMPTY = \"Empty\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ADD = \"Add\";\n\n/** @internal */\n\n/** @internal */\nconst OP_REMOVE = \"Remove\";\n\n/** @internal */\n\n/** @internal */\nconst OP_UPDATE = \"Update\";\n\n/** @internal */\n\n/** @internal */\nconst OP_AND_THEN = \"AndThen\";\n\n/** @internal */\n\n/** @internal */\nconst empty = {\n  _tag: OP_EMPTY\n};\n\n/** @internal */\nconst diff = (oldValue, newValue) => {\n  const missingLocals = new Map(oldValue.locals);\n  let patch = empty;\n  for (const [fiberRef, pairs] of newValue.locals.entries()) {\n    const newValue = headNonEmpty(pairs)[1];\n    const old = missingLocals.get(fiberRef);\n    if (old !== undefined) {\n      const oldValue = headNonEmpty(old)[1];\n      if (!equals(oldValue, newValue)) {\n        patch = combine({\n          _tag: OP_UPDATE,\n          fiberRef,\n          patch: fiberRef.diff(oldValue, newValue)\n        })(patch);\n      }\n    } else {\n      patch = combine({\n        _tag: OP_ADD,\n        fiberRef,\n        value: newValue\n      })(patch);\n    }\n    missingLocals.delete(fiberRef);\n  }\n  for (const [fiberRef] of missingLocals.entries()) {\n    patch = combine({\n      _tag: OP_REMOVE,\n      fiberRef\n    })(patch);\n  }\n  return patch;\n};\n\n/** @internal */\nconst combine = /*#__PURE__*/dual(2, (self, that) => ({\n  _tag: OP_AND_THEN,\n  first: self,\n  second: that\n}));\n\n/** @internal */\nconst patch = /*#__PURE__*/dual(3, (self, fiberId, oldValue) => {\n  let fiberRefs = oldValue;\n  let patches = of(self);\n  while (isNonEmptyReadonlyArray(patches)) {\n    const head = headNonEmpty(patches);\n    const tail = tailNonEmpty(patches);\n    switch (head._tag) {\n      case OP_EMPTY:\n        {\n          patches = tail;\n          break;\n        }\n      case OP_ADD:\n        {\n          fiberRefs = updatedAs(fiberRefs, {\n            fiberId,\n            fiberRef: head.fiberRef,\n            value: head.value\n          });\n          patches = tail;\n          break;\n        }\n      case OP_REMOVE:\n        {\n          fiberRefs = delete_(fiberRefs, head.fiberRef);\n          patches = tail;\n          break;\n        }\n      case OP_UPDATE:\n        {\n          const value = getOrDefault(fiberRefs, head.fiberRef);\n          fiberRefs = updatedAs(fiberRefs, {\n            fiberId,\n            fiberRef: head.fiberRef,\n            value: head.fiberRef.patch(head.patch)(value)\n          });\n          patches = tail;\n          break;\n        }\n      case OP_AND_THEN:\n        {\n          patches = prepend(head.first)(prepend(head.second)(tail));\n          break;\n        }\n    }\n  }\n  return fiberRefs;\n});\n\nexport { OP_ADD, OP_AND_THEN, OP_EMPTY, OP_REMOVE, OP_UPDATE, combine, diff, empty, patch };\n","import { symbol as symbol$1 } from '../../Equal/dist/effect-Equal.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../../Hash/dist/effect-Hash.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst MetricLabelSymbolKey = \"effect/MetricLabel\";\n\n/** @internal */\nconst MetricLabelTypeId = /*#__PURE__*/Symbol.for(MetricLabelSymbolKey);\n\n/** @internal */\nclass MetricLabelImpl {\n  [MetricLabelTypeId] = MetricLabelTypeId;\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  [symbol]() {\n    return pipe(hash(MetricLabelSymbolKey), combine(hash(this.key)), combine(hash(this.value)));\n  }\n  [symbol$1](that) {\n    return isMetricLabel(that) && this.key === that.key && this.value === that.value;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst make = (key, value) => {\n  return new MetricLabelImpl(key, value);\n};\n\n/** @internal */\nconst isMetricLabel = u => {\n  return typeof u === \"object\" && u != null && MetricLabelTypeId in u;\n};\n\nexport { MetricLabelTypeId, isMetricLabel, make };\n","/** @internal */\nclass SingleShotGen {\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  throw(e) {\n    throw e;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n\nexport { SingleShotGen };\n","import { dual, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { logLevelAll, logLevelFatal, logLevelError, logLevelWarning, logLevelInfo, logLevelDebug, logLevelTrace, logLevelNone, allLogLevels, fiberRefLocally, currentLogLevel } from '../../internal/core.esm.js';\nimport { Order as Order$1 } from '../../Number/dist/effect-Number.esm.js';\nimport { mapInput, lessThan as lessThan$1, lessThanOrEqualTo, greaterThan as greaterThan$1, greaterThanOrEqualTo } from '../../Order/dist/effect-Order.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * A `LogLevel` represents the log level associated with an individual logging\n * operation. Log levels are used both to describe the granularity (or\n * importance) of individual log statements, as well as to enable tuning\n * verbosity of log output.\n *\n * @since 2.0.0\n * @category model\n * @property ordinal - The priority of the log message. Larger values indicate higher priority.\n * @property label - A label associated with the log level.\n * @property syslog -The syslog severity level of the log level.\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst All = logLevelAll;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Fatal = logLevelFatal;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Error = logLevelError;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Warning = logLevelWarning;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Info = logLevelInfo;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Debug = logLevelDebug;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Trace = logLevelTrace;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst None = logLevelNone;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst allLevels = allLogLevels;\n\n/**\n * Locally applies the specified `LogLevel` to an `Effect` workflow, reverting\n * to the previous `LogLevel` after the `Effect` workflow completes.\n *\n * @since 2.0.0\n * @category utils\n */\nconst locally = /*#__PURE__*/dual(2, (use, self) => fiberRefLocally(use, currentLogLevel, self));\n\n/**\n * @since 2.0.0\n * @category instances\n */\nconst Order = /*#__PURE__*/pipe(Order$1, /*#__PURE__*/mapInput(level => level.ordinal));\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nconst lessThan = /*#__PURE__*/lessThan$1(Order);\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nconst lessThanEqual = /*#__PURE__*/lessThanOrEqualTo(Order);\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nconst greaterThan = /*#__PURE__*/greaterThan$1(Order);\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nconst greaterThanEqual = /*#__PURE__*/greaterThanOrEqualTo(Order);\n\n/**\n * @since 2.0.0\n * @category conversions\n */\nconst fromLiteral = _ => {\n  switch (_) {\n    case \"All\":\n      {\n        return All;\n      }\n    case \"Debug\":\n      {\n        return Debug;\n      }\n    case \"Error\":\n      {\n        return Error;\n      }\n    case \"Fatal\":\n      {\n        return Fatal;\n      }\n    case \"Info\":\n      {\n        return Info;\n      }\n    case \"Trace\":\n      {\n        return Trace;\n      }\n    case \"None\":\n      {\n        return None;\n      }\n    case \"Warning\":\n      {\n        return Warning;\n      }\n  }\n};\n\nexport { All, Debug, Error, Fatal, Info, None, Order, Trace, Warning, allLevels, fromLiteral, greaterThan, greaterThanEqual, lessThan, lessThanEqual, locally };\n","/** @internal */\nconst make = (label, startTime) => ({\n  label,\n  startTime\n});\n\n/** @internal */\nconst render = now => {\n  return self => {\n    const label = self.label.replace(/[\\s=\"]/g, \"_\");\n    return `${label}=${now - self.startTime}ms`;\n  };\n};\n\nexport { make, render };\n","import { make as make$1, render as render$1 } from '../../internal/logSpan.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nconst render = render$1;\n\nexport { make, render };\n","import { dual } from '../Function/dist/effect-Function.esm.js';\nimport { sync } from './core.esm.js';\nimport { make as make$1, get as get$1, set as set$1 } from '../MutableRef/dist/effect-MutableRef.esm.js';\nimport { match } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst RefTypeId = /*#__PURE__*/Symbol.for(\"effect/Ref\");\n\n/** @internal */\nconst refVariance = {\n  _A: _ => _\n};\nclass RefImpl {\n  [RefTypeId] = refVariance;\n  constructor(ref) {\n    this.ref = ref;\n  }\n  modify(f) {\n    return sync(() => {\n      const current = get$1(this.ref);\n      const [b, a] = f(current);\n      if (current !== a) {\n        set$1(a)(this.ref);\n      }\n      return b;\n    });\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst unsafeMake = value => new RefImpl(make$1(value));\n\n/** @internal */\nconst make = value => sync(() => unsafeMake(value));\n\n/** @internal */\nconst get = self => self.modify(a => [a, a]);\n\n/** @internal */\nconst set = /*#__PURE__*/dual(2, (self, value) => self.modify(() => [void 0, value]));\n\n/** @internal */\nconst getAndSet = /*#__PURE__*/dual(2, (self, value) => self.modify(a => [a, value]));\n\n/** @internal */\nconst getAndUpdate = /*#__PURE__*/dual(2, (self, f) => self.modify(a => [a, f(a)]));\n\n/** @internal */\nconst getAndUpdateSome = /*#__PURE__*/dual(2, (self, pf) => self.modify(value => {\n  const option = pf(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [value, value];\n      }\n    case \"Some\":\n      {\n        return [value, option.value];\n      }\n  }\n}));\n\n/** @internal */\nconst setAndGet = /*#__PURE__*/dual(2, (self, value) => self.modify(() => [value, value]));\n\n/** @internal */\nconst modify = /*#__PURE__*/dual(2, (self, f) => self.modify(f));\n\n/** @internal */\nconst modifySome = /*#__PURE__*/dual(3, (self, fallback, pf) => self.modify(value => {\n  const option = pf(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [fallback, value];\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}));\n\n/** @internal */\nconst update = /*#__PURE__*/dual(2, (self, f) => self.modify(a => [void 0, f(a)]));\n\n/** @internal */\nconst updateAndGet = /*#__PURE__*/dual(2, (self, f) => self.modify(a => {\n  const result = f(a);\n  return [result, result];\n}));\n\n/** @internal */\nconst updateSome = /*#__PURE__*/dual(2, (self, f) => self.modify(a => [void 0, match(f(a), {\n  onNone: () => a,\n  onSome: b => b\n})]));\n\n/** @internal */\nconst updateSomeAndGet = /*#__PURE__*/dual(2, (self, pf) => self.modify(value => {\n  const option = pf(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [value, value];\n      }\n    case \"Some\":\n      {\n        return [option.value, option.value];\n      }\n  }\n}));\n\n/** @internal */\nconst unsafeGet = self => get$1(self.ref);\n\nexport { RefTypeId, get, getAndSet, getAndUpdate, getAndUpdateSome, make, modify, modifySome, refVariance, set, setAndGet, unsafeGet, unsafeMake, update, updateAndGet, updateSome, updateSomeAndGet };\n","import { RefTypeId as RefTypeId$1, make as make$1, get as get$1, getAndSet as getAndSet$1, getAndUpdate as getAndUpdate$1, getAndUpdateSome as getAndUpdateSome$1, modify as modify$1, modifySome as modifySome$1, set as set$1, setAndGet as setAndGet$1, update as update$1, updateAndGet as updateAndGet$1, updateSome as updateSome$1, updateSomeAndGet as updateSomeAndGet$1, unsafeMake as unsafeMake$1 } from '../../internal/ref.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst RefTypeId = RefTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * @since 2.0.0\n * @category getters\n */\nconst get = get$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst getAndSet = getAndSet$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst getAndUpdate = getAndUpdate$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst getAndUpdateSome = getAndUpdateSome$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst modify = modify$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst modifySome = modifySome$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst set = set$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst setAndGet = setAndGet$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst update = update$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst updateAndGet = updateAndGet$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst updateSome = updateSome$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst updateSomeAndGet = updateSomeAndGet$1;\n\n/**\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeMake = unsafeMake$1;\n\nexport { RefTypeId, get, getAndSet, getAndUpdate, getAndUpdateSome, make, modify, modifySome, set, setAndGet, unsafeMake, update, updateAndGet, updateSome, updateSomeAndGet };\n","import { append, toReadonlyArray, fromIterable as fromIterable$2, isNonEmpty, headNonEmpty, tailNonEmpty } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { clockWith as clockWith$1, sleep as sleep$1, currentTimeMillis, currentTimeNanos } from '../Clock/dist/effect-Clock.esm.js';\nimport { add, unsafeGet, empty as empty$1 } from '../Context/dist/effect-Context.esm.js';\nimport { nanos } from '../Duration/dist/effect-Duration.esm.js';\nimport { right, left } from '../Either/dist/effect-Either.esm.js';\nimport { none as none$1 } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { setAll, joinAs } from '../FiberRefs/dist/effect-FiberRefs.esm.js';\nimport { dual, identity, constVoid, constTrue, constFalse, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { set, forEach } from '../HashMap/dist/effect-HashMap.esm.js';\nimport { fromIterable as fromIterable$1, union, size } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { fail, find, isDieType, empty, failures, failureOrCause, keepDefects, flatten, NoSuchElementException, isNoSuchElementException, interruptors, IllegalArgumentException, isCause } from './cause.esm.js';\nimport { fiberRefLocallyWith, currentLogAnnotations, isEffect, map, mapError, asyncEither, unit, sync, makeEffectError, catchAll, fail as fail$1, catchAllCause, unified, failCause, matchCauseEffect, succeed, catchIf, matchCause, zipRight, withFiberRuntime, flatMap, suspend, context, orElse, yieldNow, dieSync, dieMessage, failSync, flip, matchEffect, currentLogSpan, fiberRefGet, failCauseSync, intoDeferred, deferredAwait, as, zip, updateRuntimeFlags, deferredMake, asUnit, whenEffect, async, contextWithEffect, provideContext, currentMetricLabels, mapInputContext, currentTracerSpanAnnotations, currentTracerSpan, currentTracerSpanLinks, acquireUseRelease, currentInterruptedCause, interrupt, runtimeFlags, fiberRefGetWith, currentTracerTimingEnabled, exitSucceed, exitDie } from './core.esm.js';\nimport { randomWith } from './defaultServices.esm.js';\nimport { diff, patch } from './fiberRefs/patch.esm.js';\nimport { make as make$2 } from './metric/label.esm.js';\nimport { diff as diff$1 } from './runtimeFlags.esm.js';\nimport { SingleShotGen } from './singleShotGen.esm.js';\nimport { prepend, head as head$1, findFirst as findFirst$1, empty as empty$2 } from '../List/dist/effect-List.esm.js';\nimport { Trace, Debug, Info, Warning, Error, Fatal } from '../LogLevel/dist/effect-LogLevel.esm.js';\nimport { make } from '../LogSpan/dist/effect-LogSpan.esm.js';\nimport { some, none as none$2, match as match$1, fromNullable as fromNullable$1 } from '../Option/dist/effect-Option.esm.js';\nimport { isTagged, isObject } from '../Predicate/dist/effect-Predicate.esm.js';\nimport { fromIterable, reduce as reduce$1 } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\nimport { make as make$1, getAndSet, get } from '../Ref/dist/effect-Ref.esm.js';\nimport { tracerWith as tracerWith$1 } from '../Tracer/dist/effect-Tracer.esm.js';\n\n/* @internal */\nconst annotateLogs = /*#__PURE__*/dual(args => isEffect(args[0]), function () {\n  const args = arguments;\n  return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === \"string\" ? set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => set(acc, key, value), annotations));\n});\n\n/* @internal */\nconst asSome = self => map(self, some);\n\n/* @internal */\nconst asSomeError = self => mapError(self, some);\n\n/* @internal */\nconst asyncOption = (register, blockingOn = none$1) => asyncEither(cb => {\n  const option = register(cb);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return left(unit);\n      }\n    case \"Some\":\n      {\n        return right(option.value);\n      }\n  }\n}, blockingOn);\n\n/* @internal */\nconst try_ = arg => {\n  let evaluate;\n  let onFailure = undefined;\n  if (typeof arg === \"function\") {\n    evaluate = arg;\n  } else {\n    evaluate = arg.try;\n    onFailure = arg.catch;\n  }\n  return sync(() => {\n    try {\n      return evaluate();\n    } catch (error) {\n      throw makeEffectError(fail(onFailure ? onFailure(error) : error));\n    }\n  });\n};\n\n/* @internal */\nconst _catch = /*#__PURE__*/dual(\n// @ts-expect-error\n3, (self, tag, options) => catchAll(self, e => {\n  if (typeof e === \"object\" && e != null && tag in e && e[tag] === options.failure) {\n    return options.onFailure(e);\n  }\n  return fail$1(e);\n}));\n\n/* @internal */\nconst catchAllDefect = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, unified(cause => {\n  const option = find(cause, _ => isDieType(_) ? some(_) : none$2());\n  switch (option._tag) {\n    case \"None\":\n      {\n        return failCause(cause);\n      }\n    case \"Some\":\n      {\n        return f(option.value.defect);\n      }\n  }\n})));\n\n/* @internal */\nconst catchSomeCause = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const option = f(cause);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return failCause(cause);\n        }\n      case \"Some\":\n        {\n          return option.value;\n        }\n    }\n  },\n  onSuccess: succeed\n}));\n\n/* @internal */\nconst catchSomeDefect = /*#__PURE__*/dual(2, (self, pf) => catchAllCause(self, unified(cause => {\n  const option = find(cause, _ => isDieType(_) ? some(_) : none$2());\n  switch (option._tag) {\n    case \"None\":\n      {\n        return failCause(cause);\n      }\n    case \"Some\":\n      {\n        const optionEffect = pf(option.value.defect);\n        return optionEffect._tag === \"Some\" ? optionEffect.value : failCause(cause);\n      }\n  }\n})));\n\n/* @internal */\nconst catchTag = /*#__PURE__*/dual(3, (self, k, f) => catchIf(self, isTagged(k), f));\n\n/** @internal */\nconst catchTags = /*#__PURE__*/dual(2, (self, cases) => {\n  let keys;\n  return catchIf(self, e => {\n    keys ??= Object.keys(cases);\n    return isObject(e) && \"_tag\" in e && keys.includes(e[\"_tag\"]);\n  }, e => cases[e[\"_tag\"]](e));\n});\n\n/* @internal */\nconst cause = self => matchCause(self, {\n  onFailure: identity,\n  onSuccess: () => empty\n});\n\n/* @internal */\nconst clockWith = clockWith$1;\n\n/* @internal */\nconst clock = /*#__PURE__*/clockWith(succeed);\n\n/* @internal */\nconst delay = /*#__PURE__*/dual(2, (self, duration) => zipRight(sleep$1(duration), self));\n\n/* @internal */\nconst descriptorWith = f => withFiberRuntime((state, status) => f({\n  id: state.id(),\n  status,\n  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))\n}));\n\n/* @internal */\nconst allowInterrupt = /*#__PURE__*/descriptorWith(descriptor => size(descriptor.interruptors) > 0 ? interrupt : unit);\n\n/* @internal */\nconst descriptor = /*#__PURE__*/descriptorWith(succeed);\n\n/* @internal */\nconst diffFiberRefs = self => summarized(self, fiberRefs, diff);\n\n/* @internal */\nconst diffFiberRefsAndRuntimeFlags = self => summarized(self, zip(fiberRefs, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff(refs, refsNew), diff$1(flags, flagsNew)]);\n\n/* @internal */\nconst Do = /*#__PURE__*/succeed({});\n\n/* @internal */\nconst bind = /*#__PURE__*/dual(3, (self, tag, f) => flatMap(self, k => map(f(k), a => ({\n  ...k,\n  [tag]: a\n}))));\n\n/* @internal */\nconst bindTo = /*#__PURE__*/dual(2, (self, tag) => map(self, a => ({\n  [tag]: a\n})));\n\n/* @internal */\nconst bindValue = /*#__PURE__*/dual(3, (self, tag, f) => map(self, k => ({\n  ...k,\n  [tag]: f(k)\n})));\n\n/* @internal */\nconst dropUntil = /*#__PURE__*/dual(2, (elements, predicate) => suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = succeed(false);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    dropping = flatMap(dropping, bool => {\n      if (bool) {\n        builder.push(a);\n        return succeed(true);\n      }\n      return predicate(a, index);\n    });\n  }\n  return map(dropping, () => builder);\n}));\n\n/* @internal */\nconst dropWhile = /*#__PURE__*/dual(2, (elements, f) => suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = succeed(true);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    dropping = flatMap(dropping, d => map(d ? f(a, index) : succeed(false), b => {\n      if (!b) {\n        builder.push(a);\n      }\n      return b;\n    }));\n  }\n  return map(dropping, () => builder);\n}));\n\n/* @internal */\nconst contextWith = f => map(context(), f);\n\n/* @internal */\nconst eventually = self => orElse(self, () => flatMap(yieldNow(), () => eventually(self)));\n\n/* @internal */\nconst filterOrDie = /*#__PURE__*/dual(3, (self, filter, orDieWith) => filterOrElse(self, filter, a => dieSync(() => orDieWith(a))));\n\n/* @internal */\nconst filterOrDieMessage = /*#__PURE__*/dual(3, (self, filter, message) => filterOrElse(self, filter, () => dieMessage(message)));\n\n/* @internal */\nconst filterOrElse = /*#__PURE__*/dual(3, (self, filter, orElse) => flatMap(self, a => filter(a) ? succeed(a) : orElse(a)));\n\n/* @internal */\nconst filterOrFail = /*#__PURE__*/dual(3, (self, filter, orFailWith) => filterOrElse(self, filter, a => failSync(() => orFailWith(a))));\n\n/* @internal */\nconst findFirst = /*#__PURE__*/dual(2, (elements, f) => suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const next = iterator.next();\n  if (!next.done) {\n    return findLoop(iterator, 0, f, next.value);\n  }\n  return succeed(none$2());\n}));\nconst findLoop = (iterator, index, f, value) => flatMap(f(value, index), result => {\n  if (result) {\n    return succeed(some(value));\n  }\n  const next = iterator.next();\n  if (!next.done) {\n    return findLoop(iterator, index + 1, f, next.value);\n  }\n  return succeed(none$2());\n});\n\n/* @internal */\nconst firstSuccessOf = effects => suspend(() => {\n  const list = fromIterable$2(effects);\n  if (!isNonEmpty(list)) {\n    return dieSync(() => IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  return pipe(tailNonEmpty(list), reduce$1(headNonEmpty(list), (left, right) => orElse(left, () => right)));\n});\n\n/* @internal */\nconst flipWith = /*#__PURE__*/dual(2, (self, f) => flip(f(flip(self))));\n\n/* @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchEffect(self, {\n  onFailure: e => succeed(onFailure(e)),\n  onSuccess: a => succeed(onSuccess(a))\n}));\n\n/* @internal */\nconst every = /*#__PURE__*/dual(2, (elements, f) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, f)));\nconst forAllLoop = (iterator, index, f) => {\n  const next = iterator.next();\n  return next.done ? succeed(true) : flatMap(f(next.value, index), b => b ? forAllLoop(iterator, index + 1, f) : succeed(b));\n};\n\n/* @internal */\nconst forever = self => {\n  const loop = flatMap(flatMap(self, () => yieldNow()), () => loop);\n  return loop;\n};\n\n/** @internal */\nclass EffectGen {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this);\n  }\n}\nconst adapter = function () {\n  let x = arguments[0];\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x);\n  }\n  return new EffectGen(x);\n};\n\n/**\n * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)\n  @internal */\nconst gen = function () {\n  let f;\n  if (arguments.length === 1) {\n    f = arguments[0];\n  } else {\n    f = arguments[1].bind(arguments[0]);\n  }\n  return suspend(() => {\n    const iterator = f(adapter);\n    const state = iterator.next();\n    const run = state => state.done ? succeed(state.value) : pipe(state.value.value, flatMap(val => run(iterator.next(val))));\n    return run(state);\n  });\n};\n\n/* @internal */\nconst fiberRefs = /*#__PURE__*/withFiberRuntime(state => succeed(state.getFiberRefs()));\n\n/* @internal */\nconst head = self => matchEffect(self, {\n  onFailure: e => fail$1(some(e)),\n  onSuccess: as => {\n    const iterator = as[Symbol.iterator]();\n    const next = iterator.next();\n    if (next.done) {\n      return fail$1(none$2());\n    }\n    return succeed(next.value);\n  }\n});\n\n/* @internal */\nconst ignore = self => match(self, {\n  onFailure: constVoid,\n  onSuccess: constVoid\n});\n\n/* @internal */\nconst ignoreLogged = self => matchCauseEffect(self, {\n  onFailure: cause => logDebug(cause, \"An error was silently ignored because it is not anticipated to be useful\"),\n  onSuccess: () => unit\n});\n\n/* @internal */\nconst inheritFiberRefs = childFiberRefs => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs(parentFiberRefs, parentFiberId, childFiberRefs));\n\n/* @internal */\nconst isFailure = self => match(self, {\n  onFailure: constTrue,\n  onSuccess: constFalse\n});\n\n/* @internal */\nconst isSuccess = self => match(self, {\n  onFailure: constFalse,\n  onSuccess: constTrue\n});\n\n/* @internal */\nconst iterate = (initial, options) => suspend(() => {\n  if (options.while(initial)) {\n    return flatMap(options.body(initial), z2 => iterate(z2, options));\n  }\n  return succeed(initial);\n});\nconst logWithLevel = level => (messageOrCause, supplementary) => {\n  const levelOption = fromNullable$1(level);\n  let message;\n  let cause;\n  if (isCause(messageOrCause)) {\n    cause = messageOrCause;\n    message = supplementary ?? \"\";\n  } else {\n    message = messageOrCause;\n    cause = supplementary ?? empty;\n  }\n  return withFiberRuntime(fiberState => {\n    fiberState.log(message, cause, levelOption);\n    return unit;\n  });\n};\n\n/** @internal */\nconst log = /*#__PURE__*/logWithLevel();\n\n/** @internal */\nconst logTrace = /*#__PURE__*/logWithLevel(Trace);\n\n/** @internal */\nconst logDebug = /*#__PURE__*/logWithLevel(Debug);\n\n/** @internal */\nconst logInfo = /*#__PURE__*/logWithLevel(Info);\n\n/** @internal */\nconst logWarning = /*#__PURE__*/logWithLevel(Warning);\n\n/** @internal */\nconst logError = /*#__PURE__*/logWithLevel(Error);\n\n/** @internal */\nconst logFatal = /*#__PURE__*/logWithLevel(Fatal);\n\n/* @internal */\nconst withLogSpan = /*#__PURE__*/dual(2, (effect, label) => flatMap(currentTimeMillis, now => fiberRefLocallyWith(effect, currentLogSpan, prepend(make(label, now)))));\n\n/* @internal */\nconst logAnnotations = /*#__PURE__*/fiberRefGet(currentLogAnnotations);\n\n/* @internal */\n// @ts-expect-error\nconst loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map(loopInternal(initial, options.while, options.step, options.body), x => Array.from(x));\nconst loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap(body(initial), a => map(loopInternal(inc(initial), cont, inc, body), prepend(a))) : sync(() => empty$2()));\nconst loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : unit);\n\n/* @internal */\nconst mapAccum = /*#__PURE__*/dual(3, (elements, zero, f) => suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let result = succeed(zero);\n  let next;\n  let i = 0;\n  while (!(next = iterator.next()).done) {\n    const index = i++;\n    result = flatMap(result, state => map(f(state, next.value, index), ([z, b]) => {\n      builder.push(b);\n      return z;\n    }));\n  }\n  return map(result, z => [z, builder]);\n}));\n\n/* @internal */\nconst mapErrorCause = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: c => failCauseSync(() => f(c)),\n  onSuccess: succeed\n}));\n\n/* @internal */\nconst memoize = self => pipe(deferredMake(), flatMap(deferred => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map(complete => zipRight(complete, pipe(deferredAwait(deferred), flatMap(([patch, a]) => as(zip(patchFiberRefs(patch[0]), updateRuntimeFlags(patch[1])), a))))))));\n\n/* @internal */\nconst merge = self => matchEffect(self, {\n  onFailure: e => succeed(e),\n  onSuccess: succeed\n});\n\n/* @internal */\nconst negate = self => map(self, b => !b);\n\n/* @internal */\nconst none = self => matchEffect(self, {\n  onFailure: e => fail$1(some(e)),\n  onSuccess: option => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return unit;\n        }\n      case \"Some\":\n        {\n          return fail$1(none$2());\n        }\n    }\n  }\n});\n\n/* @internal */\nconst once = self => map(make$1(true), ref => asUnit(whenEffect(self, getAndSet(ref, false))));\n\n/* @internal */\nconst option = self => matchEffect(self, {\n  onFailure: () => succeed(none$2()),\n  onSuccess: a => succeed(some(a))\n});\n\n/* @internal */\nconst orElseFail = /*#__PURE__*/dual(2, (self, evaluate) => orElse(self, () => failSync(evaluate)));\n\n/* @internal */\nconst orElseSucceed = /*#__PURE__*/dual(2, (self, evaluate) => orElse(self, () => sync(evaluate)));\n\n/* @internal */\nconst parallelErrors = self => matchCauseEffect(self, {\n  onFailure: cause => {\n    const errors = Array.from(failures(cause));\n    return errors.length === 0 ? failCause(cause) : fail$1(errors);\n  },\n  onSuccess: succeed\n});\n\n/* @internal */\nconst patchFiberRefs = patch$1 => updateFiberRefs((fiberId, fiberRefs) => pipe(patch$1, patch(fiberId, fiberRefs)));\n\n/* @internal */\nconst promise = evaluate => evaluate.length >= 1 ? async((resolve, signal) => {\n  evaluate(signal).then(a => resolve(exitSucceed(a))).catch(e => resolve(exitDie(e)));\n}) : async(resolve => {\n  evaluate().then(a => resolve(exitSucceed(a))).catch(e => resolve(exitDie(e)));\n});\n\n/* @internal */\nconst provideService = /*#__PURE__*/dual(3, (self, tag, service) => provideServiceEffect(self, tag, succeed(service)));\n\n/* @internal */\nconst provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => contextWithEffect(env => flatMap(effect, service => provideContext(self, pipe(env, add(tag, service))))));\n\n/* @internal */\nconst random = /*#__PURE__*/randomWith(succeed);\n\n/* @internal */\nconst reduce = /*#__PURE__*/dual(3, (elements, zero, f) => fromIterable(elements).reduce((acc, el, i) => flatMap(acc, a => f(a, el, i)), succeed(zero)));\n\n/* @internal */\nconst reduceRight = /*#__PURE__*/dual(3, (elements, zero, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap(acc, a => f(el, a, i)), succeed(zero)));\n\n/* @internal */\nconst reduceWhile = /*#__PURE__*/dual(3, (elements, zero, options) => flatMap(sync(() => elements[Symbol.iterator]()), iterator => reduceWhileLoop(iterator, 0, zero, options.while, options.body)));\nconst reduceWhileLoop = (iterator, index, state, predicate, f) => {\n  const next = iterator.next();\n  if (!next.done && predicate(state)) {\n    return flatMap(f(state, next.value, index), nextState => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));\n  }\n  return succeed(state);\n};\n\n/* @internal */\nconst repeatN = /*#__PURE__*/dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));\n\n/* @internal */\nconst repeatNLoop = (self, n) => flatMap(self, a => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1)));\n\n/* @internal */\nconst sandbox = self => matchCauseEffect(self, {\n  onFailure: fail$1,\n  onSuccess: succeed\n});\n\n/* @internal */\nconst setFiberRefs = fiberRefs => suspend(() => setAll(fiberRefs));\n\n/* @internal */\nconst sleep = sleep$1;\n\n/* @internal */\nconst succeedNone = /*#__PURE__*/succeed( /*#__PURE__*/none$2());\n\n/* @internal */\nconst succeedSome = value => succeed(some(value));\n\n/* @internal */\nconst summarized = /*#__PURE__*/dual(3, (self, summary, f) => flatMap(summary, start => flatMap(self, value => map(summary, end => [f(start, end), value]))));\n\n/* @internal */\nconst tagMetrics = /*#__PURE__*/dual(args => isEffect(args[0]), function () {\n  return labelMetrics(arguments[0], typeof arguments[1] === \"string\" ? [make$2(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make$2(k, v)));\n});\n\n/* @internal */\nconst labelMetrics = /*#__PURE__*/dual(2, (self, labels) => labelMetricsSet(self, fromIterable$1(labels)));\n\n/* @internal */\nconst labelMetricsSet = /*#__PURE__*/dual(2, (self, labels) => fiberRefLocallyWith(currentMetricLabels, set => pipe(set, union(labels)))(self));\n\n/* @internal */\nconst takeUntil = /*#__PURE__*/dual(2, (elements, predicate) => suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let effect = succeed(false);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    effect = flatMap(effect, bool => {\n      if (bool) {\n        return succeed(true);\n      }\n      builder.push(a);\n      return predicate(a, index);\n    });\n  }\n  return map(effect, () => builder);\n}));\n\n/* @internal */\nconst takeWhile = /*#__PURE__*/dual(2, (elements, predicate) => suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let taking = succeed(true);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    taking = flatMap(taking, taking => pipe(taking ? predicate(a, index) : succeed(false), map(bool => {\n      if (bool) {\n        builder.push(a);\n      }\n      return bool;\n    })));\n  }\n  return map(taking, () => builder);\n}));\n\n/* @internal */\nconst tapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return zipRight(onFailure(either.left), failCause(cause));\n        }\n      case \"Right\":\n        {\n          return failCause(cause);\n        }\n    }\n  },\n  onSuccess: a => as(onSuccess(a), a)\n}));\n\n/* @internal */\nconst tapDefect = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => match$1(keepDefects(cause), {\n  onNone: () => failCause(cause),\n  onSome: a => zipRight(f(a), failCause(cause))\n})));\n\n/* @internal */\nconst tapError = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return zipRight(f(either.left), failCause(cause));\n        }\n      case \"Right\":\n        {\n          return failCause(cause);\n        }\n    }\n  },\n  onSuccess: succeed\n}));\n\n/* @internal */\nconst tapErrorTag = /*#__PURE__*/dual(3, (self, k, f) => tapError(self, e => {\n  if (isTagged(e, k)) {\n    return f(e);\n  }\n  return unit;\n}));\n\n/* @internal */\nconst tapErrorCause = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: cause => zipRight(f(cause), failCause(cause)),\n  onSuccess: succeed\n}));\n\n/* @internal */\nconst timed = self => timedWith(self, currentTimeNanos);\n\n/* @internal */\nconst timedWith = /*#__PURE__*/dual(2, (self, nanos$1) => summarized(self, nanos$1, (start, end) => nanos(end - start)));\n\n/* @internal */\nconst tracerWith = tracerWith$1;\n\n/** @internal */\nconst tracer = /*#__PURE__*/tracerWith(succeed);\n\n/* @internal */\nconst tryPromise = arg => {\n  let evaluate;\n  let catcher = undefined;\n  if (typeof arg === \"function\") {\n    evaluate = arg;\n  } else {\n    evaluate = arg.try;\n    catcher = arg.catch;\n  }\n  if (evaluate.length >= 1) {\n    return suspend(() => {\n      const controller = new AbortController();\n      return flatMap(try_(() => evaluate(controller.signal)), promise => async(resolve => {\n        promise.then(a => resolve(exitSucceed(a))).catch(e => resolve(fail$1(catcher ? catcher(e) : e)));\n        return sync(() => controller.abort());\n      }));\n    });\n  }\n  return flatMap(try_(arg), promise => async(resolve => {\n    promise.then(a => resolve(exitSucceed(a))).catch(e => resolve(fail$1(catcher ? catcher(e) : e)));\n  }));\n};\n\n/* @internal */\nconst tryMap = /*#__PURE__*/dual(2, (self, options) => flatMap(self, a => try_({\n  try: () => options.try(a),\n  catch: options.catch\n})));\n\n/* @internal */\nconst tryMapPromise = /*#__PURE__*/dual(2, (self, options) => flatMap(self, a => tryPromise({\n  try: options.try.length >= 1 ? signal => options.try(a, signal) : () => options.try(a),\n  catch: options.catch\n})));\n\n/* @internal */\nconst unless = /*#__PURE__*/dual(2, (self, predicate) => suspend(() => predicate() ? succeedNone : asSome(self)));\n\n/* @internal */\nconst unlessEffect = /*#__PURE__*/dual(2, (self, predicate) => flatMap(predicate, b => b ? succeedNone : asSome(self)));\n\n/* @internal */\nconst unsandbox = self => mapErrorCause(self, flatten);\n\n/* @internal */\nconst updateFiberRefs = f => withFiberRuntime(state => {\n  state.setFiberRefs(f(state.id(), state.getFiberRefs()));\n  return unit;\n});\n\n/* @internal */\nconst updateService = /*#__PURE__*/dual(3, (self, tag, f) => mapInputContext(self, context => add(context, tag, f(unsafeGet(context, tag)))));\n\n/* @internal */\nconst when = /*#__PURE__*/dual(2, (self, predicate) => suspend(() => predicate() ? map(self, some) : succeed(none$2())));\n\n/* @internal */\nconst whenFiberRef = /*#__PURE__*/dual(3, (self, fiberRef, predicate) => flatMap(fiberRefGet(fiberRef), s => predicate(s) ? map(self, a => [s, some(a)]) : succeed([s, none$2()])));\n\n/* @internal */\nconst whenRef = /*#__PURE__*/dual(3, (self, ref, predicate) => flatMap(get(ref), s => predicate(s) ? map(self, a => [s, some(a)]) : succeed([s, none$2()])));\n\n/* @internal */\nconst withMetric = /*#__PURE__*/dual(2, (self, metric) => metric(self));\n\n/** @internal */\nconst serviceFunctionEffect = (service, f) => (...args) => flatMap(service, a => f(a)(...args));\n\n/** @internal */\nconst serviceFunction = (service, f) => (...args) => map(service, a => f(a)(...args));\n\n/** @internal */\nconst serviceFunctions = tag => new Proxy({}, {\n  get(_target, prop, _receiver) {\n    return (...args) => flatMap(tag, s => s[prop](...args));\n  }\n});\n\n/** @internal */\nconst serviceConstants = tag => new Proxy({}, {\n  get(_target, prop, _receiver) {\n    return flatMap(tag, s => s[prop]);\n  }\n});\n\n/** @internal */\nconst serviceMembers = tag => ({\n  functions: serviceFunctions(tag),\n  constants: serviceConstants(tag)\n});\n\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n\n/* @internal */\nconst annotateCurrentSpan = function () {\n  const args = arguments;\n  return flatMap(currentSpan, span => span._tag === \"Some\" ? sync(() => {\n    if (typeof args[0] === \"string\") {\n      span.value.attribute(args[0], args[1]);\n    } else {\n      for (const key in args[0]) {\n        span.value.attribute(key, args[0][key]);\n      }\n    }\n  }) : unit);\n};\n\n/* @internal */\nconst annotateSpans = /*#__PURE__*/dual(args => isEffect(args[0]), function () {\n  const args = arguments;\n  return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === \"string\" ? set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => set(acc, key, value), annotations));\n});\n\n/* @internal */\nconst currentParentSpan = /*#__PURE__*/map( /*#__PURE__*/fiberRefGet(currentTracerSpan), head$1);\n\n/* @internal */\nconst currentSpan = /*#__PURE__*/map( /*#__PURE__*/fiberRefGet(currentTracerSpan), /*#__PURE__*/findFirst$1(span => span._tag === \"Span\"));\nconst bigint0 = /*#__PURE__*/BigInt(0);\n/** @internal */\nconst currentTimeNanosTracing = /*#__PURE__*/fiberRefGetWith(currentTracerTimingEnabled, enabled => enabled ? currentTimeNanos : succeed(bigint0));\n\n/* @internal */\nconst linkSpans = /*#__PURE__*/dual(args => isEffect(args[0]), (self, span, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append({\n  _tag: \"SpanLink\",\n  span,\n  attributes: attributes ?? {}\n})));\n\n/** @internal */\nconst makeSpan = (name, options) => tracerWith(tracer => flatMap(options?.parent ? succeedSome(options.parent) : options?.root ? succeedNone : currentParentSpan, parent => flatMap(fiberRefGet(currentTracerSpanAnnotations), annotations => flatMap(fiberRefGet(currentTracerSpanLinks), links => flatMap(currentTimeNanosTracing, startTime => sync(() => {\n  const linksArray = options?.links ? [...toReadonlyArray(links), ...options.links] : toReadonlyArray(links);\n  const span = tracer.span(name, parent, options?.context ?? empty$1(), linksArray, options?.sampled ?? (parent._tag === \"Some\" ? parent.value.sampled : true), startTime);\n  forEach(annotations, (value, key) => span.attribute(key, value));\n  Object.entries(options?.attributes ?? {}).forEach(([k, v]) => span.attribute(k, v));\n  return span;\n}))))));\n\n/* @internal */\nconst spanAnnotations = /*#__PURE__*/fiberRefGet(currentTracerSpanAnnotations);\n\n/* @internal */\nconst spanLinks = /*#__PURE__*/fiberRefGet(currentTracerSpanLinks);\n\n/** @internal */\nconst useSpan = (name, ...args) => {\n  const options = args.length === 1 ? undefined : args[0];\n  const evaluate = args[args.length - 1];\n  return acquireUseRelease(makeSpan(name, options), evaluate, (span, exit) => flatMap(currentTimeNanosTracing, endTime => sync(() => span.end(endTime, exit))));\n};\n\n/** @internal */\nconst withParentSpan = /*#__PURE__*/dual(2, (self, span) => fiberRefLocallyWith(self, currentTracerSpan, prepend(span)));\n\n/** @internal */\nconst withSpan = /*#__PURE__*/dual(args => typeof args[0] !== \"string\", (self, name, options) => useSpan(name, options ?? {}, span => withParentSpan(self, span)));\n\n// -------------------------------------------------------------------------------------\n// optionality\n// -------------------------------------------------------------------------------------\n\n/* @internal */\nconst fromNullable = value => value == null ? fail$1(NoSuchElementException()) : succeed(value);\n\n/* @internal */\nconst optionFromOptional = self => catchAll(map(self, some), error => isNoSuchElementException(error) ? succeedNone : fail$1(error));\n\nexport { Do, _catch, allowInterrupt, annotateCurrentSpan, annotateLogs, annotateSpans, asSome, asSomeError, asyncOption, bind, bindTo, bindValue, catchAllDefect, catchSomeCause, catchSomeDefect, catchTag, catchTags, cause, clock, clockWith, contextWith, currentParentSpan, currentSpan, currentTimeNanosTracing, delay, descriptor, descriptorWith, diffFiberRefs, diffFiberRefsAndRuntimeFlags, dropUntil, dropWhile, eventually, every, fiberRefs, filterOrDie, filterOrDieMessage, filterOrElse, filterOrFail, findFirst, firstSuccessOf, flipWith, forever, fromNullable, gen, head, ignore, ignoreLogged, inheritFiberRefs, isFailure, isSuccess, iterate, labelMetrics, labelMetricsSet, linkSpans, log, logAnnotations, logDebug, logError, logFatal, logInfo, logTrace, logWarning, loop, makeSpan, mapAccum, mapErrorCause, match, memoize, merge, negate, none, once, option, optionFromOptional, orElseFail, orElseSucceed, parallelErrors, patchFiberRefs, promise, provideService, provideServiceEffect, random, reduce, reduceRight, reduceWhile, repeatN, sandbox, serviceConstants, serviceFunction, serviceFunctionEffect, serviceFunctions, serviceMembers, setFiberRefs, sleep, spanAnnotations, spanLinks, succeedNone, succeedSome, summarized, tagMetrics, takeUntil, takeWhile, tapBoth, tapDefect, tapError, tapErrorCause, tapErrorTag, timed, timedWith, tracer, tracerWith, tryMap, tryMapPromise, tryPromise, try_, unless, unlessEffect, unsandbox, updateFiberRefs, updateService, useSpan, when, whenFiberRef, whenRef, withLogSpan, withMetric, withParentSpan, withSpan };\n","import { exitIsExit, exitIsFailure, exitIsSuccess, exitIsInterrupted, exitAs, exitAsUnit, exitCauseOption, exitCollectAll, exitDie, exitExists, exitFail, exitFailCause, exitFlatMap, exitFlatMapEffect, exitFlatten, exitForEachEffect, exitFromEither, exitFromOption, exitGetOrElse, exitInterrupt, exitMap, exitMapBoth, exitMapError, exitMapErrorCause, exitMatch, exitMatchEffect, exitSucceed, exitUnit, exitZip, exitZipLeft, exitZipRight, exitZipPar, exitZipParLeft, exitZipParRight, exitZipWith } from '../../internal/core.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * An `Exit<E, A>` describes the result of a executing an `Effect` workflow.\n *\n * There are two possible values for an `Exit<E, A>`:\n *   - `Exit.Success` contain a success value of type `A`\n *   - `Exit.Failure` contains a failure `Cause` of type `E`\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Represents a failed `Effect` workflow containing the `Cause` of the failure\n * of type `E`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * Represents a successful `Effect` workflow and containing the returned value\n * of type `A`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Returns `true` if the specified value is an `Exit`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isExit = exitIsExit;\n\n/**\n * Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isFailure = exitIsFailure;\n\n/**\n * Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isSuccess = exitIsSuccess;\n\n/**\n * Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\n * the failure was due to interruption, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isInterrupted = exitIsInterrupted;\n\n/**\n * Maps the `Success` value of the specified exit to the provided constant\n * value.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst as = exitAs;\n\n/**\n * Maps the `Success` value of the specified exit to a void.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst asUnit = exitAsUnit;\n\n/**\n * Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst causeOption = exitCauseOption;\n\n/**\n * Collects all of the specified exit values into a `Some<Exit<E, List<A>>>`. If\n * the provided iterable contains no elements, `None` will be returned.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst all = exitCollectAll;\n\n/**\n * Constructs a new `Exit.Failure` from the specified unrecoverable defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst die = exitDie;\n\n/**\n * Executes the predicate on the value of the specified exit if it is a\n * `Success`, otherwise returns `false`.\n *\n * @since 2.0.0\n * @category elements\n */\nconst exists = exitExists;\n\n/**\n * Constructs a new `Exit.Failure` from the specified recoverable error of type\n * `E`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fail = exitFail;\n\n/**\n * Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failCause = exitFailCause;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = exitFlatMap;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMapEffect = exitFlatMapEffect;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatten = exitFlatten;\n\n/**\n * @since 2.0.0\n * @category traversing\n */\nconst forEachEffect = exitForEachEffect;\n\n/**\n * Converts an `Either<E, A>` into an `Exit<E, A>`.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst fromEither = exitFromEither;\n\n/**\n * Converts an `Option<A>` into an `Exit<void, A>`.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst fromOption = exitFromOption;\n\n/**\n * Returns the `A` if specified exit is a `Success`, otherwise returns the\n * alternate `A` value computed from the specified function which receives the\n * `Cause<E>` of the exit `Failure`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst getOrElse = exitGetOrElse;\n\n/**\n * Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\n * the `Fiber` running an `Effect` workflow was terminated due to interruption.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst interrupt = exitInterrupt;\n\n/**\n * Maps over the `Success` value of the specified exit using the provided\n * function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = exitMap;\n\n/**\n * Maps over the `Success` and `Failure` cases of the specified exit using the\n * provided functions.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapBoth = exitMapBoth;\n\n/**\n * Maps over the error contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapError = exitMapError;\n\n/**\n * Maps over the `Cause` contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapErrorCause = exitMapErrorCause;\n\n/**\n * @since 2.0.0\n * @category folding\n */\nconst match = exitMatch;\n\n/**\n * @since 2.0.0\n * @category folding\n */\nconst matchEffect = exitMatchEffect;\n\n/**\n * Constructs a new `Exit.Success` containing the specified value of type `A`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeed = exitSucceed;\n\n/**\n * Represents an `Exit` which succeeds with `undefined`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unit = exitUnit;\n\n/**\n * Sequentially zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zip = exitZip;\n\n/**\n * Sequentially zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipLeft = exitZipLeft;\n\n/**\n * Sequentially zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipRight = exitZipRight;\n\n/**\n * Parallelly zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipPar = exitZipPar;\n\n/**\n * Parallelly zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipParLeft = exitZipParLeft;\n\n/**\n * Parallelly zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipParRight = exitZipParRight;\n\n/**\n * Zips this exit together with that exit using the specified combination\n * functions.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWith = exitZipWith;\n\nexport { all, as, asUnit, causeOption, die, exists, fail, failCause, flatMap, flatMapEffect, flatten, forEachEffect, fromEither, fromOption, getOrElse, interrupt, isExit, isFailure, isInterrupted, isSuccess, map, mapBoth, mapError, mapErrorCause, match, matchEffect, succeed, unit, zip, zipLeft, zipPar, zipParLeft, zipParRight, zipRight, zipWith };\n","import { dual } from '../Function/dist/effect-Function.esm.js';\n\n/** @internal */\nconst OP_SEQUENTIAL = \"Sequential\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PARALLEL = \"Parallel\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PARALLEL_N = \"ParallelN\";\n\n/** @internal */\n\n/** @internal */\nconst sequential = {\n  _tag: OP_SEQUENTIAL\n};\n\n/** @internal */\nconst parallel = {\n  _tag: OP_PARALLEL\n};\n\n/** @internal */\nconst parallelN = parallelism => ({\n  _tag: OP_PARALLEL_N,\n  parallelism\n});\n\n/** @internal */\nconst isSequential = self => self._tag === OP_SEQUENTIAL;\n\n/** @internal */\nconst isParallel = self => self._tag === OP_PARALLEL;\n\n/** @internal */\nconst isParallelN = self => self._tag === OP_PARALLEL_N;\n\n/** @internal */\nconst match = /*#__PURE__*/dual(4, (self, onSequential, onParallel, onParallelN) => {\n  switch (self._tag) {\n    case OP_SEQUENTIAL:\n      {\n        return onSequential();\n      }\n    case OP_PARALLEL:\n      {\n        return onParallel();\n      }\n    case OP_PARALLEL_N:\n      {\n        return onParallelN(self.parallelism);\n      }\n  }\n});\n\nexport { OP_PARALLEL, OP_PARALLEL_N, OP_SEQUENTIAL, isParallel, isParallelN, isSequential, match, parallel, parallelN, sequential };\n","import { symbol as symbol$1, equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { pipe } from '../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../Hash/dist/effect-Hash.esm.js';\n\nconst FiberStatusSymbolKey = \"effect/FiberStatus\";\n\n/** @internal */\nconst FiberStatusTypeId = /*#__PURE__*/Symbol.for(FiberStatusSymbolKey);\n\n/** @internal */\nconst OP_DONE = \"Done\";\n\n/** @internal */\n\n/** @internal */\nconst OP_RUNNING = \"Running\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SUSPENDED = \"Suspended\";\n\n/** @internal */\n\n/** @internal */\nclass Done {\n  [FiberStatusTypeId] = FiberStatusTypeId;\n  _tag = OP_DONE;\n  [symbol]() {\n    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)));\n  }\n  [symbol$1](that) {\n    return isFiberStatus(that) && that._tag === OP_DONE;\n  }\n}\n\n/** @internal */\nclass Running {\n  [FiberStatusTypeId] = FiberStatusTypeId;\n  _tag = OP_RUNNING;\n  constructor(runtimeFlags) {\n    this.runtimeFlags = runtimeFlags;\n  }\n  [symbol]() {\n    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)));\n  }\n  [symbol$1](that) {\n    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;\n  }\n}\n\n/** @internal */\nclass Suspended {\n  [FiberStatusTypeId] = FiberStatusTypeId;\n  _tag = OP_SUSPENDED;\n  constructor(runtimeFlags, blockingOn) {\n    this.runtimeFlags = runtimeFlags;\n    this.blockingOn = blockingOn;\n  }\n  [symbol]() {\n    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)));\n  }\n  [symbol$1](that) {\n    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);\n  }\n}\n\n/** @internal */\nconst done = /*#__PURE__*/new Done();\n\n/** @internal */\nconst running = runtimeFlags => new Running(runtimeFlags);\n\n/** @internal */\nconst suspended = (runtimeFlags, blockingOn) => new Suspended(runtimeFlags, blockingOn);\n\n/** @internal */\nconst isFiberStatus = u => typeof u === \"object\" && u != null && FiberStatusTypeId in u;\n\n/** @internal */\nconst isDone = self => self._tag === OP_DONE;\n\n/** @internal */\nconst isRunning = self => self._tag === OP_RUNNING;\n\n/** @internal */\nconst isSuspended = self => self._tag === OP_SUSPENDED;\n\nexport { FiberStatusTypeId, OP_DONE, OP_RUNNING, OP_SUSPENDED, done, isDone, isFiberStatus, isRunning, isSuspended, running, suspended };\n","import { FiberStatusTypeId as FiberStatusTypeId$1, done as done$1, running as running$1, suspended as suspended$1, isFiberStatus as isFiberStatus$1, isDone as isDone$1, isRunning as isRunning$1, isSuspended as isSuspended$1 } from '../../internal/fiberStatus.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst FiberStatusTypeId = FiberStatusTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst done = done$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst running = running$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst suspended = suspended$1;\n\n/**\n * Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isFiberStatus = isFiberStatus$1;\n\n/**\n * Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isDone = isDone$1;\n\n/**\n * Returns `true` if the specified `FiberStatus` is `Running`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isRunning = isRunning$1;\n\n/**\n * Returns `true` if the specified `FiberStatus` is `Suspended`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isSuspended = isSuspended$1;\n\nexport { FiberStatusTypeId, done, isDone, isFiberStatus, isRunning, isSuspended, running, suspended };\n","/** @internal */\n\n/** @internal */\nconst OP_INTERRUPT_SIGNAL = \"InterruptSignal\";\n\n/** @internal */\n\n/** @internal */\nconst OP_STATEFUL = \"Stateful\";\n\n/** @internal */\n\n/** @internal */\nconst OP_RESUME = \"Resume\";\n\n/** @internal */\n\n/** @internal */\nconst OP_YIELD_NOW = \"YieldNow\";\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst interruptSignal = cause => ({\n  _tag: OP_INTERRUPT_SIGNAL,\n  cause\n});\n\n/** @internal */\nconst stateful = onFiber => ({\n  _tag: OP_STATEFUL,\n  onFiber\n});\n\n/** @internal */\nconst resume = effect => ({\n  _tag: OP_RESUME,\n  effect\n});\n\n/** @internal */\nconst yieldNow = () => ({\n  _tag: OP_YIELD_NOW\n});\n\nexport { OP_INTERRUPT_SIGNAL, OP_RESUME, OP_STATEFUL, OP_YIELD_NOW, interruptSignal, resume, stateful, yieldNow };\n","import { none } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { stateful } from './fiberMessage.esm.js';\n\n/** @internal */\nconst FiberScopeSymbolKey = \"effect/FiberScope\";\n\n/** @internal */\nconst FiberScopeTypeId = /*#__PURE__*/Symbol.for(FiberScopeSymbolKey);\n\n/**\n * A `FiberScope` represents the scope of a fiber lifetime. The scope of a\n * fiber can be retrieved using `Effect.descriptor`, and when forking fibers,\n * you can specify a custom scope to fork them on by using the `forkIn`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/** @internal */\nclass Global {\n  [FiberScopeTypeId] = FiberScopeTypeId;\n  fiberId = none;\n  roots = new Set();\n  add(_runtimeFlags, child) {\n    this.roots.add(child);\n    child.addObserver(() => {\n      this.roots.delete(child);\n    });\n  }\n}\n\n/** @internal */\nclass Local {\n  [FiberScopeTypeId] = FiberScopeTypeId;\n  constructor(fiberId, parent) {\n    this.fiberId = fiberId;\n    this.parent = parent;\n  }\n  add(_runtimeFlags, child) {\n    this.parent.tell(stateful(parentFiber => {\n      parentFiber.addChild(child);\n      child.addObserver(() => {\n        parentFiber.removeChild(child);\n      });\n    }));\n  }\n}\n\n/** @internal */\nconst unsafeMake = fiber => {\n  return new Local(fiber.id(), fiber);\n};\n\n/** @internal */\nconst globalScope = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberScope/Global\"), () => new Global());\n\nexport { FiberScopeTypeId, globalScope, unsafeMake };\n","import { currentTimeMillis } from '../Clock/dist/effect-Clock.esm.js';\nimport { left, right } from '../Either/dist/effect-Either.esm.js';\nimport { fail as fail$1, failCause as failCause$1, interrupt, forEachEffect, match as match$1, isSuccess, succeed as succeed$2 } from '../Exit/dist/effect-Exit.esm.js';\nimport { none, getOrElse, ids } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { isSuspended, isDone, isRunning } from '../FiberStatus/dist/effect-FiberStatus.esm.js';\nimport { pipe, dual } from '../Function/dist/effect-Function.esm.js';\nimport { size } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { succeed as succeed$1, unit as unit$1, map as map$1, forEachSequential, exit, flatMap, fiberId, zipRight, forEachSequentialDiscard, zipLeft, flatten, sync, never as never$1, zipWith, asUnit, interruptAsFiber } from './core.esm.js';\nimport { globalScope } from './fiberScope.esm.js';\nimport { interruptible } from './runtimeFlags.esm.js';\nimport { Order as Order$1 } from '../Number/dist/effect-Number.esm.js';\nimport { some, none as none$1, fromNullable } from '../Option/dist/effect-Option.esm.js';\nimport { mapInput, tuple } from '../Order/dist/effect-Order.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst FiberSymbolKey = \"effect/Fiber\";\n\n/** @internal */\nconst FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);\n\n/** @internal */\nconst fiberVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\nconst fiberProto = {\n  [FiberTypeId]: fiberVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst RuntimeFiberSymbolKey = \"effect/Fiber\";\n\n/** @internal */\nconst RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);\n\n/** @internal */\nconst Order = /*#__PURE__*/pipe( /*#__PURE__*/tuple(Order$1, Order$1), /*#__PURE__*/mapInput(fiber => [fiber.id().startTimeMillis, fiber.id().id]));\n\n/** @internal */\nconst isFiber = u => typeof u === \"object\" && u != null && FiberTypeId in u;\n\n/** @internal */\nconst isRuntimeFiber = self => RuntimeFiberTypeId in self;\n\n/** @internal */\nconst _await = self => self.await();\n\n/** @internal */\nconst children = self => self.children();\n\n/** @internal */\nconst done = exit => ({\n  ...fiberProto,\n  id: () => none,\n  await: () => succeed$1(exit),\n  children: () => succeed$1([]),\n  inheritAll: () => unit$1,\n  poll: () => succeed$1(some(exit)),\n  interruptAsFork: () => unit$1\n});\n\n/** @internal */\nconst dump = self => map$1(self.status(), status => ({\n  id: self.id(),\n  status\n}));\n\n/** @internal */\nconst dumpAll = fibers => forEachSequential(fibers, dump);\n\n/** @internal */\nconst fail = error => done(fail$1(error));\n\n/** @internal */\nconst failCause = cause => done(failCause$1(cause));\n\n/** @internal */\nconst fromEffect = effect => map$1(exit(effect), done);\n\n/** @internal */\nconst id = self => self.id();\n\n/** @internal */\nconst inheritAll = self => self.inheritAll();\n\n/** @internal */\nconst interrupted = fiberId => done(interrupt(fiberId));\n\n/** @internal */\nconst interruptAll = fibers => flatMap(fiberId, fiberId => pipe(fibers, interruptAllAs(fiberId)));\n\n/** @internal */\nconst interruptAllAs = /*#__PURE__*/dual(2, (fibers, fiberId) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId)), zipRight(pipe(fibers, forEachSequentialDiscard(_await)))));\n\n/** @internal */\nconst interruptAsFork = /*#__PURE__*/dual(2, (self, fiberId) => self.interruptAsFork(fiberId));\n\n/** @internal */\nconst join = self => zipLeft(flatten(self.await()), self.inheritAll());\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => mapEffect(self, a => sync(() => f(a))));\n\n/** @internal */\nconst mapEffect = /*#__PURE__*/dual(2, (self, f) => ({\n  ...fiberProto,\n  id: () => self.id(),\n  await: () => flatMap(self.await(), forEachEffect(f)),\n  children: () => self.children(),\n  inheritAll: () => self.inheritAll(),\n  poll: () => flatMap(self.poll(), result => {\n    switch (result._tag) {\n      case \"None\":\n        {\n          return succeed$1(none$1());\n        }\n      case \"Some\":\n        {\n          return pipe(forEachEffect(result.value, f), map$1(some));\n        }\n    }\n  }),\n  interruptAsFork: id => self.interruptAsFork(id)\n}));\n\n/** @internal */\nconst mapFiber = /*#__PURE__*/dual(2, (self, f) => map$1(self.await(), match$1({\n  onFailure: cause => failCause(cause),\n  onSuccess: a => f(a)\n})));\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onFiber,\n  onRuntimeFiber\n}) => {\n  if (isRuntimeFiber(self)) {\n    return onRuntimeFiber(self);\n  }\n  return onFiber(self);\n});\n\n/** @internal */\nconst never = {\n  ...fiberProto,\n  id: () => none,\n  await: () => never$1,\n  children: () => succeed$1([]),\n  inheritAll: () => never$1,\n  poll: () => succeed$1(none$1()),\n  interruptAsFork: () => never$1\n};\n\n/** @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => ({\n  ...fiberProto,\n  id: () => getOrElse(self.id(), that.id()),\n  await: () => zipWith(self.await(), that.await(), (exit1, exit2) => isSuccess(exit1) ? exit1 : exit2),\n  children: () => self.children(),\n  inheritAll: () => zipRight(that.inheritAll(), self.inheritAll()),\n  poll: () => zipWith(self.poll(), that.poll(), (option1, option2) => {\n    switch (option1._tag) {\n      case \"None\":\n        {\n          return none$1();\n        }\n      case \"Some\":\n        {\n          return isSuccess(option1.value) ? option1 : option2;\n        }\n    }\n  }),\n  interruptAsFork: id => pipe(interruptAsFiber(self, id), zipRight(pipe(that, interruptAsFiber(id))), asUnit)\n}));\n\n/** @internal */\nconst orElseEither = /*#__PURE__*/dual(2, (self, that) => orElse(map(self, left), map(that, right)));\n\n/** @internal */\nconst poll = self => self.poll();\n\n// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js\n// MIT License\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n/** @internal */\nconst parseMs = milliseconds => {\n  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;\n  return {\n    days: roundTowardsZero(milliseconds / 86400000),\n    hours: roundTowardsZero(milliseconds / 3600000) % 24,\n    minutes: roundTowardsZero(milliseconds / 60000) % 60,\n    seconds: roundTowardsZero(milliseconds / 1000) % 60,\n    milliseconds: roundTowardsZero(milliseconds) % 1000,\n    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,\n    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000\n  };\n};\n\n/** @internal */\nconst renderStatus = status => {\n  if (isDone(status)) {\n    return \"Done\";\n  }\n  if (isRunning(status)) {\n    return \"Running\";\n  }\n  const isInterruptible = interruptible(status.runtimeFlags) ? \"interruptible\" : \"uninterruptible\";\n  return `Suspended(${isInterruptible})`;\n};\n\n/** @internal */\nconst pretty = self => flatMap(currentTimeMillis, now => map$1(dump(self), dump => {\n  const time = now - dump.id.startTimeMillis;\n  const {\n    days,\n    hours,\n    milliseconds,\n    minutes,\n    seconds\n  } = parseMs(time);\n  const lifeMsg = (days === 0 ? \"\" : `${days}d`) + (days === 0 && hours === 0 ? \"\" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? \"\" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? \"\" : `${seconds}s`) + `${milliseconds}ms`;\n  const waitMsg = isSuspended(dump.status) ? (() => {\n    const ids$1 = ids(dump.status.blockingOn);\n    return size(ids$1) > 0 ? `waiting on ` + Array.from(ids$1).map(id => `${id}`).join(\", \") : \"\";\n  })() : \"\";\n  const statusMsg = renderStatus(dump.status);\n  return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\\n   Status: ${statusMsg}`;\n}));\n\n/** @internal */\nconst unsafeRoots = () => Array.from(globalScope.roots);\n\n/** @internal */\nconst roots = /*#__PURE__*/sync(unsafeRoots);\n\n/** @internal */\nconst status = self => self.status();\n\n/** @internal */\nconst succeed = value => done(succeed$2(value));\n\n/** @internal */\nconst unit = /*#__PURE__*/succeed(void 0);\n\n/** @internal */\nconst currentFiberURI = \"effect/FiberCurrent\";\n\n/** @internal */\nconst getCurrentFiber = () => fromNullable(globalThis[currentFiberURI]);\n\nexport { FiberTypeId, Order, RuntimeFiberTypeId, _await, children, currentFiberURI, done, dump, dumpAll, fail, failCause, fiberVariance, fromEffect, getCurrentFiber, id, inheritAll, interruptAll, interruptAllAs, interruptAsFork, interrupted, isFiber, isRuntimeFiber, join, map, mapEffect, mapFiber, match, never, orElse, orElseEither, poll, pretty, roots, status, succeed, unit, unsafeRoots };\n","import { deferredMake, deferredMakeAs, deferredAwait, deferredComplete, deferredCompleteWith, deferredDone, deferredFail, deferredFailSync, deferredFailCause, deferredFailCauseSync, deferredDie, deferredDieSync, deferredInterrupt, deferredInterruptWith, deferredIsDone, deferredPoll, deferredSucceed, deferredSync, deferredUnsafeMake, deferredUnsafeDone } from '../../internal/core.esm.js';\nimport { DeferredTypeId as DeferredTypeId$1 } from '../../internal/deferred.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst DeferredTypeId = DeferredTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * A `Deferred` represents an asynchronous variable that can be set exactly\n * once, with the ability for an arbitrary number of fibers to suspend (by\n * calling `Deferred.await`) and automatically resume when the variable is set.\n *\n * `Deferred` can be used for building primitive actions whose completions\n * require the coordinated action of multiple fibers, and for building\n * higher-level concurrent or asynchronous structures.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Creates a new `Deferred`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = deferredMake;\n\n/**\n * Creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst makeAs = deferredMakeAs;\nconst _await = deferredAwait;\n\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * Note that `Deferred.completeWith` will be much faster, so consider using\n * that if you do not need to memoize the result of the specified effect.\n *\n * @since 2.0.0\n * @category utils\n */\nconst complete = deferredComplete;\n\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * @since 2.0.0\n * @category utils\n */\nconst completeWith = deferredCompleteWith;\n\n/**\n * Exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst done = deferredDone;\n\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst fail = deferredFail;\n\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst failSync = deferredFailSync;\n\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst failCause = deferredFailCause;\n\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst failCauseSync = deferredFailCauseSync;\n\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst die = deferredDie;\n\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst dieSync = deferredDieSync;\n\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the `FiberId` of the fiber\n * calling this method.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interrupt = deferredInterrupt;\n\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the specified `FiberId`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interruptWith = deferredInterruptWith;\n\n/**\n * Returns `true` if this `Deferred` has already been completed with a value or\n * an error, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isDone = deferredIsDone;\n\n/**\n * Returns a `Some<Effect<R, E, A>>` from the `Deferred` if this `Deferred` has\n * already been completed, `None` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst poll = deferredPoll;\n\n/**\n * Completes the `Deferred` with the specified value.\n *\n * @since 2.0.0\n * @category utils\n */\nconst succeed = deferredSucceed;\n\n/**\n * Completes the `Deferred` with the specified lazily evaluated value.\n *\n * @since 2.0.0\n * @category utils\n */\nconst sync = deferredSync;\n\n/**\n * Unsafely creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeMake = deferredUnsafeMake;\n\n/**\n * Unsafely exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeDone = deferredUnsafeDone;\n\nexport { DeferredTypeId, _await as await, complete, completeWith, die, dieSync, done, fail, failCause, failCauseSync, failSync, interrupt, interruptWith, isDone, make, makeAs, poll, succeed, sync, unsafeDone, unsafeMake };\n","import { sequential as sequential$1, parallel as parallel$1, parallelN as parallelN$1, isSequential as isSequential$1, isParallel as isParallel$1, isParallelN as isParallelN$1, match as match$1 } from '../../internal/executionStrategy.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Describes a strategy for evaluating multiple effects, potentially in\n * parallel.\n *\n * There are 3 possible execution strategies: `Sequential`, `Parallel`,\n * `ParallelN`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Execute effects sequentially.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Execute effects in parallel.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Execute effects in parallel, up to the specified number of concurrent fibers.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Execute effects sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst sequential = sequential$1;\n\n/**\n * Execute effects in parallel.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst parallel = parallel$1;\n\n/**\n * Execute effects in parallel, up to the specified number of concurrent fibers.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst parallelN = parallelN$1;\n\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isSequential = isSequential$1;\n\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isParallel = isParallel$1;\n\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isParallelN = isParallelN$1;\n\n/**\n * Folds over the specified `ExecutionStrategy` using the provided case\n * functions.\n *\n * @since 2.0.0\n * @category folding\n */\nconst match = match$1;\n\nexport { isParallel, isParallelN, isSequential, match, parallel, parallelN, sequential };\n","import { empty as empty$1, diff as diff$1, combine as combine$1, patch as patch$1 } from '../../internal/fiberRefs/patch.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * A `FiberRefsPatch` captures the changes in `FiberRef` values made by a single\n * fiber as a value. This allows fibers to apply the changes made by a workflow\n * without inheriting all the `FiberRef` values of the fiber that executed the\n * workflow.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Constructs a patch that describes the changes between the specified\n * collections of `FiberRef`\n *\n * @since 2.0.0\n * @category constructors\n */\nconst diff = diff$1;\n\n/**\n * Combines this patch and the specified patch to create a new patch that\n * describes applying the changes from this patch and the specified patch\n * sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst combine = combine$1;\n\n/**\n * Applies the changes described by this patch to the specified collection\n * of `FiberRef` values.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst patch = patch$1;\n\nexport { combine, diff, empty, patch };\n","import { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { fiberRefUnsafeMake } from './core.esm.js';\n\n/** @internal */\nconst currentRequestMap = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentRequestMap\"), () => fiberRefUnsafeMake(new Map()));\n\nexport { currentRequestMap };\n","import { fiberRefGetWith, currentConcurrency } from './core.esm.js';\n\n/** @internal */\nconst match = (options, sequential, unbounded, bounded) => {\n  switch (options?.concurrency) {\n    case undefined:\n      {\n        return sequential();\n      }\n    case \"unbounded\":\n      {\n        return unbounded();\n      }\n    case \"inherit\":\n      {\n        return fiberRefGetWith(currentConcurrency, concurrency => concurrency === \"unbounded\" ? unbounded() : concurrency > 1 ? bounded(concurrency) : sequential());\n      }\n    default:\n      {\n        return options.concurrency > 1 ? bounded(options.concurrency) : sequential();\n      }\n  }\n};\n\n/** @internal */\nconst matchSimple = (options, sequential, concurrent) => {\n  switch (options?.concurrency) {\n    case undefined:\n      {\n        return sequential();\n      }\n    case \"unbounded\":\n      {\n        return concurrent();\n      }\n    case \"inherit\":\n      {\n        return fiberRefGetWith(currentConcurrency, concurrency => concurrency === \"unbounded\" ? concurrent() : concurrency > 1 ? concurrent() : sequential());\n      }\n    default:\n      {\n        return options.concurrency > 1 ? concurrent() : sequential();\n      }\n  }\n};\n\nexport { match, matchSimple };\n","import { dual, constVoid, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { size } from '../HashMap/dist/effect-HashMap.esm.js';\nimport { pretty } from './cause.esm.js';\nimport { threadName } from './fiberId.esm.js';\nimport { isCons } from '../List/dist/effect-List.esm.js';\nimport { render } from '../LogSpan/dist/effect-LogSpan.esm.js';\nimport { some, none as none$1 } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst LoggerSymbolKey = \"effect/Logger\";\n\n/** @internal */\nconst LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);\n\n/** @internal */\nconst loggerVariance = {\n  _Message: _ => _,\n  _Output: _ => _\n};\n\n/** @internal */\nconst makeLogger = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n\n/** @internal */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => self.log({\n  ...options,\n  message: f(options.message)\n})));\n\n/** @internal */\nconst filterLogLevel = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => f(options.logLevel) ? some(self.log(options)) : none$1()));\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => f(self.log(options))));\n\n/** @internal */\nconst none = {\n  [LoggerTypeId]: loggerVariance,\n  log: constVoid,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst simple = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log: ({\n    message\n  }) => log(message),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n\n/** @internal */\nconst succeed = value => {\n  return simple(() => value);\n};\n\n/** @internal */\nconst sync = evaluate => {\n  return simple(evaluate);\n};\n\n/** @internal */\nconst zip = /*#__PURE__*/dual(2, (self, that) => makeLogger(options => [self.log(options), that.log(options)]));\n\n/** @internal */\nconst zipLeft = /*#__PURE__*/dual(2, (self, that) => map(zip(self, that), tuple => tuple[0]));\n\n/** @internal */\nconst zipRight = /*#__PURE__*/dual(2, (self, that) => map(zip(self, that), tuple => tuple[1]));\n\n/** @internal */\nconst stringLogger = /*#__PURE__*/makeLogger(({\n  annotations,\n  cause,\n  date,\n  fiberId,\n  logLevel,\n  message,\n  spans\n}) => {\n  const nowMillis = date.getTime();\n  const outputArray = [`timestamp=${date.toISOString()}`, `level=${logLevel.label}`, `fiber=${threadName(fiberId)}`];\n  let output = outputArray.join(\" \");\n  const stringMessage = serializeUnknown(message);\n  if (stringMessage.length > 0) {\n    output = output + \" message=\";\n    output = appendQuoted(stringMessage, output);\n  }\n  if (cause != null && cause._tag !== \"Empty\") {\n    output = output + \" cause=\";\n    output = appendQuoted(pretty(cause), output);\n  }\n  if (isCons(spans)) {\n    output = output + \" \";\n    let first = true;\n    for (const span of spans) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + pipe(span, render(nowMillis));\n    }\n  }\n  if (pipe(annotations, size) > 0) {\n    output = output + \" \";\n    let first = true;\n    for (const [key, value] of annotations) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + filterKeyName(key);\n      output = output + \"=\";\n      output = appendQuoted(serializeUnknown(value), output);\n    }\n  }\n  return output;\n});\nconst serializeUnknown = u => {\n  try {\n    return typeof u === \"object\" ? JSON.stringify(u) : String(u);\n  } catch (_) {\n    return String(u);\n  }\n};\n\n/** @internal */\nconst escapeDoubleQuotes = str => `\"${str.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\")}\"`;\nconst textOnly = /^[^\\s\"=]+$/;\n\n/** @internal */\nconst appendQuoted = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotes(label));\n\n/** @internal */\nconst logfmtLogger = /*#__PURE__*/makeLogger(({\n  annotations,\n  cause,\n  date,\n  fiberId,\n  logLevel,\n  message,\n  spans\n}) => {\n  const nowMillis = date.getTime();\n  const outputArray = [`timestamp=${date.toISOString()}`, `level=${logLevel.label}`, `fiber=${threadName(fiberId)}`];\n  let output = outputArray.join(\" \");\n  const stringMessage = serializeUnknown(message);\n  if (stringMessage.length > 0) {\n    output = output + \" message=\";\n    output = appendQuotedLogfmt(stringMessage, output);\n  }\n  if (cause != null && cause._tag !== \"Empty\") {\n    output = output + \" cause=\";\n    output = appendQuotedLogfmt(pretty(cause), output);\n  }\n  if (isCons(spans)) {\n    output = output + \" \";\n    let first = true;\n    for (const span of spans) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + pipe(span, renderLogSpanLogfmt(nowMillis));\n    }\n  }\n  if (pipe(annotations, size) > 0) {\n    output = output + \" \";\n    let first = true;\n    for (const [key, value] of annotations) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + filterKeyName(key);\n      output = output + \"=\";\n      output = appendQuotedLogfmt(serializeUnknown(value), output);\n    }\n  }\n  return output;\n});\n\n/** @internal */\nconst filterKeyName = key => key.replace(/[\\s=\"]/g, \"_\");\n\n/** @internal */\nconst escapeDoubleQuotesLogfmt = str => JSON.stringify(str);\n\n/** @internal */\nconst appendQuotedLogfmt = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotesLogfmt(label));\n\n/** @internal */\nconst renderLogSpanLogfmt = now => self => {\n  const label = filterKeyName(self.label);\n  return `${label}=${now - self.startTime}ms`;\n};\n\nexport { LoggerTypeId, filterLogLevel, logfmtLogger, makeLogger, map, mapInput, none, serializeUnknown, simple, stringLogger, succeed, sync, zip, zipLeft, zipRight };\n","import { dedupe, appendAll, of, unsafeFromArray } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { symbol as symbol$1, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../../Hash/dist/effect-Hash.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { makeBy } from '../../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nconst MetricBoundariesSymbolKey = \"effect/MetricBoundaries\";\n\n/** @internal */\nconst MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);\n\n/** @internal */\nclass MetricBoundariesImpl {\n  [MetricBoundariesTypeId] = MetricBoundariesTypeId;\n  constructor(values) {\n    this.values = values;\n  }\n  [symbol]() {\n    return pipe(hash(MetricBoundariesSymbolKey), combine(hash(this.values)));\n  }\n  [symbol$1](u) {\n    return isMetricBoundaries(u) && equals(this.values, u.values);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst isMetricBoundaries = u => {\n  return typeof u === \"object\" && u != null && MetricBoundariesTypeId in u;\n};\n\n/** @internal */\nconst fromChunk = chunk => {\n  const values = pipe(chunk, appendAll(of(Number.POSITIVE_INFINITY)), dedupe);\n  return new MetricBoundariesImpl(values);\n};\n\n/** @internal */\nconst linear = options => pipe(makeBy(options.count - 1, i => options.start + i * options.width), unsafeFromArray, fromChunk);\n\n/** @internal */\nconst exponential = options => pipe(makeBy(options.count - 1, i => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromChunk);\n\nexport { MetricBoundariesTypeId, exponential, fromChunk, isMetricBoundaries, linear };\n","import { decode } from '../../Duration/dist/effect-Duration.esm.js';\nimport { symbol as symbol$1, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, hash, combine } from '../../Hash/dist/effect-Hash.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst MetricKeyTypeSymbolKey = \"effect/MetricKeyType\";\n\n/** @internal */\nconst MetricKeyTypeTypeId = /*#__PURE__*/Symbol.for(MetricKeyTypeSymbolKey);\n\n/** @internal */\nconst CounterKeyTypeSymbolKey = \"effect/MetricKeyType/Counter\";\n\n/** @internal */\nconst CounterKeyTypeTypeId = /*#__PURE__*/Symbol.for(CounterKeyTypeSymbolKey);\n\n/** @internal */\nconst FrequencyKeyTypeSymbolKey = \"effect/MetricKeyType/Frequency\";\n\n/** @internal */\nconst FrequencyKeyTypeTypeId = /*#__PURE__*/Symbol.for(FrequencyKeyTypeSymbolKey);\n\n/** @internal */\nconst GaugeKeyTypeSymbolKey = \"effect/MetricKeyType/Gauge\";\n\n/** @internal */\nconst GaugeKeyTypeTypeId = /*#__PURE__*/Symbol.for(GaugeKeyTypeSymbolKey);\n\n/** @internal */\nconst HistogramKeyTypeSymbolKey = \"effect/MetricKeyType/Histogram\";\n\n/** @internal */\nconst HistogramKeyTypeTypeId = /*#__PURE__*/Symbol.for(HistogramKeyTypeSymbolKey);\n\n/** @internal */\nconst SummaryKeyTypeSymbolKey = \"effect/MetricKeyType/Summary\";\n\n/** @internal */\nconst SummaryKeyTypeTypeId = /*#__PURE__*/Symbol.for(SummaryKeyTypeSymbolKey);\n\n/** @internal */\nconst metricKeyTypeVariance = {\n  _In: _ => _,\n  _Out: _ => _\n};\n\n/** @internal */\nclass CounterKeyType {\n  [MetricKeyTypeTypeId] = metricKeyTypeVariance;\n  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;\n  constructor(incremental, bigint) {\n    this.incremental = incremental;\n    this.bigint = bigint;\n  }\n  [symbol]() {\n    return hash(CounterKeyTypeSymbolKey);\n  }\n  [symbol$1](that) {\n    return isCounterKey(that);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass FrequencyKeyType {\n  [MetricKeyTypeTypeId] = metricKeyTypeVariance;\n  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;\n  [symbol]() {\n    return hash(FrequencyKeyTypeSymbolKey);\n  }\n  [symbol$1](that) {\n    return isFrequencyKey(that);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass GaugeKeyType {\n  [MetricKeyTypeTypeId] = metricKeyTypeVariance;\n  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;\n  constructor(bigint) {\n    this.bigint = bigint;\n  }\n  [symbol]() {\n    return hash(GaugeKeyTypeSymbolKey);\n  }\n  [symbol$1](that) {\n    return isGaugeKey(that);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/**\n * @category model\n * @since 2.0.0\n */\nclass HistogramKeyType {\n  [MetricKeyTypeTypeId] = metricKeyTypeVariance;\n  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;\n  constructor(boundaries) {\n    this.boundaries = boundaries;\n  }\n  [symbol]() {\n    return pipe(hash(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));\n  }\n  [symbol$1](that) {\n    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass SummaryKeyType {\n  [MetricKeyTypeTypeId] = metricKeyTypeVariance;\n  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;\n  constructor(maxAge, maxSize, error, quantiles) {\n    this.maxAge = maxAge;\n    this.maxSize = maxSize;\n    this.error = error;\n    this.quantiles = quantiles;\n  }\n  [symbol]() {\n    return pipe(hash(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(hash(this.quantiles)));\n  }\n  [symbol$1](that) {\n    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst counter = options => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst frequency = /*#__PURE__*/new FrequencyKeyType();\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst gauge = options => new GaugeKeyType(options?.bigint ?? false);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst histogram = boundaries => {\n  return new HistogramKeyType(boundaries);\n};\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst summary = options => {\n  return new SummaryKeyType(decode(options.maxAge), options.maxSize, options.error, options.quantiles);\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isMetricKeyType = u => {\n  return typeof u === \"object\" && u != null && MetricKeyTypeTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isCounterKey = u => {\n  return typeof u === \"object\" && u != null && CounterKeyTypeTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isFrequencyKey = u => {\n  return typeof u === \"object\" && u != null && FrequencyKeyTypeTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isGaugeKey = u => {\n  return typeof u === \"object\" && u != null && GaugeKeyTypeTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isHistogramKey = u => {\n  return typeof u === \"object\" && u != null && HistogramKeyTypeTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isSummaryKey = u => {\n  return typeof u === \"object\" && u != null && SummaryKeyTypeTypeId in u;\n};\n\nexport { CounterKeyTypeTypeId, FrequencyKeyTypeTypeId, GaugeKeyTypeTypeId, HistogramKeyType, HistogramKeyTypeTypeId, MetricKeyTypeTypeId, SummaryKeyTypeTypeId, counter, frequency, gauge, histogram, isCounterKey, isFrequencyKey, isGaugeKey, isHistogramKey, isMetricKeyType, isSummaryKey, summary };\n","import { symbol as symbol$1, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { dual, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../../Hash/dist/effect-Hash.esm.js';\nimport { make, fromIterable, size, union, empty } from '../../HashSet/dist/effect-HashSet.esm.js';\nimport { counter as counter$1, frequency as frequency$1, gauge as gauge$1, histogram as histogram$1, summary as summary$1 } from './keyType.esm.js';\nimport { make as make$1 } from './label.esm.js';\nimport { fromNullable } from '../../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst MetricKeySymbolKey = \"effect/MetricKey\";\n\n/** @internal */\nconst MetricKeyTypeId = /*#__PURE__*/Symbol.for(MetricKeySymbolKey);\n\n/** @internal */\nconst metricKeyVariance = {\n  _Type: _ => _\n};\n\n/** @internal */\nclass MetricKeyImpl {\n  [MetricKeyTypeId] = metricKeyVariance;\n  constructor(name, keyType, description, tags = empty()) {\n    this.name = name;\n    this.keyType = keyType;\n    this.description = description;\n    this.tags = tags;\n  }\n  [symbol]() {\n    return pipe(hash(this.name), combine(hash(this.keyType)), combine(hash(this.description)), combine(hash(this.tags)));\n  }\n  [symbol$1](u) {\n    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && equals(this.tags, u.tags);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst isMetricKey = u => typeof u === \"object\" && u != null && MetricKeyTypeId in u;\n\n/** @internal */\nconst counter = (name, options) => new MetricKeyImpl(name, counter$1(options), fromNullable(options?.description));\n\n/** @internal */\nconst frequency = (name, description) => new MetricKeyImpl(name, frequency$1, fromNullable(description));\n\n/** @internal */\nconst gauge = (name, options) => new MetricKeyImpl(name, gauge$1(options), fromNullable(options?.description));\n\n/** @internal */\nconst histogram = (name, boundaries, description) => new MetricKeyImpl(name, histogram$1(boundaries), fromNullable(description));\n\n/** @internal */\nconst summary = options => new MetricKeyImpl(options.name, summary$1(options), fromNullable(options.description));\n\n/** @internal */\nconst tagged = /*#__PURE__*/dual(3, (self, key, value) => taggedWithLabelSet(self, make(make$1(key, value))));\n\n/** @internal */\nconst taggedWithLabels = /*#__PURE__*/dual(2, (self, extraTags) => taggedWithLabelSet(self, fromIterable(extraTags)));\n\n/** @internal */\nconst taggedWithLabelSet = /*#__PURE__*/dual(2, (self, extraTags) => size(extraTags) === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, pipe(self.tags, union(extraTags))));\n\nexport { MetricKeyTypeId, counter, frequency, gauge, histogram, isMetricKey, summary, tagged, taggedWithLabelSet, taggedWithLabels };\n","import { symbol as symbol$1, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../../Hash/dist/effect-Hash.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst MetricStateSymbolKey = \"effect/MetricState\";\n\n/** @internal */\nconst MetricStateTypeId = /*#__PURE__*/Symbol.for(MetricStateSymbolKey);\n\n/** @internal */\nconst CounterStateSymbolKey = \"effect/MetricState/Counter\";\n\n/** @internal */\nconst CounterStateTypeId = /*#__PURE__*/Symbol.for(CounterStateSymbolKey);\n\n/** @internal */\nconst FrequencyStateSymbolKey = \"effect/MetricState/Frequency\";\n\n/** @internal */\nconst FrequencyStateTypeId = /*#__PURE__*/Symbol.for(FrequencyStateSymbolKey);\n\n/** @internal */\nconst GaugeStateSymbolKey = \"effect/MetricState/Gauge\";\n\n/** @internal */\nconst GaugeStateTypeId = /*#__PURE__*/Symbol.for(GaugeStateSymbolKey);\n\n/** @internal */\nconst HistogramStateSymbolKey = \"effect/MetricState/Histogram\";\n\n/** @internal */\nconst HistogramStateTypeId = /*#__PURE__*/Symbol.for(HistogramStateSymbolKey);\n\n/** @internal */\nconst SummaryStateSymbolKey = \"effect/MetricState/Summary\";\n\n/** @internal */\nconst SummaryStateTypeId = /*#__PURE__*/Symbol.for(SummaryStateSymbolKey);\n\n/** @internal */\nconst metricStateVariance = {\n  _A: _ => _\n};\n\n/** @internal */\nclass CounterState {\n  [MetricStateTypeId] = metricStateVariance;\n  [CounterStateTypeId] = CounterStateTypeId;\n  constructor(count) {\n    this.count = count;\n  }\n  [symbol]() {\n    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)));\n  }\n  [symbol$1](that) {\n    return isCounterState(that) && this.count === that.count;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass FrequencyState {\n  [MetricStateTypeId] = metricStateVariance;\n  [FrequencyStateTypeId] = FrequencyStateTypeId;\n  constructor(occurrences) {\n    this.occurrences = occurrences;\n  }\n  [symbol]() {\n    return pipe(hash(FrequencyStateSymbolKey), combine(hash(this.occurrences)));\n  }\n  [symbol$1](that) {\n    return isFrequencyState(that) && equals(this.occurrences, that.occurrences);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass GaugeState {\n  [MetricStateTypeId] = metricStateVariance;\n  [GaugeStateTypeId] = GaugeStateTypeId;\n  constructor(value) {\n    this.value = value;\n  }\n  [symbol]() {\n    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)));\n  }\n  [symbol$1](u) {\n    return isGaugeState(u) && this.value === u.value;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass HistogramState {\n  [MetricStateTypeId] = metricStateVariance;\n  [HistogramStateTypeId] = HistogramStateTypeId;\n  constructor(buckets, count, min, max, sum) {\n    this.buckets = buckets;\n    this.count = count;\n    this.min = min;\n    this.max = max;\n    this.sum = sum;\n  }\n  [symbol]() {\n    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)));\n  }\n  [symbol$1](that) {\n    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass SummaryState {\n  [MetricStateTypeId] = metricStateVariance;\n  [SummaryStateTypeId] = SummaryStateTypeId;\n  constructor(error, quantiles, count, min, max, sum) {\n    this.error = error;\n    this.quantiles = quantiles;\n    this.count = count;\n    this.min = min;\n    this.max = max;\n    this.sum = sum;\n  }\n  [symbol]() {\n    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)));\n  }\n  [symbol$1](that) {\n    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst counter = count => new CounterState(count);\n\n/** @internal */\nconst frequency = occurrences => {\n  return new FrequencyState(occurrences);\n};\n\n/** @internal */\nconst gauge = count => new GaugeState(count);\n\n/** @internal */\nconst histogram = options => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);\n\n/** @internal */\nconst summary = options => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);\n\n/** @internal */\nconst isMetricState = u => {\n  return typeof u === \"object\" && u != null && MetricStateTypeId in u;\n};\n\n/** @internal */\nconst isCounterState = u => {\n  return typeof u === \"object\" && u != null && CounterStateTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isFrequencyState = u => {\n  return typeof u === \"object\" && u != null && FrequencyStateTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isGaugeState = u => {\n  return typeof u === \"object\" && u != null && GaugeStateTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isHistogramState = u => {\n  return typeof u === \"object\" && u != null && HistogramStateTypeId in u;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isSummaryState = u => {\n  return typeof u === \"object\" && u != null && SummaryStateTypeId in u;\n};\n\nexport { CounterStateTypeId, FrequencyStateTypeId, GaugeStateTypeId, HistogramState, HistogramStateTypeId, MetricStateTypeId, SummaryState, SummaryStateTypeId, counter, frequency, gauge, histogram, isCounterState, isFrequencyState, isGaugeState, isHistogramState, isMetricState, isSummaryState, summary };\n","import { map, sort, unsafeFromArray, isEmpty, empty, unsafeHead, drop, of, append, unsafeLast, splitWhere, head } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { millis, greaterThanOrEqualTo, zero } from '../../Duration/dist/effect-Duration.esm.js';\nimport { dual, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { fromIterable } from '../../HashMap/dist/effect-HashMap.esm.js';\nimport { counter as counter$1, frequency as frequency$1, gauge as gauge$1, histogram as histogram$1, summary as summary$1 } from './state.esm.js';\nimport { Order } from '../../Number/dist/effect-Number.esm.js';\nimport { none, some } from '../../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { reduce } from '../../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nconst MetricHookSymbolKey = \"effect/MetricHook\";\n\n/** @internal */\nconst MetricHookTypeId = /*#__PURE__*/Symbol.for(MetricHookSymbolKey);\n\n/** @internal */\nconst metricHookVariance = {\n  _In: _ => _,\n  _Out: _ => _\n};\n\n/** @internal */\nconst make = options => ({\n  [MetricHookTypeId]: metricHookVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  ...options\n});\n\n/** @internal */\nconst onUpdate = /*#__PURE__*/dual(2, (self, f) => ({\n  [MetricHookTypeId]: metricHookVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  get: self.get,\n  update: input => {\n    self.update(input);\n    return f(input);\n  }\n}));\nconst bigint0 = /*#__PURE__*/BigInt(0);\n\n/** @internal */\nconst counter = key => {\n  let sum = key.keyType.bigint ? bigint0 : 0;\n  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? value => value >= bigint0 : value => value >= 0 : _value => true;\n  return make({\n    get: () => counter$1(sum),\n    update: value => {\n      if (canUpdate(value)) {\n        sum = sum + value;\n      }\n    }\n  });\n};\n\n/** @internal */\nconst frequency = _key => {\n  const values = new Map();\n  const update = word => {\n    const slotCount = values.get(word) ?? 0;\n    values.set(word, slotCount + 1);\n  };\n  const snapshot = () => fromIterable(values.entries());\n  return make({\n    get: () => frequency$1(snapshot()),\n    update\n  });\n};\n\n/** @internal */\nconst gauge = (_key, startAt) => {\n  let value = startAt;\n  return make({\n    get: () => gauge$1(value),\n    update: v => {\n      value = v;\n    }\n  });\n};\n\n/** @internal */\nconst histogram = key => {\n  const bounds = key.keyType.boundaries.values;\n  const size = bounds.length;\n  const values = new Uint32Array(size + 1);\n  const boundaries = new Float32Array(size);\n  let count = 0;\n  let sum = 0;\n  let min = Number.MAX_VALUE;\n  let max = Number.MIN_VALUE;\n  pipe(bounds, sort(Order), map((n, i) => {\n    boundaries[i] = n;\n  }));\n\n  // Insert the value into the right bucket with a binary search\n  const update = value => {\n    let from = 0;\n    let to = size;\n    while (from !== to) {\n      const mid = Math.floor(from + (to - from) / 2);\n      const boundary = boundaries[mid];\n      if (value <= boundary) {\n        to = mid;\n      } else {\n        from = mid;\n      }\n      // The special case when to / from have a distance of one\n      if (to === from + 1) {\n        if (value <= boundaries[from]) {\n          to = from;\n        } else {\n          from = to;\n        }\n      }\n    }\n    values[from] = values[from] + 1;\n    count = count + 1;\n    sum = sum + value;\n    if (value < min) {\n      min = value;\n    }\n    if (value > max) {\n      max = value;\n    }\n  };\n  const getBuckets = () => {\n    const builder = Array(size);\n    let cumulated = 0;\n    for (let i = 0; i < size; i++) {\n      const boundary = boundaries[i];\n      const value = values[i];\n      cumulated = cumulated + value;\n      builder[i] = [boundary, cumulated];\n    }\n    return unsafeFromArray(builder);\n  };\n  return make({\n    get: () => histogram$1({\n      buckets: getBuckets(),\n      count,\n      min,\n      max,\n      sum\n    }),\n    update\n  });\n};\n\n/** @internal */\nconst summary = key => {\n  const {\n    error,\n    maxAge,\n    maxSize,\n    quantiles\n  } = key.keyType;\n  const sortedQuantiles = pipe(quantiles, sort(Order));\n  const values = Array(maxSize);\n  let head = 0;\n  let count = 0;\n  let sum = 0;\n  let min = Number.MAX_VALUE;\n  let max = Number.MIN_VALUE;\n\n  // Just before the snapshot we filter out all values older than maxAge\n  const snapshot = now => {\n    const builder = [];\n    // If the buffer is not full yet it contains valid items at the 0..last\n    // indices and null values at the rest of the positions.\n    //\n    // If the buffer is already full then all elements contains a valid\n    // measurement with timestamp.\n    //\n    // At any given point in time we can enumerate all the non-null elements in\n    // the buffer and filter them by timestamp to get a valid view of a time\n    // window.\n    //\n    // The order does not matter because it gets sorted before passing to\n    // `calculateQuantiles`.\n    let i = 0;\n    while (i !== maxSize - 1) {\n      const item = values[i];\n      if (item != null) {\n        const [t, v] = item;\n        const age = millis(now - t);\n        if (greaterThanOrEqualTo(age, zero) && age <= maxAge) {\n          builder.push(v);\n        }\n      }\n      i = i + 1;\n    }\n    return calculateQuantiles(error, sortedQuantiles, pipe(unsafeFromArray(builder), sort(Order)));\n  };\n  const observe = (value, timestamp) => {\n    if (maxSize > 0) {\n      head = head + 1;\n      const target = head % maxSize;\n      values[target] = [timestamp, value];\n    }\n    count = count + 1;\n    sum = sum + value;\n    if (value < min) {\n      min = value;\n    }\n    if (value > max) {\n      max = value;\n    }\n  };\n  return make({\n    get: () => summary$1({\n      error,\n      quantiles: snapshot(Date.now()),\n      count,\n      min,\n      max,\n      sum\n    }),\n    update: ([value, timestamp]) => observe(value, timestamp)\n  });\n};\n\n/** @internal */\n\n/** @internal */\nconst calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {\n  // The number of samples examined\n  const sampleCount = sortedSamples.length;\n  if (isEmpty(sortedQuantiles)) {\n    return empty();\n  }\n  const head = unsafeHead(sortedQuantiles);\n  const tail = pipe(sortedQuantiles, drop(1));\n  const resolved = pipe(tail, reduce(of(resolveQuantile(error, sampleCount, none(), 0, head, sortedSamples)), (accumulator, quantile) => {\n    const h = unsafeHead(accumulator);\n    return pipe(accumulator, append(resolveQuantile(error, sampleCount, h.value, h.consumed, quantile, h.rest)));\n  }));\n  return pipe(resolved, map(rq => [rq.quantile, rq.value]));\n};\n\n/** @internal */\nconst resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {\n  let error_1 = error;\n  let sampleCount_1 = sampleCount;\n  let current_1 = current;\n  let consumed_1 = consumed;\n  let quantile_1 = quantile;\n  let rest_1 = rest;\n  let error_2 = error;\n  let sampleCount_2 = sampleCount;\n  let current_2 = current;\n  let consumed_2 = consumed;\n  let quantile_2 = quantile;\n  let rest_2 = rest;\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    // If the remaining list of samples is empty, there is nothing more to resolve\n    if (isEmpty(rest_1)) {\n      return {\n        quantile: quantile_1,\n        value: none(),\n        consumed: consumed_1,\n        rest: empty()\n      };\n    }\n    // If the quantile is the 100% quantile, we can take the maximum of all the\n    // remaining values as the result\n    if (quantile_1 === 1) {\n      return {\n        quantile: quantile_1,\n        value: some(unsafeLast(rest_1)),\n        consumed: consumed_1 + rest_1.length,\n        rest: empty()\n      };\n    }\n    // Split into two chunks - the first chunk contains all elements of the same\n    // value as the chunk head\n    const sameHead = pipe(rest_1, splitWhere(n => n > unsafeHead(rest_1)));\n    // How many elements do we want to accept for this quantile\n    const desired = quantile_1 * sampleCount_1;\n    // The error margin\n    const allowedError = error_1 / 2 * desired;\n    // Taking into account the elements consumed from the samples so far and the\n    // number of same elements at the beginning of the chunk, calculate the number\n    // of elements we would have if we selected the current head as result\n    const candConsumed = consumed_1 + sameHead[0].length;\n    const candError = Math.abs(candConsumed - desired);\n    // If we haven't got enough elements yet, recurse\n    if (candConsumed < desired - allowedError) {\n      error_2 = error_1;\n      sampleCount_2 = sampleCount_1;\n      current_2 = head(rest_1);\n      consumed_2 = candConsumed;\n      quantile_2 = quantile_1;\n      rest_2 = sameHead[1];\n      error_1 = error_2;\n      sampleCount_1 = sampleCount_2;\n      current_1 = current_2;\n      consumed_1 = consumed_2;\n      quantile_1 = quantile_2;\n      rest_1 = rest_2;\n      continue;\n    }\n    // If we have too many elements, select the previous value and hand back the\n    // the rest as leftover\n    if (candConsumed > desired + allowedError) {\n      return {\n        quantile: quantile_1,\n        value: current_1,\n        consumed: consumed_1,\n        rest: rest_1\n      };\n    }\n    // If we are in the target interval, select the current head and hand back the leftover after dropping all elements\n    // from the sample chunk that are equal to the current head\n    switch (current_1._tag) {\n      case \"None\":\n        {\n          error_2 = error_1;\n          sampleCount_2 = sampleCount_1;\n          current_2 = head(rest_1);\n          consumed_2 = candConsumed;\n          quantile_2 = quantile_1;\n          rest_2 = sameHead[1];\n          error_1 = error_2;\n          sampleCount_1 = sampleCount_2;\n          current_1 = current_2;\n          consumed_1 = consumed_2;\n          quantile_1 = quantile_2;\n          rest_1 = rest_2;\n          continue;\n        }\n      case \"Some\":\n        {\n          const prevError = Math.abs(desired - current_1.value);\n          if (candError < prevError) {\n            error_2 = error_1;\n            sampleCount_2 = sampleCount_1;\n            current_2 = head(rest_1);\n            consumed_2 = candConsumed;\n            quantile_2 = quantile_1;\n            rest_2 = sameHead[1];\n            error_1 = error_2;\n            sampleCount_1 = sampleCount_2;\n            current_1 = current_2;\n            consumed_1 = consumed_2;\n            quantile_1 = quantile_2;\n            rest_1 = rest_2;\n            continue;\n          }\n          return {\n            quantile: quantile_1,\n            value: some(current_1.value),\n            consumed: consumed_1,\n            rest: rest_1\n          };\n        }\n    }\n  }\n  throw new Error(\"BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n\nexport { MetricHookTypeId, counter, frequency, gauge, histogram, make, onUpdate, summary };\n","import { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/** @internal */\nconst MetricPairSymbolKey = \"effect/MetricPair\";\n\n/** @internal */\nconst MetricPairTypeId = /*#__PURE__*/Symbol.for(MetricPairSymbolKey);\n\n/** @internal */\nconst metricPairVariance = {\n  _Type: _ => _\n};\n\n/** @internal */\nconst make = (metricKey, metricState) => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState,\n    pipe() {\n      return pipeArguments(this, arguments);\n    }\n  };\n};\n\n/** @internal */\nconst unsafeMake = (metricKey, metricState) => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState,\n    pipe() {\n      return pipeArguments(this, arguments);\n    }\n  };\n};\n\nexport { MetricPairTypeId, make, unsafeMake };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { empty as empty$1, fromIterable as fromIterable$1, get as get$1, modify as modify$1, remove as remove$1, set as set$1, size as size$1 } from '../../HashMap/dist/effect-HashMap.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { update, get as get$2, make as make$1 } from '../../MutableRef/dist/effect-MutableRef.esm.js';\nimport { isSome } from '../../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableHashMap\");\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\nconst MutableHashMapProto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    return this.backingMap.current[Symbol.iterator]();\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableHashMap\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst fromHashMap = backingMap => {\n  const map = Object.create(MutableHashMapProto);\n  map.backingMap = make$1(backingMap);\n  return map;\n};\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst empty = () => fromHashMap(empty$1());\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = (...entries) => fromIterable(entries);\n\n/**\n * @since 2.0.0\n * @category conversions\n */\nconst fromIterable = entries => fromHashMap(fromIterable$1(entries));\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst get = /*#__PURE__*/dual(2, (self, key) => get$1(self.backingMap.current, key));\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst has = /*#__PURE__*/dual(2, (self, key) => isSome(get(self, key)));\n\n/**\n * Updates the value of the specified key within the `MutableHashMap` if it exists.\n *\n * @since 2.0.0\n */\nconst modify = /*#__PURE__*/dual(3, (self, key, f) => {\n  update(self.backingMap, modify$1(key, f));\n  return self;\n});\n\n/**\n * Set or remove the specified key in the `MutableHashMap` using the specified\n * update function.\n *\n * @since 2.0.0\n */\nconst modifyAt = /*#__PURE__*/dual(3, (self, key, f) => {\n  const result = f(get(self, key));\n  if (isSome(result)) {\n    set(self, key, result.value);\n  } else {\n    remove(self, key);\n  }\n  return self;\n});\n\n/**\n * @since 2.0.0\n */\nconst remove = /*#__PURE__*/dual(2, (self, key) => {\n  update(self.backingMap, remove$1(key));\n  return self;\n});\n\n/**\n * @since 2.0.0\n */\nconst set = /*#__PURE__*/dual(3, (self, key, value) => {\n  update(self.backingMap, set$1(key, value));\n  return self;\n});\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst size = self => size$1(get$2(self.backingMap));\n\nexport { empty, fromIterable, get, has, make, modify, modifyAt, remove, set, size };\n","import { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { fromIterable } from '../../HashSet/dist/effect-HashSet.esm.js';\nimport { counter, frequency, gauge, histogram, summary } from './hook.esm.js';\nimport { isCounterKey, isGaugeKey, isFrequencyKey, isHistogramKey, isSummaryKey } from './keyType.esm.js';\nimport { unsafeMake } from './pair.esm.js';\nimport { empty, get, has, set } from '../../MutableHashMap/dist/effect-MutableHashMap.esm.js';\nimport { getOrUndefined } from '../../Option/dist/effect-Option.esm.js';\n\n/** @internal */\nconst MetricRegistrySymbolKey = \"effect/MetricRegistry\";\n\n/** @internal */\nconst MetricRegistryTypeId = /*#__PURE__*/Symbol.for(MetricRegistrySymbolKey);\n\n/** @internal */\nclass MetricRegistryImpl {\n  [MetricRegistryTypeId] = MetricRegistryTypeId;\n  map = empty();\n  snapshot() {\n    const result = [];\n    for (const [key, hook] of this.map) {\n      result.push(unsafeMake(key, hook.get()));\n    }\n    return fromIterable(result);\n  }\n  get(key) {\n    const hook = pipe(this.map, get(key), getOrUndefined);\n    if (hook == null) {\n      if (isCounterKey(key.keyType)) {\n        return this.getCounter(key);\n      }\n      if (isGaugeKey(key.keyType)) {\n        return this.getGauge(key);\n      }\n      if (isFrequencyKey(key.keyType)) {\n        return this.getFrequency(key);\n      }\n      if (isHistogramKey(key.keyType)) {\n        return this.getHistogram(key);\n      }\n      if (isSummaryKey(key.keyType)) {\n        return this.getSummary(key);\n      }\n      throw new Error(\"BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/io/issues\");\n    } else {\n      return hook;\n    }\n  }\n  getCounter(key) {\n    let value = pipe(this.map, get(key), getOrUndefined);\n    if (value == null) {\n      const counter$1 = counter(key);\n      if (!pipe(this.map, has(key))) {\n        pipe(this.map, set(key, counter$1));\n      }\n      value = counter$1;\n    }\n    return value;\n  }\n  getFrequency(key) {\n    let value = pipe(this.map, get(key), getOrUndefined);\n    if (value == null) {\n      const frequency$1 = frequency();\n      if (!pipe(this.map, has(key))) {\n        pipe(this.map, set(key, frequency$1));\n      }\n      value = frequency$1;\n    }\n    return value;\n  }\n  getGauge(key) {\n    let value = pipe(this.map, get(key), getOrUndefined);\n    if (value == null) {\n      const gauge$1 = gauge(key, key.keyType.bigint ? BigInt(0) : 0);\n      if (!pipe(this.map, has(key))) {\n        pipe(this.map, set(key, gauge$1));\n      }\n      value = gauge$1;\n    }\n    return value;\n  }\n  getHistogram(key) {\n    let value = pipe(this.map, get(key), getOrUndefined);\n    if (value == null) {\n      const histogram$1 = histogram(key);\n      if (!pipe(this.map, has(key))) {\n        pipe(this.map, set(key, histogram$1));\n      }\n      value = histogram$1;\n    }\n    return value;\n  }\n  getSummary(key) {\n    let value = pipe(this.map, get(key), getOrUndefined);\n    if (value == null) {\n      const summary$1 = summary(key);\n      if (!pipe(this.map, has(key))) {\n        pipe(this.map, set(key, summary$1));\n      }\n      value = summary$1;\n    }\n    return value;\n  }\n}\n\n/** @internal */\nconst make = () => {\n  return new MetricRegistryImpl();\n};\n\nexport { MetricRegistryTypeId, make };\n","import { clockWith } from '../Clock/dist/effect-Clock.esm.js';\nimport { toMillis, nanos } from '../Duration/dist/effect-Duration.esm.js';\nimport { dual, constVoid, pipe, identity } from '../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { empty, make as make$2, union, fromIterable, isHashSet } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { defects } from './cause.esm.js';\nimport { tap, sync as sync$1, matchCauseEffect, failCause, succeed as succeed$1, map as map$1, fiberRefGetWith, currentMetricLabels } from './core.esm.js';\nimport { exponential, fromChunk } from './metric/boundaries.esm.js';\nimport { counter as counter$1, frequency as frequency$1, gauge as gauge$1, histogram as histogram$1, summary as summary$1, taggedWithLabelSet } from './metric/key.esm.js';\nimport { make as make$3 } from './metric/label.esm.js';\nimport { make as make$1 } from './metric/registry.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { forEach } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\nimport { tapDefect, tapError } from './core-effect.esm.js';\n\n/** @internal */\nconst MetricSymbolKey = \"effect/Metric\";\n\n/** @internal */\nconst MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);\n\n/** @internal */\nconst metricVariance = {\n  _Type: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\n\n/** @internal */\nconst globalMetricRegistry = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Metric/globalMetricRegistry\"), () => make$1());\n\n/** @internal */\nconst make = function (keyType, unsafeUpdate, unsafeValue) {\n  const metric = Object.assign(effect => tap(effect, a => sync$1(() => unsafeUpdate(a, empty()))), {\n    [MetricTypeId]: metricVariance,\n    keyType,\n    unsafeUpdate,\n    unsafeValue,\n    pipe() {\n      return pipeArguments(this, arguments);\n    }\n  });\n  return metric;\n};\n\n/** @internal */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => make(self.keyType, (input, extraTags) => self.unsafeUpdate(f(input), extraTags), self.unsafeValue));\n\n/** @internal */\nconst counter = (name, options) => fromMetricKey(counter$1(name, options));\n\n/** @internal */\nconst frequency = (name, description) => fromMetricKey(frequency$1(name, description));\n\n/** @internal */\nconst withConstantInput = /*#__PURE__*/dual(2, (self, input) => mapInput(self, () => input));\n\n/** @internal */\nconst fromMetricKey = key => {\n  const hook = extraTags => {\n    const fullKey = pipe(key, taggedWithLabelSet(extraTags));\n    return globalMetricRegistry.get(fullKey);\n  };\n  return make(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get());\n};\n\n/** @internal */\nconst gauge = (name, options) => fromMetricKey(gauge$1(name, options));\n\n/** @internal */\nconst histogram = (name, boundaries, description) => fromMetricKey(histogram$1(name, boundaries, description));\n\n/* @internal */\nconst increment = self => update(self, self.keyType.bigint ? BigInt(1) : 1);\n\n/* @internal */\nconst incrementBy = /*#__PURE__*/dual(2, (self, amount) => update(self, amount));\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => make(self.keyType, self.unsafeUpdate, extraTags => f(self.unsafeValue(extraTags))));\n\n/** @internal */\nconst mapType = /*#__PURE__*/dual(2, (self, f) => make(f(self.keyType), self.unsafeUpdate, self.unsafeValue));\n\n/* @internal */\nconst set = /*#__PURE__*/dual(2, (self, value) => update(self, value));\n\n/** @internal */\nconst succeed = out => make(void 0, constVoid, () => out);\n\n/** @internal */\nconst sync = evaluate => make(void 0, constVoid, evaluate);\n\n/** @internal */\nconst summary = options => withNow(summaryTimestamp(options));\n\n/** @internal */\nconst summaryTimestamp = options => fromMetricKey(summary$1(options));\n\n/** @internal */\nconst tagged = /*#__PURE__*/dual(3, (self, key, value) => taggedWithLabels(self, make$2(make$3(key, value))));\n\n/** @internal */\nconst taggedWithLabelsInput = /*#__PURE__*/dual(2, (self, f) => map(make(self.keyType, (input, extraTags) => self.unsafeUpdate(input, union(fromIterable(f(input)), extraTags)), self.unsafeValue), constVoid));\n\n/** @internal */\nconst taggedWithLabels = /*#__PURE__*/dual(2, (self, extraTagsIterable) => {\n  const extraTags = isHashSet(extraTagsIterable) ? extraTagsIterable : fromIterable(extraTagsIterable);\n  return make(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, pipe(extraTags, union(extraTags1))), extraTags1 => self.unsafeValue(pipe(extraTags, union(extraTags1))));\n});\n\n/** @internal */\nconst timer = name => {\n  const boundaries = exponential({\n    start: 1,\n    factor: 2,\n    count: 100\n  });\n  const base = pipe(histogram(name, boundaries), tagged(\"time_unit\", \"milliseconds\"));\n  return mapInput(base, toMillis);\n};\n\n/** @internal */\nconst timerWithBoundaries = (name, boundaries) => {\n  const base = pipe(histogram(name, fromChunk(boundaries)), tagged(\"time_unit\", \"milliseconds\"));\n  return mapInput(base, toMillis);\n};\n\n/* @internal */\nconst trackAll = /*#__PURE__*/dual(2, (self, input) => effect => matchCauseEffect(effect, {\n  onFailure: cause => {\n    self.unsafeUpdate(input, empty());\n    return failCause(cause);\n  },\n  onSuccess: value => {\n    self.unsafeUpdate(input, empty());\n    return succeed$1(value);\n  }\n}));\n\n/* @internal */\nconst trackDefect = /*#__PURE__*/dual(2, (self, metric) => trackDefectWith(self, metric, identity));\n\n/* @internal */\nconst trackDefectWith = /*#__PURE__*/dual(3, (self, metric, f) => {\n  const updater = defect => metric.unsafeUpdate(f(defect), empty());\n  return tapDefect(self, cause => sync$1(() => pipe(defects(cause), forEach(updater))));\n});\n\n/* @internal */\nconst trackDuration = /*#__PURE__*/dual(2, (self, metric) => trackDurationWith(self, metric, identity));\n\n/* @internal */\nconst trackDurationWith = /*#__PURE__*/dual(3, (self, metric, f) => clockWith(clock => {\n  const startTime = clock.unsafeCurrentTimeNanos();\n  return map$1(self, a => {\n    const endTime = clock.unsafeCurrentTimeNanos();\n    const duration = nanos(endTime - startTime);\n    metric.unsafeUpdate(f(duration), empty());\n    return a;\n  });\n}));\n\n/* @internal */\nconst trackError = /*#__PURE__*/dual(2, (self, metric) => trackErrorWith(self, metric, a => a));\n\n/* @internal */\nconst trackErrorWith = /*#__PURE__*/dual(3, (self, metric, f) => {\n  const updater = error => update(metric, f(error));\n  return tapError(self, updater);\n});\n\n/* @internal */\nconst trackSuccess = /*#__PURE__*/dual(2, (self, metric) => trackSuccessWith(self, metric, a => a));\n\n/* @internal */\nconst trackSuccessWith = /*#__PURE__*/dual(3, (self, metric, f) => {\n  const updater = value => update(metric, f(value));\n  return tap(self, updater);\n});\n\n/* @internal */\nconst update = /*#__PURE__*/dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, tags => sync$1(() => self.unsafeUpdate(input, tags))));\n\n/* @internal */\nconst value = self => fiberRefGetWith(currentMetricLabels, tags => sync$1(() => self.unsafeValue(tags)));\n\n/** @internal */\nconst withNow = self => mapInput(self, input => [input, Date.now()]);\n\n/** @internal */\nconst zip = /*#__PURE__*/dual(2, (self, that) => make([self.keyType, that.keyType], (input, extraTags) => {\n  const [l, r] = input;\n  self.unsafeUpdate(l, extraTags);\n  that.unsafeUpdate(r, extraTags);\n}, extraTags => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)]));\n\n/** @internal */\nconst unsafeSnapshot = () => globalMetricRegistry.snapshot();\n\n/** @internal */\nconst snapshot = /*#__PURE__*/sync$1(unsafeSnapshot);\n\nexport { MetricTypeId, counter, frequency, fromMetricKey, gauge, globalMetricRegistry, histogram, increment, incrementBy, make, map, mapInput, mapType, set, snapshot, succeed, summary, summaryTimestamp, sync, tagged, taggedWithLabels, taggedWithLabelsInput, timer, timerWithBoundaries, trackAll, trackDefect, trackDefectWith, trackDuration, trackDurationWith, trackError, trackErrorWith, trackSuccess, trackSuccessWith, unsafeSnapshot, update, value, withConstantInput, withNow, zip };\n","import { dual } from '../Function/dist/effect-Function.esm.js';\nimport { currentRequestMap } from './completedRequestMap.esm.js';\nimport { fiberRefGetWith, sync, deferredUnsafeDone, matchEffect, exitFail, exitSucceed } from './core.esm.js';\nimport { struct } from './Data.esm.js';\n\n/** @internal */\nconst RequestSymbolKey = \"effect/Request\";\n\n/** @internal */\nconst RequestTypeId = /*#__PURE__*/Symbol.for(RequestSymbolKey);\n\n/** @internal */\nconst requestVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\nconst isRequest = u => typeof u === \"object\" && u != null && RequestTypeId in u;\n\n/** @internal */\nconst of = () => args =>\n// @ts-expect-error\nstruct({\n  [RequestTypeId]: requestVariance,\n  ...args\n});\n\n/** @internal */\nconst tagged = tag => args =>\n// @ts-expect-error\nstruct({\n  [RequestTypeId]: requestVariance,\n  _tag: tag,\n  ...args\n});\n\n/** @internal */\nconst complete = /*#__PURE__*/dual(2, (self, result) => fiberRefGetWith(currentRequestMap, map => sync(() => {\n  if (map.has(self)) {\n    const entry = map.get(self);\n    if (!entry.state.completed) {\n      entry.state.completed = true;\n      deferredUnsafeDone(entry.result, result);\n    }\n  }\n})));\n\n/** @internal */\nconst completeEffect = /*#__PURE__*/dual(2, (self, effect) => matchEffect(effect, {\n  onFailure: error => complete(self, exitFail(error)),\n  onSuccess: value => complete(self, exitSucceed(value))\n}));\n\n/** @internal */\nconst fail = /*#__PURE__*/dual(2, (self, error) => complete(self, exitFail(error)));\n\n/** @internal */\nconst succeed = /*#__PURE__*/dual(2, (self, value) => complete(self, exitSucceed(value)));\n\n/** @internal */\nclass Listeners {\n  count = 0;\n  observers = new Set();\n  addObserver(f) {\n    this.observers.add(f);\n  }\n  removeObserver(f) {\n    this.observers.delete(f);\n  }\n  increment() {\n    this.count++;\n    this.observers.forEach(f => f(this.count));\n  }\n  decrement() {\n    this.count--;\n    this.observers.forEach(f => f(this.count));\n  }\n}\n\nexport { Listeners, RequestTypeId, complete, completeEffect, fail, isRequest, of, succeed, tagged };\n","import { some, none } from '../../Option/dist/effect-Option.esm.js';\n\n/** @internal */\nconst Direction = {\n  Forward: 0,\n  Backward: 1 << 0\n};\n\n/** @internal */\nclass RedBlackTreeIterator {\n  count = 0;\n  constructor(self, stack, direction) {\n    this.self = self;\n    this.stack = stack;\n    this.direction = direction;\n  }\n\n  /**\n   * Clones the iterator\n   */\n  clone() {\n    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);\n  }\n\n  /**\n   * Reverse the traversal direction\n   */\n  reversed() {\n    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);\n  }\n\n  /**\n   * Iterator next\n   */\n  next() {\n    const entry = this.entry;\n    this.count++;\n    if (this.direction === Direction.Forward) {\n      this.moveNext();\n    } else {\n      this.movePrev();\n    }\n    switch (entry._tag) {\n      case \"None\":\n        {\n          return {\n            done: true,\n            value: this.count\n          };\n        }\n      case \"Some\":\n        {\n          return {\n            done: false,\n            value: entry.value\n          };\n        }\n    }\n  }\n\n  /**\n   * Returns the key\n   */\n  get key() {\n    if (this.stack.length > 0) {\n      return some(this.stack[this.stack.length - 1].key);\n    }\n    return none();\n  }\n\n  /**\n   * Returns the value\n   */\n  get value() {\n    if (this.stack.length > 0) {\n      return some(this.stack[this.stack.length - 1].value);\n    }\n    return none();\n  }\n\n  /**\n   * Returns the key\n   */\n  get entry() {\n    if (this.stack.length > 0) {\n      return some([this.stack[this.stack.length - 1].key, this.stack[this.stack.length - 1].value]);\n    }\n    return none();\n  }\n\n  /**\n   * Returns the position of this iterator in the sorted list\n   */\n  get index() {\n    let idx = 0;\n    const stack = this.stack;\n    if (stack.length === 0) {\n      const r = this.self._root;\n      if (r != null) {\n        return r.count;\n      }\n      return 0;\n    } else if (stack[stack.length - 1].left != null) {\n      idx = stack[stack.length - 1].left.count;\n    }\n    for (let s = stack.length - 2; s >= 0; --s) {\n      if (stack[s + 1] === stack[s].right) {\n        ++idx;\n        if (stack[s].left != null) {\n          idx += stack[s].left.count;\n        }\n      }\n    }\n    return idx;\n  }\n\n  /**\n   * Advances iterator to next element in list\n   */\n  moveNext() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return;\n    }\n    let n = stack[stack.length - 1];\n    if (n.right != null) {\n      n = n.right;\n      while (n != null) {\n        stack.push(n);\n        n = n.left;\n      }\n    } else {\n      stack.pop();\n      while (stack.length > 0 && stack[stack.length - 1].right === n) {\n        n = stack[stack.length - 1];\n        stack.pop();\n      }\n    }\n  }\n\n  /**\n   * Checks if there is a next element\n   */\n  get hasNext() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return false;\n    }\n    if (stack[stack.length - 1].right != null) {\n      return true;\n    }\n    for (let s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1].left === stack[s]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Advances iterator to previous element in list\n   */\n  movePrev() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return;\n    }\n    let n = stack[stack.length - 1];\n    if (n != null && n.left != null) {\n      n = n.left;\n      while (n != null) {\n        stack.push(n);\n        n = n.right;\n      }\n    } else {\n      stack.pop();\n      while (stack.length > 0 && stack[stack.length - 1].left === n) {\n        n = stack[stack.length - 1];\n        stack.pop();\n      }\n    }\n  }\n\n  /**\n   * Checks if there is a previous element\n   */\n  get hasPrev() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return false;\n    }\n    if (stack[stack.length - 1].left != null) {\n      return true;\n    }\n    for (let s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1].right === stack[s]) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport { Direction, RedBlackTreeIterator };\n","/** @internal */\nconst Color = {\n  Red: 0,\n  Black: 1 << 0\n};\n/** @internal */\nclass Node {\n  constructor(color, key, value, left, right, count) {\n    this.color = color;\n    this.key = key;\n    this.value = value;\n    this.left = left;\n    this.right = right;\n    this.count = count;\n  }\n}\n\n/** @internal */\nfunction clone(node) {\n  return new Node(node.color, node.key, node.value, node.left, node.right, node.count);\n}\n\n/** @internal */\nfunction swap(n, v) {\n  n.key = v.key;\n  n.value = v.value;\n  n.left = v.left;\n  n.right = v.right;\n  n.color = v.color;\n  n.count = v.count;\n}\n\n/** @internal */\nfunction repaint(node, color) {\n  return new Node(color, node.key, node.value, node.left, node.right, node.count);\n}\n\n/** @internal */\nfunction recount(node) {\n  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);\n}\n\nexport { Color, Node, clone, recount, repaint, swap };\n","import { prepend, empty as empty$1 } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { equals, symbol as symbol$1 } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual } from '../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash, array } from '../Hash/dist/effect-Hash.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { Direction, RedBlackTreeIterator } from './RedBlackTree/iterator.esm.js';\nimport { Node, Color, repaint, recount, swap, clone } from './RedBlackTree/node.esm.js';\nimport { Stack } from './Stack.esm.js';\nimport { some, none, isSome } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isObject } from '../Predicate/dist/effect-Predicate.esm.js';\n\nconst RedBlackTreeSymbolKey = \"effect/RedBlackTree\";\n\n/** @internal */\nconst RedBlackTreeTypeId = /*#__PURE__*/Symbol.for(RedBlackTreeSymbolKey);\n\n/** @internal */\n\nconst RedBlackTreeProto = {\n  [RedBlackTreeTypeId]: RedBlackTreeTypeId,\n  [symbol]() {\n    return combine(hash(RedBlackTreeSymbolKey))(array(Array.from(this)));\n  },\n  [symbol$1](that) {\n    if (isRedBlackTree(that)) {\n      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {\n        return false;\n      }\n      return equals(Array.from(this), Array.from(that));\n    }\n    return false;\n  },\n  [Symbol.iterator]() {\n    const stack = [];\n    let n = this._root;\n    while (n != null) {\n      stack.push(n);\n      n = n.left;\n    }\n    return new RedBlackTreeIterator(this, stack, Direction.Forward);\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"RedBlackTree\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeImpl = (ord, root) => {\n  const tree = Object.create(RedBlackTreeProto);\n  tree._ord = ord;\n  tree._root = root;\n  return tree;\n};\n\n/** @internal */\nconst isRedBlackTree = u => isObject(u) && RedBlackTreeTypeId in u;\n\n/** @internal */\nconst empty = ord => makeImpl(ord, undefined);\n\n/** @internal */\nconst fromIterable = ord => entries => {\n  let tree = empty(ord);\n  for (const [key, value] of entries) {\n    tree = insert(tree, key, value);\n  }\n  return tree;\n};\n\n/** @internal */\nconst make = ord => (...entries) => {\n  return fromIterable(ord)(entries);\n};\n\n/** @internal */\nconst atBackwards = /*#__PURE__*/dual(2, (self, index) => at(self, index, Direction.Backward));\n\n/** @internal */\nconst atForwards = /*#__PURE__*/dual(2, (self, index) => at(self, index, Direction.Forward));\nconst at = (self, index, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      if (index < 0) {\n        return new RedBlackTreeIterator(self, [], direction);\n      }\n      let node = self._root;\n      const stack = [];\n      while (node !== undefined) {\n        stack.push(node);\n        if (node.left !== undefined) {\n          if (index < node.left.count) {\n            node = node.left;\n            continue;\n          }\n          index -= node.left.count;\n        }\n        if (!index) {\n          return new RedBlackTreeIterator(self, stack, direction);\n        }\n        index -= 1;\n        if (node.right !== undefined) {\n          if (index >= node.right.count) {\n            break;\n          }\n          node = node.right;\n        } else {\n          break;\n        }\n      }\n      return new RedBlackTreeIterator(self, [], direction);\n    }\n  };\n};\n\n/** @internal */\nconst findAll = /*#__PURE__*/dual(2, (self, key) => {\n  const stack = [];\n  let node = self._root;\n  let result = empty$1();\n  while (node !== undefined || stack.length > 0) {\n    if (node) {\n      stack.push(node);\n      node = node.left;\n    } else {\n      const current = stack.pop();\n      if (equals(key, current.key)) {\n        result = prepend(current.value)(result);\n      }\n      node = current.right;\n    }\n  }\n  return result;\n});\n\n/** @internal */\nconst findFirst = /*#__PURE__*/dual(2, (self, key) => {\n  const cmp = self._ord;\n  let node = self._root;\n  while (node !== undefined) {\n    const d = cmp(key, node.key);\n    if (equals(key, node.key)) {\n      return some(node.value);\n    }\n    if (d <= 0) {\n      node = node.left;\n    } else {\n      node = node.right;\n    }\n  }\n  return none();\n});\n\n/** @internal */\nconst first = self => {\n  let node = self._root;\n  let current = self._root;\n  while (node !== undefined) {\n    current = node;\n    node = node.left;\n  }\n  return current ? some([current.key, current.value]) : none();\n};\n\n/** @internal */\nconst getAt = /*#__PURE__*/dual(2, (self, index) => {\n  if (index < 0) {\n    return none();\n  }\n  let root = self._root;\n  let node = undefined;\n  while (root !== undefined) {\n    node = root;\n    if (root.left) {\n      if (index < root.left.count) {\n        root = root.left;\n        continue;\n      }\n      index -= root.left.count;\n    }\n    if (!index) {\n      return some([node.key, node.value]);\n    }\n    index -= 1;\n    if (root.right) {\n      if (index >= root.right.count) {\n        break;\n      }\n      root = root.right;\n    } else {\n      break;\n    }\n  }\n  return none();\n});\n\n/** @internal */\nconst getOrder = tree => tree._ord;\n\n/** @internal */\nconst has = /*#__PURE__*/dual(2, (self, key) => isSome(findFirst(self, key)));\n\n/** @internal */\nconst insert = /*#__PURE__*/dual(3, (self, key, value) => {\n  const cmp = self._ord;\n  // Find point to insert new node at\n  let n = self._root;\n  const n_stack = [];\n  const d_stack = [];\n  while (n != null) {\n    const d = cmp(key, n.key);\n    n_stack.push(n);\n    d_stack.push(d);\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n  // Rebuild path to leaf node\n  n_stack.push(new Node(Color.Red, key, value, undefined, undefined, 1));\n  for (let s = n_stack.length - 2; s >= 0; --s) {\n    const n2 = n_stack[s];\n    if (d_stack[s] <= 0) {\n      n_stack[s] = new Node(n2.color, n2.key, n2.value, n_stack[s + 1], n2.right, n2.count + 1);\n    } else {\n      n_stack[s] = new Node(n2.color, n2.key, n2.value, n2.left, n_stack[s + 1], n2.count + 1);\n    }\n  }\n  // Rebalance tree using rotations\n  for (let s = n_stack.length - 1; s > 1; --s) {\n    const p = n_stack[s - 1];\n    const n3 = n_stack[s];\n    if (p.color === Color.Black || n3.color === Color.Black) {\n      break;\n    }\n    const pp = n_stack[s - 2];\n    if (pp.left === p) {\n      if (p.left === n3) {\n        const y = pp.right;\n        if (y && y.color === Color.Red) {\n          p.color = Color.Black;\n          pp.right = repaint(y, Color.Black);\n          pp.color = Color.Red;\n          s -= 1;\n        } else {\n          pp.color = Color.Red;\n          pp.left = p.right;\n          p.color = Color.Black;\n          p.right = pp;\n          n_stack[s - 2] = p;\n          n_stack[s - 1] = n3;\n          recount(pp);\n          recount(p);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.left === pp) {\n              ppp.left = p;\n            } else {\n              ppp.right = p;\n            }\n          }\n          break;\n        }\n      } else {\n        const y = pp.right;\n        if (y && y.color === Color.Red) {\n          p.color = Color.Black;\n          pp.right = repaint(y, Color.Black);\n          pp.color = Color.Red;\n          s -= 1;\n        } else {\n          p.right = n3.left;\n          pp.color = Color.Red;\n          pp.left = n3.right;\n          n3.color = Color.Black;\n          n3.left = p;\n          n3.right = pp;\n          n_stack[s - 2] = n3;\n          n_stack[s - 1] = p;\n          recount(pp);\n          recount(p);\n          recount(n3);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.left === pp) {\n              ppp.left = n3;\n            } else {\n              ppp.right = n3;\n            }\n          }\n          break;\n        }\n      }\n    } else {\n      if (p.right === n3) {\n        const y = pp.left;\n        if (y && y.color === Color.Red) {\n          p.color = Color.Black;\n          pp.left = repaint(y, Color.Black);\n          pp.color = Color.Red;\n          s -= 1;\n        } else {\n          pp.color = Color.Red;\n          pp.right = p.left;\n          p.color = Color.Black;\n          p.left = pp;\n          n_stack[s - 2] = p;\n          n_stack[s - 1] = n3;\n          recount(pp);\n          recount(p);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.right === pp) {\n              ppp.right = p;\n            } else {\n              ppp.left = p;\n            }\n          }\n          break;\n        }\n      } else {\n        const y = pp.left;\n        if (y && y.color === Color.Red) {\n          p.color = Color.Black;\n          pp.left = repaint(y, Color.Black);\n          pp.color = Color.Red;\n          s -= 1;\n        } else {\n          p.left = n3.right;\n          pp.color = Color.Red;\n          pp.right = n3.left;\n          n3.color = Color.Black;\n          n3.right = p;\n          n3.left = pp;\n          n_stack[s - 2] = n3;\n          n_stack[s - 1] = p;\n          recount(pp);\n          recount(p);\n          recount(n3);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.right === pp) {\n              ppp.right = n3;\n            } else {\n              ppp.left = n3;\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n  // Return new tree\n  n_stack[0].color = Color.Black;\n  return makeImpl(self._ord, n_stack[0]);\n});\n\n/** @internal */\nconst keysForward = self => keys(self, Direction.Forward);\n\n/** @internal */\nconst keysBackward = self => keys(self, Direction.Backward);\nconst keys = (self, direction) => {\n  const begin = self[Symbol.iterator]();\n  let count = 0;\n  return {\n    [Symbol.iterator]: () => keys(self, direction),\n    next: () => {\n      count++;\n      const entry = begin.key;\n      if (direction === Direction.Forward) {\n        begin.moveNext();\n      } else {\n        begin.movePrev();\n      }\n      switch (entry._tag) {\n        case \"None\":\n          {\n            return {\n              done: true,\n              value: count\n            };\n          }\n        case \"Some\":\n          {\n            return {\n              done: false,\n              value: entry.value\n            };\n          }\n      }\n    }\n  };\n};\n\n/** @internal */\nconst last = self => {\n  let node = self._root;\n  let current = self._root;\n  while (node !== undefined) {\n    current = node;\n    node = node.right;\n  }\n  return current ? some([current.key, current.value]) : none();\n};\n\n/** @internal */\nconst reversed = self => {\n  return {\n    [Symbol.iterator]: () => {\n      const stack = [];\n      let node = self._root;\n      while (node !== undefined) {\n        stack.push(node);\n        node = node.right;\n      }\n      return new RedBlackTreeIterator(self, stack, Direction.Backward);\n    }\n  };\n};\n\n/** @internal */\nconst greaterThanBackwards = /*#__PURE__*/dual(2, (self, key) => greaterThan(self, key, Direction.Backward));\n\n/** @internal */\nconst greaterThanForwards = /*#__PURE__*/dual(2, (self, key) => greaterThan(self, key, Direction.Forward));\nconst greaterThan = (self, key, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d < 0) {\n          last_ptr = stack.length;\n        }\n        if (d < 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n\n/** @internal */\nconst greaterThanEqualBackwards = /*#__PURE__*/dual(2, (self, key) => greaterThanEqual(self, key, Direction.Backward));\n\n/** @internal */\nconst greaterThanEqualForwards = /*#__PURE__*/dual(2, (self, key) => greaterThanEqual(self, key, Direction.Forward));\nconst greaterThanEqual = (self, key, direction = Direction.Forward) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d <= 0) {\n          last_ptr = stack.length;\n        }\n        if (d <= 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n\n/** @internal */\nconst lessThanBackwards = /*#__PURE__*/dual(2, (self, key) => lessThan(self, key, Direction.Backward));\n\n/** @internal */\nconst lessThanForwards = /*#__PURE__*/dual(2, (self, key) => lessThan(self, key, Direction.Forward));\nconst lessThan = (self, key, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d > 0) {\n          last_ptr = stack.length;\n        }\n        if (d <= 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n\n/** @internal */\nconst lessThanEqualBackwards = /*#__PURE__*/dual(2, (self, key) => lessThanEqual(self, key, Direction.Backward));\n\n/** @internal */\nconst lessThanEqualForwards = /*#__PURE__*/dual(2, (self, key) => lessThanEqual(self, key, Direction.Forward));\nconst lessThanEqual = (self, key, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d >= 0) {\n          last_ptr = stack.length;\n        }\n        if (d < 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n\n/** @internal */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => {\n  const root = self._root;\n  if (root !== undefined) {\n    visitFull(root, (key, value) => {\n      f(key, value);\n      return none();\n    });\n  }\n});\n\n/** @internal */\nconst forEachGreaterThanEqual = /*#__PURE__*/dual(3, (self, min, f) => {\n  const root = self._root;\n  const ord = self._ord;\n  if (root !== undefined) {\n    visitGreaterThanEqual(root, min, ord, (key, value) => {\n      f(key, value);\n      return none();\n    });\n  }\n});\n\n/** @internal */\nconst forEachLessThan = /*#__PURE__*/dual(3, (self, max, f) => {\n  const root = self._root;\n  const ord = self._ord;\n  if (root !== undefined) {\n    visitLessThan(root, max, ord, (key, value) => {\n      f(key, value);\n      return none();\n    });\n  }\n});\n\n/** @internal */\nconst forEachBetween = /*#__PURE__*/dual(2, (self, {\n  body,\n  max,\n  min\n}) => {\n  const root = self._root;\n  const ord = self._ord;\n  if (root) {\n    visitBetween(root, min, max, ord, (key, value) => {\n      body(key, value);\n      return none();\n    });\n  }\n});\n\n/** @internal */\nconst reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let accumulator = zero;\n  for (const entry of self) {\n    accumulator = f(accumulator, entry[1], entry[0]);\n  }\n  return accumulator;\n});\n\n/** @internal */\nconst removeFirst = /*#__PURE__*/dual(2, (self, key) => {\n  if (!has(self, key)) {\n    return self;\n  }\n  const ord = self._ord;\n  const cmp = ord;\n  let node = self._root;\n  const stack = [];\n  while (node !== undefined) {\n    const d = cmp(key, node.key);\n    stack.push(node);\n    if (equals(key, node.key)) {\n      node = undefined;\n    } else if (d <= 0) {\n      node = node.left;\n    } else {\n      node = node.right;\n    }\n  }\n  if (stack.length === 0) {\n    return self;\n  }\n  const cstack = new Array(stack.length);\n  let n = stack[stack.length - 1];\n  cstack[cstack.length - 1] = new Node(n.color, n.key, n.value, n.left, n.right, n.count);\n  for (let i = stack.length - 2; i >= 0; --i) {\n    n = stack[i];\n    if (n.left === stack[i + 1]) {\n      cstack[i] = new Node(n.color, n.key, n.value, cstack[i + 1], n.right, n.count);\n    } else {\n      cstack[i] = new Node(n.color, n.key, n.value, n.left, cstack[i + 1], n.count);\n    }\n  }\n  // Get node\n  n = cstack[cstack.length - 1];\n  // If not leaf, then swap with previous node\n  if (n.left !== undefined && n.right !== undefined) {\n    // First walk to previous leaf\n    const split = cstack.length;\n    n = n.left;\n    while (n.right != null) {\n      cstack.push(n);\n      n = n.right;\n    }\n    // Copy path to leaf\n    const v = cstack[split - 1];\n    cstack.push(new Node(n.color, v.key, v.value, n.left, n.right, n.count));\n    cstack[split - 1].key = n.key;\n    cstack[split - 1].value = n.value;\n    // Fix up stack\n    for (let i = cstack.length - 2; i >= split; --i) {\n      n = cstack[i];\n      cstack[i] = new Node(n.color, n.key, n.value, n.left, cstack[i + 1], n.count);\n    }\n    cstack[split - 1].left = cstack[split];\n  }\n\n  // Remove leaf node\n  n = cstack[cstack.length - 1];\n  if (n.color === Color.Red) {\n    // Easy case: removing red leaf\n    const p = cstack[cstack.length - 2];\n    if (p.left === n) {\n      p.left = undefined;\n    } else if (p.right === n) {\n      p.right = undefined;\n    }\n    cstack.pop();\n    for (let i = 0; i < cstack.length; ++i) {\n      cstack[i].count--;\n    }\n    return makeImpl(ord, cstack[0]);\n  } else {\n    if (n.left !== undefined || n.right !== undefined) {\n      // Second easy case:  Single child black parent\n      if (n.left !== undefined) {\n        swap(n, n.left);\n      } else if (n.right !== undefined) {\n        swap(n, n.right);\n      }\n      // Child must be red, so repaint it black to balance color\n      n.color = Color.Black;\n      for (let i = 0; i < cstack.length - 1; ++i) {\n        cstack[i].count--;\n      }\n      return makeImpl(ord, cstack[0]);\n    } else if (cstack.length === 1) {\n      // Third easy case: root\n      return makeImpl(ord, undefined);\n    } else {\n      // Hard case: Repaint n, and then do some nasty stuff\n      for (let i = 0; i < cstack.length; ++i) {\n        cstack[i].count--;\n      }\n      const parent = cstack[cstack.length - 2];\n      fixDoubleBlack(cstack);\n      // Fix up links\n      if (parent.left === n) {\n        parent.left = undefined;\n      } else {\n        parent.right = undefined;\n      }\n    }\n  }\n  return makeImpl(ord, cstack[0]);\n});\n\n/** @internal */\nconst size = self => self._root?.count ?? 0;\n\n/** @internal */\nconst valuesForward = self => values(self, Direction.Forward);\n\n/** @internal */\nconst valuesBackward = self => values(self, Direction.Backward);\n\n/** @internal */\nconst values = (self, direction) => {\n  const begin = self[Symbol.iterator]();\n  let count = 0;\n  return {\n    [Symbol.iterator]: () => values(self, direction),\n    next: () => {\n      count++;\n      const entry = begin.value;\n      if (direction === Direction.Forward) {\n        begin.moveNext();\n      } else {\n        begin.movePrev();\n      }\n      switch (entry._tag) {\n        case \"None\":\n          {\n            return {\n              done: true,\n              value: count\n            };\n          }\n        case \"Some\":\n          {\n            return {\n              done: false,\n              value: entry.value\n            };\n          }\n      }\n    }\n  };\n};\nconst visitFull = (node, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current != null) {\n      stack = new Stack(current, stack);\n      current = current.left;\n    } else if (stack != null) {\n      const value = visit(stack.value.key, stack.value.value);\n      if (isSome(value)) {\n        return value;\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return none();\n};\nconst visitGreaterThanEqual = (node, min, ord, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current !== undefined) {\n      stack = new Stack(current, stack);\n      if (ord(min, current.key) <= 0) {\n        current = current.left;\n      } else {\n        current = undefined;\n      }\n    } else if (stack !== undefined) {\n      if (ord(min, stack.value.key) <= 0) {\n        const value = visit(stack.value.key, stack.value.value);\n        if (isSome(value)) {\n          return value;\n        }\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return none();\n};\nconst visitLessThan = (node, max, ord, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current !== undefined) {\n      stack = new Stack(current, stack);\n      current = current.left;\n    } else if (stack !== undefined && ord(max, stack.value.key) > 0) {\n      const value = visit(stack.value.key, stack.value.value);\n      if (isSome(value)) {\n        return value;\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return none();\n};\nconst visitBetween = (node, min, max, ord, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current !== undefined) {\n      stack = new Stack(current, stack);\n      if (ord(min, current.key) <= 0) {\n        current = current.left;\n      } else {\n        current = undefined;\n      }\n    } else if (stack !== undefined && ord(max, stack.value.key) > 0) {\n      if (ord(min, stack.value.key) <= 0) {\n        const value = visit(stack.value.key, stack.value.value);\n        if (isSome(value)) {\n          return value;\n        }\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return none();\n};\n\n/**\n * Fix up a double black node in a Red-Black Tree.\n */\nconst fixDoubleBlack = stack => {\n  let n, p, s, z;\n  for (let i = stack.length - 1; i >= 0; --i) {\n    n = stack[i];\n    if (i === 0) {\n      n.color = Color.Black;\n      return;\n    }\n    p = stack[i - 1];\n    if (p.left === n) {\n      s = p.right;\n      if (s !== undefined && s.right !== undefined && s.right.color === Color.Red) {\n        s = p.right = clone(s);\n        z = s.right = clone(s.right);\n        p.right = s.left;\n        s.left = p;\n        s.right = z;\n        s.color = p.color;\n        n.color = Color.Black;\n        p.color = Color.Black;\n        z.color = Color.Black;\n        recount(p);\n        recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.left === p) {\n            pp.left = s;\n          } else {\n            pp.right = s;\n          }\n        }\n        stack[i - 1] = s;\n        return;\n      } else if (s !== undefined && s.left !== undefined && s.left.color === Color.Red) {\n        s = p.right = clone(s);\n        z = s.left = clone(s.left);\n        p.right = z.left;\n        s.left = z.right;\n        z.left = p;\n        z.right = s;\n        z.color = p.color;\n        p.color = Color.Black;\n        s.color = Color.Black;\n        n.color = Color.Black;\n        recount(p);\n        recount(s);\n        recount(z);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.left === p) {\n            pp.left = z;\n          } else {\n            pp.right = z;\n          }\n        }\n        stack[i - 1] = z;\n        return;\n      }\n      if (s !== undefined && s.color === Color.Black) {\n        if (p.color === Color.Red) {\n          p.color = Color.Black;\n          p.right = repaint(s, Color.Red);\n          return;\n        } else {\n          p.right = repaint(s, Color.Red);\n          continue;\n        }\n      } else if (s !== undefined) {\n        s = clone(s);\n        p.right = s.left;\n        s.left = p;\n        s.color = p.color;\n        p.color = Color.Red;\n        recount(p);\n        recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.left === p) {\n            pp.left = s;\n          } else {\n            pp.right = s;\n          }\n        }\n        stack[i - 1] = s;\n        stack[i] = p;\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n;\n        } else {\n          stack.push(n);\n        }\n        i = i + 2;\n      }\n    } else {\n      s = p.left;\n      if (s !== undefined && s.left !== undefined && s.left.color === Color.Red) {\n        s = p.left = clone(s);\n        z = s.left = clone(s.left);\n        p.left = s.right;\n        s.right = p;\n        s.left = z;\n        s.color = p.color;\n        n.color = Color.Black;\n        p.color = Color.Black;\n        z.color = Color.Black;\n        recount(p);\n        recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.right === p) {\n            pp.right = s;\n          } else {\n            pp.left = s;\n          }\n        }\n        stack[i - 1] = s;\n        return;\n      } else if (s !== undefined && s.right !== undefined && s.right.color === Color.Red) {\n        s = p.left = clone(s);\n        z = s.right = clone(s.right);\n        p.left = z.right;\n        s.right = z.left;\n        z.right = p;\n        z.left = s;\n        z.color = p.color;\n        p.color = Color.Black;\n        s.color = Color.Black;\n        n.color = Color.Black;\n        recount(p);\n        recount(s);\n        recount(z);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.right === p) {\n            pp.right = z;\n          } else {\n            pp.left = z;\n          }\n        }\n        stack[i - 1] = z;\n        return;\n      }\n      if (s !== undefined && s.color === Color.Black) {\n        if (p.color === Color.Red) {\n          p.color = Color.Black;\n          p.left = repaint(s, Color.Red);\n          return;\n        } else {\n          p.left = repaint(s, Color.Red);\n          continue;\n        }\n      } else if (s !== undefined) {\n        s = clone(s);\n        p.left = s.right;\n        s.right = p;\n        s.color = p.color;\n        p.color = Color.Red;\n        recount(p);\n        recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.right === p) {\n            pp.right = s;\n          } else {\n            pp.left = s;\n          }\n        }\n        stack[i - 1] = s;\n        stack[i] = p;\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n;\n        } else {\n          stack.push(n);\n        }\n        i = i + 2;\n      }\n    }\n  }\n};\n\nexport { RedBlackTreeTypeId, atBackwards, atForwards, empty, findAll, findFirst, first, forEach, forEachBetween, forEachGreaterThanEqual, forEachLessThan, fromIterable, getAt, getOrder, greaterThanBackwards, greaterThanEqualBackwards, greaterThanEqualForwards, greaterThanForwards, has, insert, isRedBlackTree, keysBackward, keysForward, last, lessThanBackwards, lessThanEqualBackwards, lessThanEqualForwards, lessThanForwards, make, reduce, removeFirst, reversed, size, valuesBackward, valuesForward };\n","import { isRedBlackTree as isRedBlackTree$1, empty as empty$1, fromIterable as fromIterable$1, make as make$1, atForwards, atBackwards, findAll as findAll$1, findFirst as findFirst$1, first as first$1, getAt as getAt$1, getOrder as getOrder$1, greaterThanForwards, greaterThanBackwards, greaterThanEqualForwards, greaterThanEqualBackwards, has as has$1, insert as insert$1, keysForward, keysBackward, last as last$1, lessThanForwards, lessThanBackwards, lessThanEqualForwards, lessThanEqualBackwards, forEach as forEach$1, forEachGreaterThanEqual as forEachGreaterThanEqual$1, forEachLessThan as forEachLessThan$1, forEachBetween as forEachBetween$1, reduce as reduce$1, removeFirst as removeFirst$1, reversed as reversed$1, size as size$1, valuesForward, valuesBackward } from '../../internal/RedBlackTree.esm.js';\nimport { Direction as Direction$1 } from '../../internal/RedBlackTree/iterator.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category constants\n */\nconst Direction = Direction$1;\n\n/**\n * A Red-Black Tree.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isRedBlackTree = isRedBlackTree$1;\n\n/**\n * Creates an empty `RedBlackTree`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Constructs a new tree from an iterable of key-value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = fromIterable$1;\n\n/**\n * Constructs a new `RedBlackTree` from the specified entries.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Returns an iterator that points to the element at the specified index of the\n * tree.\n *\n * **Note**: The iterator will run through elements in order.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst at = atForwards;\n\n/**\n * Returns an iterator that points to the element at the specified index of the\n * tree.\n *\n * **Note**: The iterator will run through elements in reverse order.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst atReversed = atBackwards;\n\n/**\n * Finds all values in the tree associated with the specified key.\n *\n * @since 2.0.0\n * @category elements\n */\nconst findAll = findAll$1;\n\n/**\n * Finds the first value in the tree associated with the specified key, if it exists.\n *\n * @category elements\n * @since 2.0.0\n */\nconst findFirst = findFirst$1;\n\n/**\n * Returns the first entry in the tree, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst first = first$1;\n\n/**\n * Returns the element at the specified index within the tree or `None` if the\n * specified index does not exist.\n *\n * @since 2.0.0\n * @category elements\n */\nconst getAt = getAt$1;\n\n/**\n * Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.\n *\n * @since 2.0.0\n * @category getters\n */\nconst getOrder = getOrder$1;\n\n/**\n * Returns an iterator that traverse entries in order with keys greater than the\n * specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst greaterThan = greaterThanForwards;\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys greater\n * than the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst greaterThanReversed = greaterThanBackwards;\n\n/**\n * Returns an iterator that traverse entries in order with keys greater than or\n * equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst greaterThanEqual = greaterThanEqualForwards;\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys greater\n * than or equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst greaterThanEqualReversed = greaterThanEqualBackwards;\n\n/**\n * Finds the item with key, if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nconst has = has$1;\n\n/**\n * Insert a new item into the tree.\n *\n * @since 2.0.0\n */\nconst insert = insert$1;\n\n/**\n * Get all the keys present in the tree in order.\n *\n * @since 2.0.0\n * @category getters\n */\nconst keys = keysForward;\n\n/**\n * Get all the keys present in the tree in reverse order.\n *\n * @since 2.0.0\n * @category getters\n */\nconst keysReversed = keysBackward;\n\n/**\n * Returns the last entry in the tree, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst last = last$1;\n\n/**\n * Returns an iterator that traverse entries in order with keys less than the\n * specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst lessThan = lessThanForwards;\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys less\n * than the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst lessThanReversed = lessThanBackwards;\n\n/**\n * Returns an iterator that traverse entries in order with keys less than or\n * equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst lessThanEqual = lessThanEqualForwards;\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys less\n * than or equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst lessThanEqualReversed = lessThanEqualBackwards;\n\n/**\n * Execute the specified function for each node of the tree, in order.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEach = forEach$1;\n\n/**\n * Visit each node of the tree in order with key greater then or equal to max.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEachGreaterThanEqual = forEachGreaterThanEqual$1;\n\n/**\n * Visit each node of the tree in order with key lower then max.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEachLessThan = forEachLessThan$1;\n\n/**\n * Visit each node of the tree in order with key lower than max and greater\n * than or equal to min.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEachBetween = forEachBetween$1;\n\n/**\n * Reduce a state over the entries of the tree.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduce = reduce$1;\n\n/**\n * Removes the entry with the specified key, if it exists.\n *\n * @since 2.0.0\n */\nconst removeFirst = removeFirst$1;\n\n/**\n * Traverse the tree in reverse order.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst reversed = reversed$1;\n\n/**\n * Returns the size of the tree.\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = size$1;\n\n/**\n * Get all values present in the tree in order.\n *\n * @since 2.0.0\n * @category getters\n */\nconst values = valuesForward;\n\n/**\n * Get all values present in the tree in reverse order.\n *\n * @since 2.0.0\n * @category getters\n */\nconst valuesReversed = valuesBackward;\n\nexport { Direction, at, atReversed, empty, findAll, findFirst, first, forEach, forEachBetween, forEachGreaterThanEqual, forEachLessThan, fromIterable, getAt, getOrder, greaterThan, greaterThanEqual, greaterThanEqualReversed, greaterThanReversed, has, insert, isRedBlackTree, keys, keysReversed, last, lessThan, lessThanEqual, lessThanEqualReversed, lessThanReversed, make, reduce, removeFirst, reversed, size, values, valuesReversed };\n","import { symbol as symbol$1, equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { dual, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol, combine, hash } from '../../Hash/dist/effect-Hash.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isObject } from '../../Predicate/dist/effect-Predicate.esm.js';\nimport { empty as empty$1, fromIterable as fromIterable$1, has as has$1, insert, getOrder, forEach as forEach$1, removeFirst, size as size$1, keys } from '../../RedBlackTree/dist/effect-RedBlackTree.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/SortedSet\");\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\nconst SortedSetProto = {\n  [TypeId]: {\n    _A: _ => _\n  },\n  [symbol]() {\n    return pipe(hash(this.keyTree), combine(hash(TypeId)));\n  },\n  [symbol$1](that) {\n    return isSortedSet(that) && equals(this.keyTree, that.keyTree);\n  },\n  [Symbol.iterator]() {\n    return keys(this.keyTree);\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"SortedSet\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst fromTree = keyTree => {\n  const a = Object.create(SortedSetProto);\n  a.keyTree = keyTree;\n  return a;\n};\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isSortedSet = u => isObject(u) && TypeId in u;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst empty = O => fromTree(empty$1(O));\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = ord => iterable => fromTree(fromIterable$1(ord)(Array.from(iterable).map(k => [k, true])));\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = ord => (...entries) => fromIterable(ord)(entries);\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst add = /*#__PURE__*/dual(2, (self, value) => has$1(self.keyTree, value) ? self : fromTree(insert(self.keyTree, value, true)));\n\n/**\n * @since 2.0.0\n */\nconst difference = /*#__PURE__*/dual(2, (self, that) => {\n  let out = self;\n  for (const value of that) {\n    out = remove(out, value);\n  }\n  return out;\n});\n\n/**\n * Check if a predicate holds true for every `SortedSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst every = /*#__PURE__*/dual(2, (self, refinement) => {\n  for (const value of self) {\n    if (!refinement(value)) {\n      return false;\n    }\n  }\n  return true;\n});\n\n/**\n * @since 2.0.0\n * @category filtering\n */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => {\n  const ord = getOrder(self.keyTree);\n  let out = empty(ord);\n  for (const value of self) {\n    if (predicate(value)) {\n      out = add(out, value);\n    }\n  }\n  return out;\n});\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = /*#__PURE__*/dual(3, (self, O, f) => {\n  let out = empty(O);\n  forEach(self, a => {\n    for (const b of f(a)) {\n      out = add(out, b);\n    }\n  });\n  return out;\n});\n\n/**\n * @since 2.0.0\n * @category traversing\n */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => forEach$1(self.keyTree, f));\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst has = /*#__PURE__*/dual(2, (self, value) => has$1(self.keyTree, value));\n\n/**\n * @since 2.0.0\n */\nconst intersection = /*#__PURE__*/dual(2, (self, that) => {\n  const ord = getOrder(self.keyTree);\n  let out = empty(ord);\n  for (const value of that) {\n    if (has(self, value)) {\n      out = add(out, value);\n    }\n  }\n  return out;\n});\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst isSubset = /*#__PURE__*/dual(2, (self, that) => every(self, a => has(that, a)));\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nconst map = /*#__PURE__*/dual(3, (self, O, f) => {\n  let out = empty(O);\n  forEach(self, a => {\n    const b = f(a);\n    if (!has(out, b)) {\n      out = add(out, b);\n    }\n  });\n  return out;\n});\n\n/**\n * @since 2.0.0\n * @category filtering\n */\nconst partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const ord = getOrder(self.keyTree);\n  let right = empty(ord);\n  let left = empty(ord);\n  for (const value of self) {\n    if (predicate(value)) {\n      right = add(right, value);\n    } else {\n      left = add(left, value);\n    }\n  }\n  return [left, right];\n});\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst remove = /*#__PURE__*/dual(2, (self, value) => fromTree(removeFirst(self.keyTree, value)));\n\n/**\n * @since 2.0.0\n * @category getters\n */\nconst size = self => size$1(self.keyTree);\n\n/**\n * Check if a predicate holds true for some `SortedSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nconst some = /*#__PURE__*/dual(2, (self, predicate) => {\n  for (const value of self) {\n    if (predicate(value)) {\n      return true;\n    }\n  }\n  return false;\n});\n\n/**\n * @since 2.0.0\n * @category elements\n */\nconst toggle = /*#__PURE__*/dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));\n\n/**\n * @since 2.0.0\n */\nconst union = /*#__PURE__*/dual(2, (self, that) => {\n  const ord = getOrder(self.keyTree);\n  let out = empty(ord);\n  for (const value of self) {\n    out = add(value)(out);\n  }\n  for (const value of that) {\n    out = add(value)(out);\n  }\n  return out;\n});\n\n/**\n * @since 2.0.0\n * @category getters\n */\nconst values = self => keys(self.keyTree);\n\nexport { add, difference, empty, every, filter, flatMap, forEach, fromIterable, has, intersection, isSortedSet, isSubset, make, map, partition, remove, size, some, toggle, union, values };\n","import { pipe } from '../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { map, zip, sync, unit } from './core.esm.js';\nimport { get, set } from '../MutableRef/dist/effect-MutableRef.esm.js';\nimport { add, remove } from '../SortedSet/dist/effect-SortedSet.esm.js';\n\n/** @internal */\nconst SupervisorSymbolKey = \"effect/Supervisor\";\n\n/** @internal */\nconst SupervisorTypeId = /*#__PURE__*/Symbol.for(SupervisorSymbolKey);\n\n/** @internal */\nconst supervisorVariance = {\n  _T: _ => _\n};\n\n/** @internal */\nclass ProxySupervisor {\n  [SupervisorTypeId] = supervisorVariance;\n  constructor(underlying, value0) {\n    this.underlying = underlying;\n    this.value0 = value0;\n  }\n  value() {\n    return this.value0();\n  }\n  onStart(context, effect, parent, fiber) {\n    this.underlying.onStart(context, effect, parent, fiber);\n  }\n  onEnd(value, fiber) {\n    this.underlying.onEnd(value, fiber);\n  }\n  onEffect(fiber, effect) {\n    this.underlying.onEffect(fiber, effect);\n  }\n  onSuspend(fiber) {\n    this.underlying.onSuspend(fiber);\n  }\n  onResume(fiber) {\n    this.underlying.onResume(fiber);\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => pipe(this.value(), map(f)));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n\n/** @internal */\nclass Zip {\n  [SupervisorTypeId] = supervisorVariance;\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  value() {\n    return zip(this.left.value(), this.right.value());\n  }\n  onStart(context, effect, parent, fiber) {\n    this.left.onStart(context, effect, parent, fiber);\n    this.right.onStart(context, effect, parent, fiber);\n  }\n  onEnd(value, fiber) {\n    this.left.onEnd(value, fiber);\n    this.right.onEnd(value, fiber);\n  }\n  onEffect(fiber, effect) {\n    this.left.onEffect(fiber, effect);\n    this.right.onEffect(fiber, effect);\n  }\n  onSuspend(fiber) {\n    this.left.onSuspend(fiber);\n    this.right.onSuspend(fiber);\n  }\n  onResume(fiber) {\n    this.left.onResume(fiber);\n    this.right.onResume(fiber);\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => pipe(this.value(), map(f)));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\nclass Track {\n  [SupervisorTypeId] = supervisorVariance;\n  fibers = new Set();\n  value() {\n    return sync(() => Array.from(this.fibers));\n  }\n  onStart(_context, _effect, _parent, fiber) {\n    this.fibers.add(fiber);\n  }\n  onEnd(_value, fiber) {\n    this.fibers.delete(fiber);\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => pipe(this.value(), map(f)));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n  onRun(execution, _fiber) {\n    return execution();\n  }\n}\nclass Const {\n  [SupervisorTypeId] = supervisorVariance;\n  constructor(effect) {\n    this.effect = effect;\n  }\n  value() {\n    return this.effect;\n  }\n  onStart(_context, _effect, _parent, _fiber) {\n    //\n  }\n  onEnd(_value, _fiber) {\n    //\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => pipe(this.value(), map(f)));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n  onRun(execution, _fiber) {\n    return execution();\n  }\n}\nclass FibersIn {\n  [SupervisorTypeId] = supervisorVariance;\n  constructor(ref) {\n    this.ref = ref;\n  }\n  value() {\n    return sync(() => get(this.ref));\n  }\n  onStart(_context, _effect, _parent, fiber) {\n    pipe(this.ref, set(pipe(get(this.ref), add(fiber))));\n  }\n  onEnd(_value, fiber) {\n    pipe(this.ref, set(pipe(get(this.ref), remove(fiber))));\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => pipe(this.value(), map(f)));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n  onRun(execution, _fiber) {\n    return execution();\n  }\n}\n\n/** @internal */\nconst unsafeTrack = () => {\n  return new Track();\n};\n\n/** @internal */\nconst track = /*#__PURE__*/sync(unsafeTrack);\n\n/** @internal */\nconst fromEffect = effect => {\n  return new Const(effect);\n};\n\n/** @internal */\nconst none = /*#__PURE__*/globalValue(\"effect/Supervisor/none\", () => fromEffect(unit));\n\n/** @internal */\nconst fibersIn = ref => sync(() => new FibersIn(ref));\n\nexport { Const, ProxySupervisor, SupervisorTypeId, Track, Zip, fibersIn, fromEffect, none, supervisorVariance, track, unsafeTrack };\n","import { of, isNonEmpty, headNonEmpty, prepend, tailNonEmpty } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { make } from '../../Differ/dist/effect-Differ.esm.js';\nimport { equals } from '../../Equal/dist/effect-Equal.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { reduce, difference, empty as empty$1, union, make as make$1 } from '../../HashSet/dist/effect-HashSet.esm.js';\nimport { none, Zip } from '../supervisor.esm.js';\n\n/** @internal */\n\n/** @internal */\nconst OP_EMPTY = \"Empty\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ADD_SUPERVISOR = \"AddSupervisor\";\n\n/** @internal */\n\n/** @internal */\nconst OP_REMOVE_SUPERVISOR = \"RemoveSupervisor\";\n\n/** @internal */\n\n/** @internal */\nconst OP_AND_THEN = \"AndThen\";\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/**\n * The empty `SupervisorPatch`.\n *\n * @internal\n */\nconst empty = {\n  _tag: OP_EMPTY\n};\n\n/**\n * Combines two patches to produce a new patch that describes applying the\n * updates from this patch and then the updates from the specified patch.\n *\n * @internal\n */\nconst combine = (self, that) => {\n  return {\n    _tag: OP_AND_THEN,\n    first: self,\n    second: that\n  };\n};\n\n/**\n * Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.\n *\n * @internal\n */\nconst patch = (self, supervisor) => {\n  return patchLoop(supervisor, of(self));\n};\n\n/** @internal */\nconst patchLoop = (_supervisor, _patches) => {\n  let supervisor = _supervisor;\n  let patches = _patches;\n  while (isNonEmpty(patches)) {\n    const head = headNonEmpty(patches);\n    switch (head._tag) {\n      case OP_EMPTY:\n        {\n          patches = tailNonEmpty(patches);\n          break;\n        }\n      case OP_ADD_SUPERVISOR:\n        {\n          supervisor = supervisor.zip(head.supervisor);\n          patches = tailNonEmpty(patches);\n          break;\n        }\n      case OP_REMOVE_SUPERVISOR:\n        {\n          supervisor = removeSupervisor(supervisor, head.supervisor);\n          patches = tailNonEmpty(patches);\n          break;\n        }\n      case OP_AND_THEN:\n        {\n          patches = prepend(head.first)(prepend(head.second)(tailNonEmpty(patches)));\n          break;\n        }\n    }\n  }\n  return supervisor;\n};\n\n/** @internal */\nconst removeSupervisor = (self, that) => {\n  if (equals(self, that)) {\n    return none;\n  } else {\n    if (self instanceof Zip) {\n      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));\n    } else {\n      return self;\n    }\n  }\n};\n\n/** @internal */\nconst toSet = self => {\n  if (equals(self, none)) {\n    return empty$1();\n  } else {\n    if (self instanceof Zip) {\n      return pipe(toSet(self.left), union(toSet(self.right)));\n    } else {\n      return make$1(self);\n    }\n  }\n};\n\n/** @internal */\nconst diff = (oldValue, newValue) => {\n  if (equals(oldValue, newValue)) {\n    return empty;\n  }\n  const oldSupervisors = toSet(oldValue);\n  const newSupervisors = toSet(newValue);\n  const added = pipe(newSupervisors, difference(oldSupervisors), reduce(empty, (patch, supervisor) => combine(patch, {\n    _tag: OP_ADD_SUPERVISOR,\n    supervisor\n  })));\n  const removed = pipe(oldSupervisors, difference(newSupervisors), reduce(empty, (patch, supervisor) => combine(patch, {\n    _tag: OP_REMOVE_SUPERVISOR,\n    supervisor\n  })));\n  return combine(added, removed);\n};\n\n/** @internal */\nconst differ = /*#__PURE__*/make({\n  empty,\n  patch,\n  combine,\n  diff\n});\n\nexport { OP_ADD_SUPERVISOR, OP_AND_THEN, OP_EMPTY, OP_REMOVE_SUPERVISOR, combine, diff, differ, empty, patch };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { globalValue } from '../../GlobalValue/dist/effect-GlobalValue.esm.js';\nimport { currentMaxOpsBeforeYield, currentSchedulingPriority, fiberRefUnsafeMake, fiberRefLocally } from '../../internal/core.esm.js';\nimport { set } from '../../internal/timeout.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category utils\n */\nclass PriorityBuckets {\n  /**\n   * @since 2.0.0\n   */\n  buckets = [];\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task, priority) {\n    let bucket = undefined;\n    let index;\n    for (index = 0; index < this.buckets.length; index++) {\n      if (this.buckets[index][0] <= priority) {\n        bucket = this.buckets[index];\n      } else {\n        break;\n      }\n    }\n    if (bucket) {\n      bucket[1].push(task);\n    } else {\n      const newBuckets = [];\n      for (let i = 0; i < index; i++) {\n        newBuckets.push(this.buckets[i]);\n      }\n      newBuckets.push([priority, [task]]);\n      for (let i = index; i < this.buckets.length; i++) {\n        newBuckets.push(this.buckets[i]);\n      }\n      this.buckets = newBuckets;\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass MixedScheduler {\n  /**\n   * @since 2.0.0\n   */\n  running = false;\n  /**\n   * @since 2.0.0\n   */\n  tasks = new PriorityBuckets();\n  constructor(\n  /**\n   * @since 2.0.0\n   */\n  maxNextTickBeforeTimer) {\n    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  starveInternal(depth) {\n    const tasks = this.tasks.buckets;\n    this.tasks.buckets = [];\n    for (const [_, toRun] of tasks) {\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]();\n      }\n    }\n    if (this.tasks.buckets.length === 0) {\n      this.running = false;\n    } else {\n      this.starve(depth);\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  starve(depth = 0) {\n    if (depth >= this.maxNextTickBeforeTimer) {\n      set(() => this.starveInternal(0), 0);\n    } else {\n      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  shouldYield(fiber) {\n    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task, priority) {\n    this.tasks.scheduleTask(task, priority);\n    if (!this.running) {\n      this.running = true;\n      this.starve();\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category schedulers\n */\nconst defaultScheduler = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Scheduler/defaultScheduler\"), () => new MixedScheduler(2048));\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass SyncScheduler {\n  /**\n   * @since 2.0.0\n   */\n  tasks = new PriorityBuckets();\n\n  /**\n   * @since 2.0.0\n   */\n  deferred = false;\n\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task, priority) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task, priority);\n    } else {\n      this.tasks.scheduleTask(task, priority);\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  shouldYield(fiber) {\n    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  flush() {\n    while (this.tasks.buckets.length > 0) {\n      const tasks = this.tasks.buckets;\n      this.tasks.buckets = [];\n      for (const [_, toRun] of tasks) {\n        for (let i = 0; i < toRun.length; i++) {\n          toRun[i]();\n        }\n      }\n    }\n    this.deferred = true;\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass ControlledScheduler {\n  /**\n   * @since 2.0.0\n   */\n  tasks = new PriorityBuckets();\n\n  /**\n   * @since 2.0.0\n   */\n  deferred = false;\n\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task, priority) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task, priority);\n    } else {\n      this.tasks.scheduleTask(task, priority);\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  shouldYield(fiber) {\n    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  step() {\n    const tasks = this.tasks.buckets;\n    this.tasks.buckets = [];\n    for (const [_, toRun] of tasks) {\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]();\n      }\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst makeMatrix = (...record) => {\n  const index = record.sort(([p0], [p1]) => p0 < p1 ? -1 : p0 > p1 ? 1 : 0);\n  return {\n    shouldYield(fiber) {\n      for (const scheduler of record) {\n        const priority = scheduler[1].shouldYield(fiber);\n        if (priority !== false) {\n          return priority;\n        }\n      }\n      return false;\n    },\n    scheduleTask(task, priority) {\n      let scheduler = undefined;\n      for (const i of index) {\n        if (priority >= i[0]) {\n          scheduler = i[1];\n        } else {\n          return (scheduler ?? defaultScheduler).scheduleTask(task, priority);\n        }\n      }\n      return (scheduler ?? defaultScheduler).scheduleTask(task, priority);\n    }\n  };\n};\n\n/**\n * @since 2.0.0\n * @category utilities\n */\nconst defaultShouldYield = fiber => {\n  return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;\n};\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = (scheduleTask, shouldYield = defaultShouldYield) => ({\n  scheduleTask,\n  shouldYield\n});\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst makeBatched = (callback, shouldYield = defaultShouldYield) => {\n  let running = false;\n  const tasks = new PriorityBuckets();\n  const starveInternal = () => {\n    const tasksToRun = tasks.buckets;\n    tasks.buckets = [];\n    for (const [_, toRun] of tasksToRun) {\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]();\n      }\n    }\n    if (tasks.buckets.length === 0) {\n      running = false;\n    } else {\n      starve();\n    }\n  };\n  const starve = () => callback(starveInternal);\n  return make((task, priority) => {\n    tasks.scheduleTask(task, priority);\n    if (!running) {\n      running = true;\n      starve();\n    }\n  }, shouldYield);\n};\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst timer = (ms, shouldYield = defaultShouldYield) => make(task => set(task, ms), shouldYield);\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst timerBatched = (ms, shouldYield = defaultShouldYield) => makeBatched(task => set(task, ms), shouldYield);\n\n/** @internal */\nconst currentScheduler = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentScheduler\"), () => fiberRefUnsafeMake(defaultScheduler));\n\n/** @internal */\nconst withScheduler = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));\n\nexport { ControlledScheduler, MixedScheduler, PriorityBuckets, SyncScheduler, currentScheduler, defaultScheduler, defaultShouldYield, make, makeBatched, makeMatrix, timer, timerBatched, withScheduler };\n","import { not } from '../Boolean/dist/effect-Boolean.esm.js';\nimport { fromIterable as fromIterable$1, isNonEmpty, headNonEmpty, tailNonEmpty, unsafeFromArray, prepend } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { get as get$1, getOption, add, Tag, merge, make as make$2, unsafeGet } from '../Context/dist/effect-Context.esm.js';\nimport { await as _await$1 } from '../Deferred/dist/effect-Deferred.esm.js';\nimport { parallel, sequential, parallelN } from '../ExecutionStrategy/dist/effect-ExecutionStrategy.esm.js';\nimport { threadName, combine, none as none$2, unsafeMake as unsafeMake$1 } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { getOrDefault } from '../FiberRefs/dist/effect-FiberRefs.esm.js';\nimport { diff as diff$1, patch as patch$1 } from '../FiberRefsPatch/dist/effect-FiberRefsPatch.esm.js';\nimport { isDone, done, suspended, running } from '../FiberStatus/dist/effect-FiberStatus.esm.js';\nimport { dual, identity, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { map as map$1 } from '../HashMap/dist/effect-HashMap.esm.js';\nimport { make, fromIterable as fromIterable$2, union, size } from '../HashSet/dist/effect-HashSet.esm.js';\nimport { par, flatten as flatten$2, sequentialCollectionToChunk } from './blockedRequests.esm.js';\nimport { pretty, failureOrCause, parallel as parallel$1, sequential as sequential$1, interrupt, isEmpty, isInterruptedOnly, die, NoSuchElementException, stripFailures, isInterruptedException, IllegalArgumentException } from './cause.esm.js';\nimport { clockTag } from './clock.esm.js';\nimport { currentRequestMap } from './completedRequestMap.esm.js';\nimport { matchSimple, match as match$1 } from './concurrency.esm.js';\nimport { configProviderTag } from './configProvider.esm.js';\nimport { fiberRefUnsafeMake, currentTracerSpan, fiberRefUnsafeMakeHashSet, uninterruptible, tap, isEffect, withFiberRuntime, fiberRefLocally, currentForkScopeOverride, map as map$2, exit, exitIsSuccess, onError, failCause, partitionMap, either, flatMap as flatMap$1, unit, succeed, fail, dieSync, uninterruptibleMask, interruptible, forEachSequential, zipRight, asUnit, onInterrupt, zipLeft, interruptFiber, deferredMake, exitMatchEffect, flatten, deferredFailCause, deferredSucceed, contextWithEffect, scopeFork, currentMetricLabels, acquireUseRelease, scopeClose, exitZipWith, flip, fiberIdWith, updateRuntimeFlags, runtimeFlags, ScopeTypeId, releaseMapMake, CloseableScopeTypeId, releaseMapAdd, scopeAddFinalizerExit, as, mapInputContext, onExit, fiberRefUnsafeMakePatch, fiberRefGet, fiberRefSet, fiberRefGetWith, sync, fiberRefUpdate, fiberRefDelete, fiberRefUnsafeMakeContext, fiberRefUnsafeMakeRuntimeFlags, forEachSequentialDiscard, exitSucceed, matchCauseEffect, suspend, fiberRefLocallyWith, currentInterruptedCause, deferredUnsafeMake, deferredAwait, async, currentSchedulingPriority, whileLoop, currentUnhandledErrorLogLevel, currentLogLevel, currentLogSpan, currentLogAnnotations, exitFailCause, exitUnit, currentContext, blocked, catchAllCause, runRequestBlock, RevertFlags, yieldNow as yieldNow$1, isEffectError, withRuntimeFlags, matchEffect, if_, zipWith, currentRequestBatching, transplant, step, deferredUnsafeDone, deferredFail, exitCollectAll, exitIsFailure, exitInterrupt, exitAsUnit, interruptAsFiber, flatMapStep } from './core.esm.js';\nimport { makeSpan, currentTimeNanosTracing, mapErrorCause } from './core-effect.esm.js';\nimport { currentServices } from './defaultServices.esm.js';\nimport { consoleTag } from './defaultServices/console.esm.js';\nimport { sequential as sequential$2, isSequential, isParallel } from './executionStrategy.esm.js';\nimport { _await, FiberTypeId, fiberVariance, join, RuntimeFiberTypeId, currentFiberURI, inheritAll, interruptAsFork } from './fiber.esm.js';\nimport { resume, stateful, interruptSignal, OP_STATEFUL, OP_RESUME, OP_INTERRUPT_SIGNAL, OP_YIELD_NOW, yieldNow } from './fiberMessage.esm.js';\nimport { get, joinAs, delete_, updatedAs, forkAs, getOrDefault as getOrDefault$1 } from './fiberRefs.esm.js';\nimport { globalScope, unsafeMake } from './fiberScope.esm.js';\nimport { makeLogger, stringLogger, logfmtLogger, serializeUnknown } from './logger.esm.js';\nimport { counter, tagged, histogram } from './metric.esm.js';\nimport { exponential } from './metric/boundaries.esm.js';\nimport { make as make$3 } from './metric/label.esm.js';\nimport { OP_FAILURE, OP_SUCCESS, OP_YIELD, OP_ASYNC, OP_ON_FAILURE, OP_ON_SUCCESS, OP_WHILE, OP_TAG, OP_SYNC, OP_REVERT_FLAGS, OP_ON_SUCCESS_AND_FAILURE, OP_WITH_RUNTIME, OP_UPDATE_RUNTIME_FLAGS, OP_COMMIT } from './opCodes/effect.esm.js';\nimport { complete } from './request.esm.js';\nimport { patch, diff, runtimeMetrics, WindDown, Interruption, interruptible as interruptible$1, enable, cooperativeYielding, OpSupervision, none as none$3 } from './runtimeFlags.esm.js';\nimport { none as none$1 } from './supervisor.esm.js';\nimport { differ, empty as empty$1 } from './supervisor/patch.esm.js';\nimport { tracerTag } from './tracer.esm.js';\nimport { head, prepend as prepend$1 } from '../List/dist/effect-List.esm.js';\nimport { fromLiteral, greaterThan } from '../LogLevel/dist/effect-LogLevel.esm.js';\nimport { make as make$4, compareAndSet } from '../MutableRef/dist/effect-MutableRef.esm.js';\nimport { flatMap, map, some, none, match, fromNullable, isSome, getOrElse } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isIterable } from '../Predicate/dist/effect-Predicate.esm.js';\nimport { fromIterable, filterMap, reduce, flatten as flatten$1, reduceRight, compact } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\nimport { make as make$1, modify, update, get as get$2 } from '../Ref/dist/effect-Ref.esm.js';\nimport { empty, exclude } from '../RuntimeFlagsPatch/dist/effect-RuntimeFlagsPatch.esm.js';\nimport { currentScheduler } from '../Scheduler/dist/effect-Scheduler.esm.js';\n\n/** @internal */\nconst fiberStarted = /*#__PURE__*/counter(\"effect_fiber_started\");\n/** @internal */\nconst fiberActive = /*#__PURE__*/counter(\"effect_fiber_active\");\n/** @internal */\nconst fiberSuccesses = /*#__PURE__*/counter(\"effect_fiber_successes\");\n/** @internal */\nconst fiberFailures = /*#__PURE__*/counter(\"effect_fiber_failures\");\n/** @internal */\nconst fiberLifetimes = /*#__PURE__*/tagged( /*#__PURE__*/histogram(\"effect_fiber_lifetimes\", /*#__PURE__*/exponential({\n  start: 1.0,\n  factor: 1.3,\n  count: 100\n})), \"time_unit\", \"milliseconds\");\n\n/** @internal */\n\n/** @internal */\nconst EvaluationSignalContinue = \"Continue\";\n\n/** @internal */\n\n/** @internal */\nconst EvaluationSignalDone = \"Done\";\n\n/** @internal */\n\n/** @internal */\nconst EvaluationSignalYieldNow = \"Yield\";\n\n/** @internal */\n\n/** @internal */\nconst runtimeFiberVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\nconst absurd = _ => {\n  throw new Error(`BUG: FiberRuntime - ${JSON.stringify(_)} - please report an issue at https://github.com/Effect-TS/io/issues`);\n};\nconst contOpSuccess = {\n  [OP_ON_SUCCESS]: (_, cont, value) => {\n    return cont.i1(value);\n  },\n  [\"OnStep\"]: (_, cont, value) => {\n    return cont.i1(exitSucceed(value));\n  },\n  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {\n    return cont.i2(value);\n  },\n  [OP_REVERT_FLAGS]: (self, cont, value) => {\n    self.patchRuntimeFlags(self._runtimeFlags, cont.patch);\n    if (interruptible$1(self._runtimeFlags) && self.isInterrupted()) {\n      return exitFailCause(self.getInterruptedCause());\n    } else {\n      return exitSucceed(value);\n    }\n  },\n  [OP_WHILE]: (self, cont, value) => {\n    cont.i2(value);\n    if (cont.i0()) {\n      self.pushStack(cont);\n      return cont.i1();\n    } else {\n      return unit;\n    }\n  }\n};\nconst drainQueueWhileRunningTable = {\n  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {\n    self.processNewInterruptSignal(message.cause);\n    return interruptible$1(runtimeFlags) ? exitFailCause(message.cause) : cur;\n  },\n  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {\n    throw new Error(\"It is illegal to have multiple concurrent run loops in a single fiber\");\n  },\n  [OP_STATEFUL]: (self, runtimeFlags, cur, message) => {\n    message.onFiber(self, running(runtimeFlags));\n    return cur;\n  },\n  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {\n    return flatMap$1(yieldNow$1(), () => cur);\n  }\n};\n\n/**\n * Executes all requests, submitting requests to each data source in parallel.\n */\nconst runBlockedRequests = self => forEachSequentialDiscard(flatten$2(self), requestsByRequestResolver => forEachParUnboundedDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential]) => {\n  const map = new Map();\n  for (const block of sequential) {\n    for (const entry of block) {\n      map.set(entry.request, entry);\n    }\n  }\n  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(sequential), sequential.flat()), currentRequestMap, map);\n}, false));\n\n/** @internal */\nclass FiberRuntime {\n  [FiberTypeId] = fiberVariance;\n  [RuntimeFiberTypeId] = runtimeFiberVariance;\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  _queue = new Array();\n  _children = null;\n  _observers = new Array();\n  _running = false;\n  _stack = [];\n  _asyncInterruptor = null;\n  _asyncBlockingOn = null;\n  _exitValue = null;\n  _steps = [false];\n  currentOpCount = 0;\n  isYielding = false;\n  constructor(fiberId, fiberRefs0, runtimeFlags0) {\n    this._runtimeFlags = runtimeFlags0;\n    this._fiberId = fiberId;\n    this._fiberRefs = fiberRefs0;\n    this._supervisor = this.getFiberRef(currentSupervisor);\n    this._scheduler = this.getFiberRef(currentScheduler);\n    if (runtimeMetrics(runtimeFlags0)) {\n      const tags = this.getFiberRef(currentMetricLabels);\n      fiberStarted.unsafeUpdate(1, tags);\n      fiberActive.unsafeUpdate(1, tags);\n    }\n    this._tracer = get$1(this.getFiberRef(currentServices), tracerTag);\n  }\n\n  /**\n   * The identity of the fiber.\n   */\n  id() {\n    return this._fiberId;\n  }\n\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background. This can be called to \"kick off\" execution of a fiber after\n   * it has been created.\n   */\n  resume(effect) {\n    this.tell(resume(effect));\n  }\n\n  /**\n   * The status of the fiber.\n   */\n  status() {\n    return this.ask((_, status) => status);\n  }\n\n  /**\n   * Gets the fiber runtime flags.\n   */\n  runtimeFlags() {\n    return this.ask((state, status) => {\n      if (isDone(status)) {\n        return state._runtimeFlags;\n      }\n      return status.runtimeFlags;\n    });\n  }\n\n  /**\n   * Returns the current `FiberScope` for the fiber.\n   */\n  scope() {\n    return unsafeMake(this);\n  }\n\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  children() {\n    return this.ask(fiber => Array.from(fiber.getChildren()));\n  }\n\n  /**\n   * Gets the fiber's set of children.\n   */\n  getChildren() {\n    if (this._children === null) {\n      this._children = new Set();\n    }\n    return this._children;\n  }\n\n  /**\n   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`\n   * if the fiber has not been interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getInterruptedCause() {\n    return this.getFiberRef(currentInterruptedCause);\n  }\n\n  /**\n   * Retrieves the whole set of fiber refs.\n   */\n  fiberRefs() {\n    return this.ask(fiber => fiber.getFiberRefs());\n  }\n\n  /**\n   * Returns an effect that will contain information computed from the fiber\n   * state and status while running on the fiber.\n   *\n   * This allows the outside world to interact safely with mutable fiber state\n   * without locks or immutable data.\n   */\n  ask(f) {\n    return suspend(() => {\n      const deferred = deferredUnsafeMake(this._fiberId);\n      this.tell(stateful((fiber, status) => {\n        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));\n      }));\n      return deferredAwait(deferred);\n    });\n  }\n\n  /**\n   * Adds a message to be processed by the fiber on the fiber.\n   */\n  tell(message) {\n    this._queue.push(message);\n    if (!this._running) {\n      this._running = true;\n      this.drainQueueLaterOnExecutor();\n    }\n  }\n  await() {\n    return async(resume => {\n      const cb = exit => resume(succeed(exit));\n      this.tell(stateful((fiber, _) => {\n        if (fiber._exitValue !== null) {\n          cb(this._exitValue);\n        } else {\n          fiber.addObserver(cb);\n        }\n      }));\n      return sync(() => this.tell(stateful((fiber, _) => {\n        fiber.removeObserver(cb);\n      })));\n    }, this.id());\n  }\n  inheritAll() {\n    return withFiberRuntime((parentFiber, parentStatus) => {\n      const parentFiberId = parentFiber.id();\n      const parentFiberRefs = parentFiber.getFiberRefs();\n      const parentRuntimeFlags = parentStatus.runtimeFlags;\n      const childFiberRefs = this.getFiberRefs();\n      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);\n      parentFiber.setFiberRefs(updatedFiberRefs);\n      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);\n      const patch = pipe(diff(parentRuntimeFlags, updatedRuntimeFlags),\n      // Do not inherit WindDown or Interruption!\n      exclude(Interruption), exclude(WindDown));\n      return updateRuntimeFlags(patch);\n    });\n  }\n\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  poll() {\n    return sync(() => fromNullable(this._exitValue));\n  }\n\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll() {\n    return this._exitValue;\n  }\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  interruptAsFork(fiberId) {\n    return sync(() => this.tell(interruptSignal(interrupt(fiberId))));\n  }\n\n  /**\n   * Adds an observer to the list of observers.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addObserver(observer) {\n    if (this._exitValue !== null) {\n      observer(this._exitValue);\n    } else {\n      this._observers.push(observer);\n    }\n  }\n\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeObserver(observer) {\n    this._observers = this._observers.filter(o => o !== observer);\n  }\n  /**\n   * Retrieves all fiber refs of the fiber.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRefs() {\n    this.setFiberRef(currentRuntimeFlags, this._runtimeFlags);\n    return this._fiberRefs;\n  }\n\n  /**\n   * Deletes the specified fiber ref.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeDeleteFiberRef(fiberRef) {\n    this._fiberRefs = delete_(this._fiberRefs, fiberRef);\n  }\n\n  /**\n   * Retrieves the state of the fiber ref, or else its initial value.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRef(fiberRef) {\n    if (this._fiberRefs.locals.has(fiberRef)) {\n      return this._fiberRefs.locals.get(fiberRef)[0][1];\n    }\n    return fiberRef.initial;\n  }\n\n  /**\n   * Sets the fiber ref to the specified value.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRef(fiberRef, value) {\n    this._fiberRefs = updatedAs(this._fiberRefs, {\n      fiberId: this._fiberId,\n      fiberRef,\n      value\n    });\n    this.refreshRefCache();\n  }\n  refreshRefCache() {\n    this._tracer = get$1(this.getFiberRef(currentServices), tracerTag);\n    this._supervisor = this.getFiberRef(currentSupervisor);\n    this._scheduler = this.getFiberRef(currentScheduler);\n  }\n\n  /**\n   * Wholesale replaces all fiber refs of this fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRefs(fiberRefs) {\n    this._fiberRefs = fiberRefs;\n    this.refreshRefCache();\n  }\n\n  /**\n   * Adds a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addChild(child) {\n    this.getChildren().add(child);\n  }\n\n  /**\n   * Removes a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeChild(child) {\n    this.getChildren().delete(child);\n  }\n\n  /**\n   * On the current thread, executes all messages in the fiber's inbox. This\n   * method may return before all work is done, in the event the fiber executes\n   * an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueOnCurrentThread() {\n    let recurse = true;\n    while (recurse) {\n      let evaluationSignal = EvaluationSignalContinue;\n      const prev = globalThis[currentFiberURI];\n      globalThis[currentFiberURI] = this;\n      try {\n        while (evaluationSignal === EvaluationSignalContinue) {\n          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);\n        }\n      } finally {\n        this._running = false;\n        globalThis[currentFiberURI] = prev;\n      }\n      // Maybe someone added something to the queue between us checking, and us\n      // giving up the drain. If so, we need to restart the draining, but only\n      // if we beat everyone else to the restart:\n      if (this._queue.length > 0 && !this._running) {\n        this._running = true;\n        if (evaluationSignal === EvaluationSignalYieldNow) {\n          this.drainQueueLaterOnExecutor();\n          recurse = false;\n        } else {\n          recurse = true;\n        }\n      } else {\n        recurse = false;\n      }\n    }\n  }\n\n  /**\n   * Schedules the execution of all messages in the fiber's inbox.\n   *\n   * This method will return immediately after the scheduling\n   * operation is completed, but potentially before such messages have been\n   * executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueLaterOnExecutor() {\n    this._scheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));\n  }\n\n  /**\n   * Drains the fiber's message queue while the fiber is actively running,\n   * returning the next effect to execute, which may be the input effect if no\n   * additional effect needs to be executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueWhileRunning(runtimeFlags, cur0) {\n    let cur = cur0;\n    while (this._queue.length > 0) {\n      const message = this._queue.splice(0, 1)[0];\n      // @ts-expect-error\n      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);\n    }\n    return cur;\n  }\n\n  /**\n   * Determines if the fiber is interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  isInterrupted() {\n    return !isEmpty(this.getFiberRef(currentInterruptedCause));\n  }\n\n  /**\n   * Adds an interruptor to the set of interruptors that are interrupting this\n   * fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addInterruptedCause(cause) {\n    const oldSC = this.getFiberRef(currentInterruptedCause);\n    this.setFiberRef(currentInterruptedCause, sequential$1(oldSC, cause));\n  }\n\n  /**\n   * Processes a new incoming interrupt signal.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  processNewInterruptSignal(cause) {\n    this.addInterruptedCause(cause);\n    this.sendInterruptSignalToAllChildren();\n  }\n\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  sendInterruptSignalToAllChildren() {\n    if (this._children === null || this._children.size === 0) {\n      return false;\n    }\n    let told = false;\n    for (const child of this._children) {\n      child.tell(interruptSignal(interrupt(this.id())));\n      told = true;\n    }\n    return told;\n  }\n\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  interruptAllChildren() {\n    if (this.sendInterruptSignalToAllChildren()) {\n      const it = this._children.values();\n      this._children = null;\n      let isDone = false;\n      const body = () => {\n        const next = it.next();\n        if (!next.done) {\n          return asUnit(next.value.await());\n        } else {\n          return sync(() => {\n            isDone = true;\n          });\n        }\n      };\n      return whileLoop({\n        while: () => !isDone,\n        body,\n        step: () => {\n          //\n        }\n      });\n    }\n    return null;\n  }\n  reportExitValue(exit) {\n    if (runtimeMetrics(this._runtimeFlags)) {\n      const tags = this.getFiberRef(currentMetricLabels);\n      fiberActive.unsafeUpdate(-1, tags);\n      switch (exit._tag) {\n        case OP_SUCCESS:\n          {\n            fiberSuccesses.unsafeUpdate(1, tags);\n            break;\n          }\n        case OP_FAILURE:\n          {\n            fiberFailures.unsafeUpdate(1, tags);\n            break;\n          }\n      }\n    }\n    if (exit._tag === \"Failure\") {\n      const level = this.getFiberRef(currentUnhandledErrorLogLevel);\n      if (!isInterruptedOnly(exit.cause) && level._tag === \"Some\") {\n        this.log(\"Fiber terminated with a non handled error\", exit.cause, level);\n      }\n    }\n  }\n  setExitValue(exit) {\n    this._exitValue = exit;\n    if (runtimeMetrics(this._runtimeFlags)) {\n      const tags = this.getFiberRef(currentMetricLabels);\n      const startTimeMillis = this.id().startTimeMillis;\n      const endTimeMillis = new Date().getTime();\n      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);\n    }\n    this.reportExitValue(exit);\n    for (let i = this._observers.length - 1; i >= 0; i--) {\n      this._observers[i](exit);\n    }\n  }\n  getLoggers() {\n    return this.getFiberRef(currentLoggers);\n  }\n  log(message, cause, overrideLogLevel) {\n    const logLevel = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);\n    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);\n    if (greaterThan(minimumLogLevel, logLevel)) {\n      return;\n    }\n    const spans = this.getFiberRef(currentLogSpan);\n    const annotations = this.getFiberRef(currentLogAnnotations);\n    const loggers = this.getLoggers();\n    const contextMap = this.getFiberRefs();\n    if (size(loggers) > 0) {\n      const clockService = get$1(this.getFiberRef(currentServices), clockTag);\n      const date = new Date(clockService.unsafeCurrentTimeMillis());\n      for (const logger of loggers) {\n        logger.log({\n          fiberId: this.id(),\n          logLevel,\n          message,\n          cause,\n          context: contextMap,\n          spans,\n          annotations,\n          date\n        });\n      }\n    }\n  }\n\n  /**\n   * Evaluates a single message on the current thread, while the fiber is\n   * suspended. This method should only be called while evaluation of the\n   * fiber's effect is suspended due to an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateMessageWhileSuspended(message) {\n    switch (message._tag) {\n      case OP_YIELD_NOW:\n        {\n          return EvaluationSignalYieldNow;\n        }\n      case OP_INTERRUPT_SIGNAL:\n        {\n          this.processNewInterruptSignal(message.cause);\n          if (this._asyncInterruptor !== null) {\n            this._asyncInterruptor(exitFailCause(message.cause));\n            this._asyncInterruptor = null;\n          }\n          return EvaluationSignalContinue;\n        }\n      case OP_RESUME:\n        {\n          this._asyncInterruptor = null;\n          this._asyncBlockingOn = null;\n          this.evaluateEffect(message.effect);\n          return EvaluationSignalContinue;\n        }\n      case OP_STATEFUL:\n        {\n          message.onFiber(this, this._exitValue !== null ? done : suspended(this._runtimeFlags, this._asyncBlockingOn));\n          return EvaluationSignalContinue;\n        }\n      default:\n        {\n          return absurd(message);\n        }\n    }\n  }\n\n  /**\n   * Evaluates an effect until completion, potentially asynchronously.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateEffect(effect0) {\n    this._supervisor.onResume(this);\n    try {\n      let effect = interruptible$1(this._runtimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;\n      while (effect !== null) {\n        try {\n          const eff = effect;\n          const exit = this.runLoop(eff);\n          this._runtimeFlags = pipe(this._runtimeFlags, enable(WindDown));\n          const interruption = this.interruptAllChildren();\n          if (interruption !== null) {\n            effect = flatMap$1(interruption, () => exit);\n          } else {\n            if (this._queue.length === 0) {\n              // No more messages to process, so we will allow the fiber to end life:\n              this.setExitValue(exit);\n            } else {\n              // There are messages, possibly added by the final op executed by\n              // the fiber. To be safe, we should execute those now before we\n              // allow the fiber to end life:\n              this.tell(resume(exit));\n            }\n            effect = null;\n          }\n        } catch (e) {\n          if (isEffect(e)) {\n            if (e._op === OP_YIELD) {\n              if (cooperativeYielding(this._runtimeFlags)) {\n                this.tell(yieldNow());\n                this.tell(resume(exitUnit));\n                effect = null;\n              } else {\n                effect = exitUnit;\n              }\n            } else if (e._op === OP_ASYNC) {\n              // Terminate this evaluation, async resumption will continue evaluation:\n              effect = null;\n            }\n          } else {\n            throw e;\n          }\n        }\n      }\n    } finally {\n      this._supervisor.onSuspend(this);\n    }\n  }\n\n  /**\n   * Begins execution of the effect associated with this fiber on the current\n   * thread. This can be called to \"kick off\" execution of a fiber after it has\n   * been created, in hopes that the effect can be executed synchronously.\n   *\n   * This is not the normal way of starting a fiber, but it is useful when the\n   * express goal of executing the fiber is to synchronously produce its exit.\n   */\n  start(effect) {\n    if (!this._running) {\n      this._running = true;\n      const prev = globalThis[currentFiberURI];\n      globalThis[currentFiberURI] = this;\n      try {\n        this.evaluateEffect(effect);\n      } finally {\n        this._running = false;\n        globalThis[currentFiberURI] = prev;\n        // Because we're special casing `start`, we have to be responsible\n        // for spinning up the fiber if there were new messages added to\n        // the queue between the completion of the effect and the transition\n        // to the not running state.\n        if (this._queue.length > 0) {\n          this.drainQueueLaterOnExecutor();\n        }\n      }\n    } else {\n      this.tell(resume(effect));\n    }\n  }\n\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background, and on the correct thread pool. This can be called to \"kick\n   * off\" execution of a fiber after it has been created, in hopes that the\n   * effect can be executed synchronously.\n   */\n  startFork(effect) {\n    this.tell(resume(effect));\n  }\n\n  /**\n   * Takes the current runtime flags, patches them to return the new runtime\n   * flags, and then makes any changes necessary to fiber state based on the\n   * specified patch.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  patchRuntimeFlags(oldRuntimeFlags, patch$1) {\n    const newRuntimeFlags = patch(oldRuntimeFlags, patch$1);\n    globalThis[currentFiberURI] = this;\n    this._runtimeFlags = newRuntimeFlags;\n    return newRuntimeFlags;\n  }\n\n  /**\n   * Initiates an asynchronous operation, by building a callback that will\n   * resume execution, and then feeding that callback to the registration\n   * function, handling error cases and repeated resumptions appropriately.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  initiateAsync(runtimeFlags, asyncRegister) {\n    let alreadyCalled = false;\n    const callback = effect => {\n      if (!alreadyCalled) {\n        alreadyCalled = true;\n        this.tell(resume(effect));\n      }\n    };\n    if (interruptible$1(runtimeFlags)) {\n      this._asyncInterruptor = callback;\n    }\n    try {\n      asyncRegister(callback);\n    } catch (e) {\n      callback(failCause(die(e)));\n    }\n  }\n  pushStack(cont) {\n    this._stack.push(cont);\n    if (cont._op === \"OnStep\") {\n      this._steps.push(true);\n    }\n    if (cont._op === \"RevertFlags\") {\n      this._steps.push(false);\n    }\n  }\n  popStack() {\n    const item = this._stack.pop();\n    if (item) {\n      if (item._op === \"OnStep\" || item._op === \"RevertFlags\") {\n        this._steps.pop();\n      }\n      return item;\n    }\n    return;\n  }\n  getNextSuccessCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._op !== OP_ON_FAILURE) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  getNextFailCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  [OP_TAG](op) {\n    return map$2(fiberRefGet(currentContext), context => {\n      try {\n        return unsafeGet(context, op);\n      } catch (e) {\n        console.log(e);\n        throw e;\n      }\n    });\n  }\n  [\"Left\"](op) {\n    return fail(op.left);\n  }\n  [\"None\"](_) {\n    return fail(NoSuchElementException());\n  }\n  [\"Right\"](op) {\n    return exitSucceed(op.right);\n  }\n  [\"Some\"](op) {\n    return exitSucceed(op.value);\n  }\n  [OP_SYNC](op) {\n    const value = op.i0();\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._op in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._op](this, cont, value);\n    } else {\n      throw exitSucceed(value);\n    }\n  }\n  [OP_SUCCESS](op) {\n    const oldCur = op;\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._op in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._op](this, cont, oldCur.i0);\n    } else {\n      throw oldCur;\n    }\n  }\n  [OP_FAILURE](op) {\n    const cause = op.i0;\n    const cont = this.getNextFailCont();\n    if (cont !== undefined) {\n      switch (cont._op) {\n        case OP_ON_FAILURE:\n        case OP_ON_SUCCESS_AND_FAILURE:\n          {\n            if (!(interruptible$1(this._runtimeFlags) && this.isInterrupted())) {\n              return cont.i1(cause);\n            } else {\n              return exitFailCause(stripFailures(cause));\n            }\n          }\n        case \"OnStep\":\n          {\n            if (!(interruptible$1(this._runtimeFlags) && this.isInterrupted())) {\n              return cont.i1(exitFailCause(cause));\n            } else {\n              return exitFailCause(stripFailures(cause));\n            }\n          }\n        case OP_REVERT_FLAGS:\n          {\n            this.patchRuntimeFlags(this._runtimeFlags, cont.patch);\n            if (interruptible$1(this._runtimeFlags) && this.isInterrupted()) {\n              return exitFailCause(sequential$1(cause, this.getInterruptedCause()));\n            } else {\n              return exitFailCause(cause);\n            }\n          }\n        default:\n          {\n            absurd(cont);\n          }\n      }\n    } else {\n      throw exitFailCause(cause);\n    }\n  }\n  [OP_WITH_RUNTIME](op) {\n    return op.i0(this, running(this._runtimeFlags));\n  }\n  [\"Blocked\"](op) {\n    if (this._steps[this._steps.length - 1]) {\n      const nextOp = this.popStack();\n      if (nextOp) {\n        switch (nextOp._op) {\n          case \"OnStep\":\n            {\n              return nextOp.i1(op);\n            }\n          case \"OnSuccess\":\n            {\n              return blocked(op.i0, flatMap$1(op.i1, nextOp.i1));\n            }\n          case \"OnSuccessAndFailure\":\n            {\n              return blocked(op.i0, matchCauseEffect(op.i1, {\n                onFailure: nextOp.i1,\n                onSuccess: nextOp.i2\n              }));\n            }\n          case \"OnFailure\":\n            {\n              return blocked(op.i0, catchAllCause(op.i1, nextOp.i1));\n            }\n          case \"While\":\n            {\n              return blocked(op.i0, flatMap$1(op.i1, a => {\n                nextOp.i2(a);\n                if (nextOp.i0()) {\n                  return whileLoop({\n                    while: nextOp.i0,\n                    body: nextOp.i1,\n                    step: nextOp.i2\n                  });\n                }\n                return unit;\n              }));\n            }\n          case \"RevertFlags\":\n            {\n              this.pushStack(nextOp);\n              break;\n            }\n        }\n      }\n    }\n    return uninterruptibleMask(restore => flatMap$1(fork(runRequestBlock(op.i0)), () => restore(op.i1)));\n  }\n  [\"RunBlocked\"](op) {\n    return runBlockedRequests(op.i0);\n  }\n  [OP_UPDATE_RUNTIME_FLAGS](op) {\n    const updateFlags = op.i0;\n    const oldRuntimeFlags = this._runtimeFlags;\n    const newRuntimeFlags = patch(oldRuntimeFlags, updateFlags);\n    // One more chance to short circuit: if we're immediately going\n    // to interrupt. Interruption will cause immediate reversion of\n    // the flag, so as long as we \"peek ahead\", there's no need to\n    // set them to begin with.\n    if (interruptible$1(newRuntimeFlags) && this.isInterrupted()) {\n      return exitFailCause(this.getInterruptedCause());\n    } else {\n      // Impossible to short circuit, so record the changes\n      this.patchRuntimeFlags(this._runtimeFlags, updateFlags);\n      if (op.i1) {\n        // Since we updated the flags, we need to revert them\n        const revertFlags = diff(newRuntimeFlags, oldRuntimeFlags);\n        this.pushStack(new RevertFlags(revertFlags, op));\n        return op.i1(oldRuntimeFlags);\n      } else {\n        return exitUnit;\n      }\n    }\n  }\n  [OP_ON_SUCCESS](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [\"OnStep\"](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OP_ON_FAILURE](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OP_ON_SUCCESS_AND_FAILURE](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OP_ASYNC](op) {\n    this._asyncBlockingOn = op.i1;\n    this.initiateAsync(this._runtimeFlags, op.i0);\n    throw op;\n  }\n  [OP_YIELD](op) {\n    this.isYielding = false;\n    throw op;\n  }\n  [OP_WHILE](op) {\n    const check = op.i0;\n    const body = op.i1;\n    if (check()) {\n      this.pushStack(op);\n      return body();\n    } else {\n      return exitUnit;\n    }\n  }\n  [OP_COMMIT](op) {\n    return op.commit();\n  }\n\n  /**\n   * The main run-loop for evaluating effects.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  runLoop(effect0) {\n    let cur = effect0;\n    this.currentOpCount = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if ((this._runtimeFlags & OpSupervision) !== 0) {\n        this._supervisor.onEffect(this, cur);\n      }\n      if (this._queue.length > 0) {\n        cur = this.drainQueueWhileRunning(this._runtimeFlags, cur);\n      }\n      if (!this.isYielding) {\n        this.currentOpCount += 1;\n        const shouldYield = this._scheduler.shouldYield(this);\n        if (shouldYield !== false) {\n          this.isYielding = true;\n          this.currentOpCount = 0;\n          const oldCur = cur;\n          cur = flatMap$1(yieldNow$1({\n            priority: shouldYield\n          }), () => oldCur);\n        }\n      }\n      try {\n        if (!(\"_op\" in cur)) {\n          console.log(cur);\n        }\n        if (!(cur._op in this)) {\n          if (typeof cur === \"function\") {\n            console.log(cur());\n          }\n          // @ts-expect-error\n          absurd(cur);\n        }\n        // @ts-expect-error\n        cur = this._tracer.context(\n        // @ts-expect-error\n        () => this[cur._op](cur), this);\n      } catch (e) {\n        if (isEffect(e)) {\n          if (e._op === OP_YIELD || e._op === OP_ASYNC) {\n            throw e;\n          }\n          if (e._op === OP_SUCCESS || e._op === OP_FAILURE) {\n            return e;\n          }\n        } else {\n          if (isEffectError(e)) {\n            cur = exitFailCause(e.cause);\n          } else if (isInterruptedException(e)) {\n            cur = exitFailCause(sequential$1(die(e), interrupt(none$2)));\n          } else {\n            cur = exitFailCause(die(e));\n          }\n        }\n      }\n    }\n  }\n  run = () => {\n    this.drainQueueOnCurrentThread();\n  };\n}\n\n// circular with Logger\n\n/** @internal */\nconst currentMinimumLogLevel = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/fromLiteral(\"Info\"));\n\n/** @internal */\nconst getConsole = refs => {\n  const defaultServicesValue = getOrDefault(refs, currentServices);\n  const cnsl = get$1(defaultServicesValue, consoleTag);\n  return cnsl.unsafe;\n};\n\n/** @internal */\nconst defaultLogger = /*#__PURE__*/makeLogger(options => {\n  const formatted = stringLogger.log(options);\n  getConsole(options.context).log(formatted);\n});\n\n/** @internal */\nconst logFmtLogger = /*#__PURE__*/makeLogger(options => {\n  const formatted = logfmtLogger.log(options);\n  getConsole(options.context).log(formatted);\n});\n\n/** @internal */\nconst tracerLogger = /*#__PURE__*/makeLogger(({\n  annotations,\n  cause,\n  context,\n  fiberId,\n  logLevel,\n  message\n}) => {\n  const span = flatMap(get(context, currentTracerSpan), head);\n  const clockService = map(get(context, currentServices), _ => get$1(_, clockTag));\n  if (span._tag === \"None\" || span.value._tag === \"ExternalSpan\" || clockService._tag === \"None\") {\n    return;\n  }\n  const attributes = Object.fromEntries(map$1(annotations, value => serializeUnknown(value)));\n  attributes[\"effect.fiberId\"] = threadName(fiberId);\n  attributes[\"effect.logLevel\"] = logLevel.label;\n  if (cause !== null && cause._tag !== \"Empty\") {\n    attributes[\"effect.cause\"] = pretty(cause);\n  }\n  span.value.event(String(message), clockService.value.unsafeCurrentTimeNanos(), attributes);\n});\n\n/** @internal */\nconst currentLoggers = /*#__PURE__*/fiberRefUnsafeMakeHashSet( /*#__PURE__*/make(defaultLogger, tracerLogger));\n\n// circular with Effect\n\n/* @internal */\nconst acquireRelease = /*#__PURE__*/dual(args => isEffect(args[0]), (acquire, release) => {\n  return uninterruptible(tap(acquire, a => addFinalizer(exit => release(a, exit))));\n});\n\n/* @internal */\nconst acquireReleaseInterruptible = /*#__PURE__*/dual(args => isEffect(args[0]), (acquire, release) => {\n  return ensuring(acquire, addFinalizer(exit => release(exit)));\n});\n\n/* @internal */\nconst addFinalizer = finalizer => withFiberRuntime(runtime => {\n  const acquireRefs = runtime.getFiberRefs();\n  const acquireFlags = runtime._runtimeFlags;\n  return flatMap$1(scope, scope => scopeAddFinalizerExit(scope, exit => withFiberRuntime(runtimeFinalizer => {\n    const preRefs = runtimeFinalizer.getFiberRefs();\n    const preFlags = runtimeFinalizer._runtimeFlags;\n    const patchRefs = diff$1(preRefs, acquireRefs);\n    const patchFlags = diff(preFlags, acquireFlags);\n    const inverseRefs = diff$1(acquireRefs, preRefs);\n    runtimeFinalizer.setFiberRefs(patch$1(patchRefs, runtimeFinalizer.id(), acquireRefs));\n    return ensuring(withRuntimeFlags(finalizer(exit), patchFlags), sync(() => {\n      runtimeFinalizer.setFiberRefs(patch$1(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));\n    }));\n  })));\n});\n\n/* @internal */\nconst daemonChildren = self => {\n  const forkScope = fiberRefLocally(currentForkScopeOverride, some(globalScope));\n  return forkScope(self);\n};\n\n/** @internal */\nconst _existsParFound = /*#__PURE__*/Symbol.for(\"effect/Effect/existsPar/found\");\n\n/* @internal */\nconst exists = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, f, options) => matchSimple(options, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, f)), () => matchEffect(forEachOptions(elements, (a, i) => if_(f(a, i), {\n  onTrue: fail(_existsParFound),\n  onFalse: unit\n}), options), {\n  onFailure: e => e === _existsParFound ? succeed(true) : fail(e),\n  onSuccess: () => succeed(false)\n})));\nconst existsLoop = (iterator, index, f) => {\n  const next = iterator.next();\n  if (next.done) {\n    return succeed(false);\n  }\n  return pipe(flatMap$1(f(next.value, index), b => b ? succeed(b) : existsLoop(iterator, index + 1, f)));\n};\n\n/* @internal */\nconst filter = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, f, options) => {\n  const predicate = options?.negate ? (a, i) => map$2(f(a, i), not) : f;\n  return matchSimple(options, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith(effect, suspend(() => predicate(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map$2(forEachOptions(elements, (a, i) => map$2(predicate(a, i), b => b ? some(a) : none()), options), compact));\n});\n\n// === all\n\nconst allResolveInput = input => {\n  if (Array.isArray(input) || isIterable(input)) {\n    return [input, none()];\n  }\n  const keys = Object.keys(input);\n  const size = keys.length;\n  return [keys.map(k => input[k]), some(values => {\n    const res = {};\n    for (let i = 0; i < size; i++) {\n      res[keys[i]] = values[i];\n    }\n    return res;\n  })];\n};\nconst allValidate = (effects, reconcile, options) => {\n  const eitherEffects = [];\n  for (const effect of effects) {\n    eitherEffects.push(either(effect));\n  }\n  return flatMap$1(forEachOptions(eitherEffects, identity, {\n    concurrency: options?.concurrency,\n    batching: options?.batching\n  }), eithers => {\n    const none$1 = none();\n    const size = eithers.length;\n    const errors = new Array(size);\n    const successes = new Array(size);\n    let errored = false;\n    for (let i = 0; i < size; i++) {\n      const either = eithers[i];\n      if (either._tag === \"Left\") {\n        errors[i] = some(either.left);\n        errored = true;\n      } else {\n        successes[i] = either.right;\n        errors[i] = none$1;\n      }\n    }\n    if (errored) {\n      return reconcile._tag === \"Some\" ? fail(reconcile.value(errors)) : fail(errors);\n    } else if (options?.discard) {\n      return unit;\n    }\n    return reconcile._tag === \"Some\" ? succeed(reconcile.value(successes)) : succeed(successes);\n  });\n};\nconst allEither = (effects, reconcile, options) => {\n  const eitherEffects = [];\n  for (const effect of effects) {\n    eitherEffects.push(either(effect));\n  }\n  if (options?.discard) {\n    return forEachOptions(eitherEffects, identity, {\n      concurrency: options?.concurrency,\n      batching: options?.batching,\n      discard: true\n    });\n  }\n  return map$2(forEachOptions(eitherEffects, identity, {\n    concurrency: options?.concurrency,\n    batching: options?.batching\n  }), eithers => reconcile._tag === \"Some\" ? reconcile.value(eithers) : eithers);\n};\n\n/* @internal */\nconst all = (arg, options) => {\n  const [effects, reconcile] = allResolveInput(arg);\n  if (options?.mode === \"validate\") {\n    return allValidate(effects, reconcile, options);\n  } else if (options?.mode === \"either\") {\n    return allEither(effects, reconcile, options);\n  }\n  return reconcile._tag === \"Some\" ? map$2(forEachOptions(effects, identity, options), reconcile.value) : forEachOptions(effects, identity, options);\n};\n\n/* @internal */\nconst allWith = options => arg => all(arg, options);\n\n/* @internal */\nconst allSuccesses = (elements, options) => map$2(all(fromIterable(elements).map(exit), options), filterMap(exit => exitIsSuccess(exit) ? some(exit.i0) : none()));\n\n/* @internal */\nconst replicate = /*#__PURE__*/dual(2, (self, n) => Array.from({\n  length: n\n}, () => self));\n\n/* @internal */\nconst replicateEffect = /*#__PURE__*/dual(args => isEffect(args[0]), (self, n, options) => all(replicate(self, n), options));\n\n// @ts-expect-error\nconst forEachOptions = /*#__PURE__*/dual(args => isIterable(args[0]), (self, f, options) => withFiberRuntime(r => {\n  const requestBatchingEnabled = options?.batching === true || options?.batching === \"inherit\" && r.getFiberRef(currentRequestBatching);\n  if (options?.discard) {\n    return match$1(options, () => finalizersMask(sequential)(restore => requestBatchingEnabled ? forEachBatchedDiscard(self, (a, i) => restore(f(a, i))) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMask(parallel)(restore => forEachParUnboundedDiscard(self, (a, i) => restore(f(a, i)), requestBatchingEnabled)), n => finalizersMask(parallelN(n))(restore => forEachParNDiscard(self, n, (a, i) => restore(f(a, i)), requestBatchingEnabled)));\n  }\n  return match$1(options, () => finalizersMask(sequential)(restore => requestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMask(parallel)(restore => forEachParUnbounded(self, (a, i) => restore(f(a, i)), requestBatchingEnabled)), n => finalizersMask(parallelN(n))(restore => forEachParN(self, n, (a, i) => restore(f(a, i)), requestBatchingEnabled)));\n}));\n\n/* @internal */\nconst forEachParUnbounded = (self, f, batching) => suspend(() => {\n  const as = fromIterable(self);\n  const array = new Array(as.length);\n  const fn = (a, i) => flatMap$1(f(a, i), b => sync(() => array[i] = b));\n  return zipRight(forEachParUnboundedDiscard(as, fn, batching), succeed(array));\n});\nconst forEachBatchedDiscard = (self, f) => suspend(() => {\n  const as = fromIterable(self);\n  const size = as.length;\n  if (size === 0) {\n    return unit;\n  } else if (size === 1) {\n    return asUnit(f(as[0], 0));\n  }\n  const effects = as.map(f);\n  const blocked$1 = new Array();\n  const loop = i => i === effects.length ? suspend(() => {\n    if (blocked$1.length > 0) {\n      const requests = blocked$1.map(b => b.i0).reduce(par);\n      return blocked(requests, forEachBatchedDiscard(blocked$1.map(b => b.i1), identity));\n    }\n    return unit;\n  }) : flatMapStep(effects[i], s => {\n    if (s._op === \"Blocked\") {\n      blocked$1.push(s);\n      return loop(i + 1);\n    } else if (s._op === \"Failure\") {\n      return suspend(() => {\n        if (blocked$1.length > 0) {\n          const requests = blocked$1.map(b => b.i0).reduce(par);\n          return blocked(requests, flatMap$1(forEachBatchedDiscard(blocked$1.map(b => b.i1), identity), () => s));\n        }\n        return unit;\n      });\n    } else {\n      return loop(i + 1);\n    }\n  });\n  return loop(0);\n});\n\n/* @internal */\nconst forEachParUnboundedDiscard = (self, f, batching) => suspend(() => {\n  const as = fromIterable(self);\n  const size = as.length;\n  if (size === 0) {\n    return unit;\n  } else if (size === 1) {\n    return asUnit(f(as[0], 0));\n  }\n  return uninterruptibleMask(restore => {\n    const deferred = deferredUnsafeMake(none$2);\n    let ref = 0;\n    const residual = [];\n    const joinOrder = [];\n    const process = transplant(graft => forEachSequential(as, (a, i) => pipe(graft(pipe(suspend(() => restore((batching ? step : exit)(f(a, i)))), flatMap$1(exit => {\n      switch (exit._op) {\n        case \"Failure\":\n          {\n            if (residual.length > 0) {\n              const requests = residual.map(blocked => blocked.i0).reduce(par);\n              const _continue = forEachParUnboundedDiscard(residual, blocked => blocked.i1, batching);\n              return blocked(requests, matchCauseEffect(_continue, {\n                onFailure: cause => zipRight(deferredFail(deferred, void 0), failCause(parallel$1(cause, exit.cause))),\n                onSuccess: () => zipRight(deferredFail(deferred, void 0), failCause(exit.cause))\n              }));\n            }\n            return zipRight(deferredFail(deferred, void 0), failCause(exit.cause));\n          }\n        default:\n          {\n            if (exit._op === \"Blocked\") {\n              residual.push(exit);\n            }\n            if (ref + 1 === size) {\n              if (residual.length > 0) {\n                const requests = residual.map(blocked => blocked.i0).reduce(par);\n                const _continue = forEachParUnboundedDiscard(residual, blocked => blocked.i1, batching);\n                return deferredSucceed(deferred, blocked(requests, _continue));\n              } else {\n                deferredUnsafeDone(deferred, exitSucceed(exitUnit));\n              }\n            } else {\n              ref = ref + 1;\n            }\n            return unit;\n          }\n      }\n    }))), forkDaemon, map$2(fiber => {\n      fiber.addObserver(() => {\n        joinOrder.push(fiber);\n      });\n      return fiber;\n    }))));\n    return flatMap$1(process, fibers => matchCauseEffect(restore(deferredAwait(deferred)), {\n      onFailure: cause => flatMap$1(forEachParUnbounded(fibers, interruptFiber, batching), exits => {\n        const exit = exitCollectAll(exits, {\n          parallel: true\n        });\n        if (exit._tag === \"Some\" && exitIsFailure(exit.value)) {\n          return failCause(parallel$1(stripFailures(cause), exit.value.i0));\n        } else {\n          return failCause(stripFailures(cause));\n        }\n      }),\n      onSuccess: rest => flatMap$1(rest, () => forEachSequentialDiscard(joinOrder, f => f.inheritAll()))\n    }));\n  });\n});\n\n/* @internal */\nconst forEachParN = (self, n, f, batching) => suspend(() => {\n  const as = fromIterable(self);\n  const array = new Array(as.length);\n  const fn = (a, i) => map$2(f(a, i), b => array[i] = b);\n  return zipRight(forEachParNDiscard(as, n, fn, batching), succeed(array));\n});\n\n/* @internal */\nconst forEachParNDiscard = (self, n, f, batching) => suspend(() => {\n  let i = 0;\n  const iterator = self[Symbol.iterator]();\n  const residual = [];\n  const worker = flatMap$1(sync(() => iterator.next()), next => next.done ? unit : flatMap$1((batching ? step : exit)(asUnit(f(next.value, i++))), res => {\n    switch (res._op) {\n      case \"Blocked\":\n        {\n          residual.push(res);\n          return worker;\n        }\n      case \"Failure\":\n        {\n          return res;\n        }\n      case \"Success\":\n        return worker;\n    }\n  }));\n  const effects = [];\n  for (let i = 0; i < n; i++) {\n    effects.push(worker);\n  }\n  return flatMap$1(exit(forEachParUnboundedDiscard(effects, identity, batching)), exit => {\n    if (residual.length === 0) {\n      return exit;\n    }\n    const requests = residual.map(blocked => blocked.i0).reduce(par);\n    const _continue = forEachParNDiscard(residual, n, blocked => blocked.i1, batching);\n    if (exit._tag === \"Failure\") {\n      return blocked(requests, matchCauseEffect(_continue, {\n        onFailure: cause => exitFailCause(parallel$1(exit.cause, cause)),\n        onSuccess: () => exit\n      }));\n    }\n    return blocked(requests, _continue);\n  });\n});\n\n/* @internal */\nconst fork = self => withFiberRuntime((state, status) => succeed(unsafeFork(self, state, status.runtimeFlags)));\n\n/* @internal */\nconst forkDaemon = self => forkWithScopeOverride(self, globalScope);\n\n/* @internal */\nconst forkWithErrorHandler = /*#__PURE__*/dual(2, (self, handler) => fork(onError(self, cause => {\n  const either = failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return handler(either.left);\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n})));\n\n/** @internal */\nconst unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);\n  childFiber.resume(effect);\n  return childFiber;\n};\n\n/** @internal */\nconst unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childId = unsafeMake$1();\n  const parentFiberRefs = parentFiber.getFiberRefs();\n  const childFiberRefs = forkAs(parentFiberRefs, childId);\n  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);\n  const childContext = getOrDefault$1(childFiberRefs, currentContext);\n  const supervisor = childFiber._supervisor;\n  supervisor.onStart(childContext, effect, some(parentFiber), childFiber);\n  childFiber.addObserver(exit => supervisor.onEnd(exit, childFiber));\n  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));\n  parentScope.add(parentRuntimeFlags, childFiber);\n  return childFiber;\n};\n\n/* @internal */\nconst forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));\n\n/* @internal */\nconst mergeAll = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, zero, f, options) => matchSimple(options, () => fromIterable(elements).reduce((acc, a, i) => zipWith(acc, a, (acc, a) => f(acc, a, i)), succeed(zero)), () => flatMap$1(make$1(zero), acc => flatMap$1(forEachOptions(elements, (effect, i) => flatMap$1(effect, a => update(acc, b => f(b, a, i))), options), () => get$2(acc)))));\n\n/* @internal */\nconst partition = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, f, options) => pipe(forEachOptions(elements, (a, i) => either(f(a, i)), options), map$2(chunk => partitionMap(chunk, identity))));\n\n/* @internal */\nconst validateAll = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, f, options) => flatMap$1(partition(elements, f, {\n  concurrency: options?.concurrency,\n  batching: options?.batching\n}), ([es, bs]) => es.length === 0 ? options?.discard ? unit : succeed(bs) : fail(es)));\n\n/* @internal */\nconst raceAll = all => {\n  const list = fromIterable$1(all);\n  if (!isNonEmpty(list)) {\n    return dieSync(() => IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  const self = headNonEmpty(list);\n  const effects = tailNonEmpty(list);\n  const inheritAll$1 = res => pipe(inheritAll(res[1]), as(res[0]));\n  return pipe(deferredMake(), flatMap$1(done => pipe(make$1(effects.length), flatMap$1(fails => uninterruptibleMask(restore => pipe(fork(interruptible(self)), flatMap$1(head => pipe(effects, forEachSequential(effect => fork(interruptible(effect))), map$2(unsafeFromArray), map$2(tail => pipe(tail, prepend(head))), tap(fibers => pipe(fibers, reduce(unit, (effect, fiber) => pipe(effect, zipRight(pipe(_await(fiber), flatMap$1(raceAllArbiter(fibers, fiber, done, fails)), fork, asUnit)))))), flatMap$1(fibers => pipe(restore(pipe(_await$1(done), flatMap$1(inheritAll$1))), onInterrupt(() => pipe(fibers, reduce(unit, (effect, fiber) => pipe(effect, zipLeft(interruptFiber(fiber))))))))))))))));\n};\n\n/* @internal */\nconst raceAllArbiter = (fibers, winner, deferred, fails) => exit => exitMatchEffect(exit, {\n  onFailure: cause => pipe(modify(fails, fails => [fails === 0 ? pipe(deferredFailCause(deferred, cause), asUnit) : unit, fails - 1]), flatten),\n  onSuccess: value => pipe(deferredSucceed(deferred, [value, winner]), flatMap$1(set => set ? pipe(fromIterable$1(fibers), reduce(unit, (effect, fiber) => fiber === winner ? effect : pipe(effect, zipLeft(interruptFiber(fiber))))) : unit))\n});\n\n/* @internal */\nconst reduceEffect = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, zero, f, options) => matchSimple(options, () => fromIterable(elements).reduce((acc, a, i) => zipWith(acc, a, (acc, a) => f(acc, a, i)), zero), () => suspend(() => pipe(mergeAll([zero, ...elements], none(), (acc, elem, i) => {\n  switch (acc._tag) {\n    case \"None\":\n      {\n        return some(elem);\n      }\n    case \"Some\":\n      {\n        return some(f(acc.value, elem, i));\n      }\n  }\n}, options), map$2(option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        throw new Error(\"BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/io/issues\");\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n})))));\n\n/* @internal */\nconst parallelFinalizers = self => contextWithEffect(context => match(getOption(context, scopeTag), {\n  onNone: () => self,\n  onSome: scope => {\n    switch (scope.strategy._tag) {\n      case \"Parallel\":\n        return self;\n      case \"Sequential\":\n      case \"ParallelN\":\n        return flatMap$1(scopeFork(scope, parallel), inner => scopeExtend(self, inner));\n    }\n  }\n}));\n\n/* @internal */\nconst parallelNFinalizers = parallelism => self => contextWithEffect(context => match(getOption(context, scopeTag), {\n  onNone: () => self,\n  onSome: scope => {\n    if (scope.strategy._tag === \"ParallelN\" && scope.strategy.parallelism === parallelism) {\n      return self;\n    }\n    return flatMap$1(scopeFork(scope, parallelN(parallelism)), inner => scopeExtend(self, inner));\n  }\n}));\n\n/* @internal */\nconst finalizersMask = strategy => self => contextWithEffect(context => match(getOption(context, scopeTag), {\n  onNone: () => self(identity),\n  onSome: scope => {\n    const patch = strategy._tag === \"Parallel\" ? parallelFinalizers : strategy._tag === \"Sequential\" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);\n    switch (scope.strategy._tag) {\n      case \"Parallel\":\n        return patch(self(parallelFinalizers));\n      case \"Sequential\":\n        return patch(self(sequentialFinalizers));\n      case \"ParallelN\":\n        return patch(self(parallelNFinalizers(scope.strategy.parallelism)));\n    }\n  }\n}));\n\n/* @internal */\nconst scopeWith = f => flatMap$1(scopeTag, f);\n\n/* @internal */\nconst scopedEffect = effect => flatMap$1(scopeMake(), scope => scopeUse(scope)(effect));\n\n/* @internal */\nconst sequentialFinalizers = self => contextWithEffect(context => match(getOption(context, scopeTag), {\n  onNone: () => self,\n  onSome: scope => {\n    switch (scope.strategy._tag) {\n      case \"Sequential\":\n        return self;\n      case \"Parallel\":\n      case \"ParallelN\":\n        return flatMap$1(scopeFork(scope, sequential), inner => scopeExtend(self, inner));\n    }\n  }\n}));\n\n/* @internal */\nconst tagMetricsScoped = (key, value) => labelMetricsScoped([make$3(key, value)]);\n\n/* @internal */\nconst labelMetricsScoped = labels => labelMetricsScopedSet(fromIterable$2(labels));\n\n/* @internal */\nconst labelMetricsScopedSet = labels => fiberRefLocallyScopedWith(currentMetricLabels, set => pipe(set, union(labels)));\n\n/* @internal */\nconst using = /*#__PURE__*/dual(2, (self, use) => acquireUseRelease(scopeMake(), scope => flatMap$1(scopeExtend(self, scope), use), (scope, exit) => scopeClose(scope, exit)));\n\n/** @internal */\nconst validate = /*#__PURE__*/dual(args => isEffect(args[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));\n\n/** @internal */\nconst validateWith = /*#__PURE__*/dual(args => isEffect(args[1]), (self, that, f, options) => flatten(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {\n  onSuccess: f,\n  onFailure: (ca, cb) => options?.concurrent ? parallel$1(ca, cb) : sequential$1(ca, cb)\n}), options)));\n\n/* @internal */\nconst validateFirst = /*#__PURE__*/dual(args => isIterable(args[0]), (elements, f, options) => flip(forEachOptions(elements, (a, i) => flip(f(a, i)), options)));\n\n/* @internal */\nconst withClockScoped = value => fiberRefLocallyScopedWith(currentServices, add(clockTag, value));\n\n/* @internal */\nconst withConfigProviderScoped = value => fiberRefLocallyScopedWith(currentServices, add(configProviderTag, value));\n\n/* @internal */\nconst withEarlyRelease = self => scopeWith(parent => flatMap$1(scopeFork(parent, sequential$2), child => pipe(self, scopeExtend(child), map$2(value => [fiberIdWith(fiberId => scopeClose(child, exitInterrupt(fiberId))), value]))));\n\n/** @internal */\nconst zipOptions = /*#__PURE__*/dual(args => isEffect(args[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));\n\n/** @internal */\nconst zipLeftOptions = /*#__PURE__*/dual(args => isEffect(args[1]), (self, that, options) => zipWithOptions(self, that, (a, _) => a, options));\n\n/** @internal */\nconst zipRightOptions = /*#__PURE__*/dual(args => isEffect(args[1]), (self, that, options) => zipWithOptions(self, that, (_, b) => b, options));\n\n/** @internal */\nconst zipWithOptions = /*#__PURE__*/dual(args => isEffect(args[1]), (self, that, f, options) => map$2(all([self, that], {\n  concurrency: options?.concurrent ? 2 : 1,\n  batching: options?.batching\n}), ([a, a2]) => f(a, a2)));\n\n/* @internal */\nconst withRuntimeFlagsScoped = update => {\n  if (update === empty) {\n    return unit;\n  }\n  return pipe(runtimeFlags, flatMap$1(runtimeFlags => {\n    const updatedRuntimeFlags = patch(runtimeFlags, update);\n    const revertRuntimeFlags = diff(updatedRuntimeFlags, runtimeFlags);\n    return pipe(updateRuntimeFlags(update), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asUnit);\n  }), uninterruptible);\n};\n\n// circular with ReleaseMap\n\n/* @internal */\nconst releaseMapReleaseAll = (strategy, exit$1) => self => suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return unit;\n      }\n    case \"Running\":\n      {\n        const finalizersMap = self.state.finalizers;\n        const update = self.state.update;\n        const finalizers = Array.from(finalizersMap.keys()).sort((a, b) => b - a).map(key => finalizersMap.get(key));\n        self.state = {\n          _tag: \"Exited\",\n          nextKey: self.state.nextKey,\n          exit: exit$1,\n          update\n        };\n        return isSequential(strategy) ? pipe(finalizers, forEachSequential(fin => exit(update(fin)(exit$1))), flatMap$1(results => pipe(exitCollectAll(results), map(exitAsUnit), getOrElse(() => exitUnit)))) : isParallel(strategy) ? pipe(forEachParUnbounded(finalizers, fin => exit(update(fin)(exit$1)), false), flatMap$1(results => pipe(exitCollectAll(results, {\n          parallel: true\n        }), map(exitAsUnit), getOrElse(() => exitUnit)))) : pipe(forEachParN(finalizers, strategy.parallelism, fin => exit(update(fin)(exit$1)), false), flatMap$1(results => pipe(exitCollectAll(results, {\n          parallel: true\n        }), map(exitAsUnit), getOrElse(() => exitUnit))));\n      }\n  }\n});\n\n// circular with Scope\n\n/** @internal */\nconst scopeTag = /*#__PURE__*/Tag(ScopeTypeId);\n\n/* @internal */\nconst scope = scopeTag;\n\n/* @internal */\nconst scopeMake = (strategy = sequential$2) => map$2(releaseMapMake, rm => ({\n  [ScopeTypeId]: ScopeTypeId,\n  [CloseableScopeTypeId]: CloseableScopeTypeId,\n  strategy,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  fork: strategy => uninterruptible(pipe(scopeMake(strategy), flatMap$1(scope => pipe(releaseMapAdd(rm, exit => scopeClose(scope, exit)), tap(fin => scopeAddFinalizerExit(scope, fin)), as(scope))))),\n  close: exit => asUnit(releaseMapReleaseAll(strategy, exit)(rm)),\n  addFinalizer: fin => asUnit(releaseMapAdd(fin)(rm))\n}));\n\n/* @internal */\nconst scopeExtend = /*#__PURE__*/dual(2, (effect, scope) => mapInputContext(effect,\n// @ts-expect-error\nmerge(make$2(scopeTag, scope))));\n\n/* @internal */\nconst scopeUse = /*#__PURE__*/dual(2, (effect, scope) => pipe(effect, scopeExtend(scope), onExit(exit => scope.close(exit))));\n\n// circular with Supervisor\n\n/** @internal */\nconst fiberRefUnsafeMakeSupervisor = initial => fiberRefUnsafeMakePatch(initial, {\n  differ: differ,\n  fork: empty$1\n});\n\n// circular with FiberRef\n\n/* @internal */\nconst fiberRefLocallyScoped = /*#__PURE__*/dual(2, (self, value) => asUnit(acquireRelease(flatMap$1(fiberRefGet(self), oldValue => as(fiberRefSet(self, value), oldValue)), oldValue => fiberRefSet(self, oldValue))));\n\n/* @internal */\nconst fiberRefLocallyScopedWith = /*#__PURE__*/dual(2, (self, f) => fiberRefGetWith(self, a => fiberRefLocallyScoped(self, f(a))));\n\n/* @internal */\nconst fiberRefMake = (initial, options) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options));\n\n/* @internal */\nconst fiberRefMakeWith = ref => acquireRelease(tap(sync(ref), ref => fiberRefUpdate(ref, identity)), fiberRef => fiberRefDelete(fiberRef));\n\n/* @internal */\nconst fiberRefMakeContext = initial => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial));\n\n/* @internal */\nconst fiberRefMakeRuntimeFlags = initial => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial));\n\n/** @internal */\nconst currentRuntimeFlags = /*#__PURE__*/fiberRefUnsafeMakeRuntimeFlags(none$3);\n\n/** @internal */\nconst currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(none$1);\n\n// circular with Fiber\n\n/* @internal */\nconst fiberAwaitAll = fibers => asUnit(_await(fiberAll(fibers)));\n\n/** @internal */\nconst fiberAll = fibers => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => fromIterable(fibers).reduce((id, fiber) => combine(id, fiber.id()), none$2),\n  await: () => exit(forEachParUnbounded(fibers, fiber => flatten(fiber.await()), false)),\n  children: () => map$2(forEachParUnbounded(fibers, fiber => fiber.children(), false), flatten$1),\n  inheritAll: () => forEachSequentialDiscard(fibers, fiber => fiber.inheritAll()),\n  poll: () => map$2(forEachSequential(fibers, fiber => fiber.poll()), reduceRight(some(exitSucceed(new Array())), (optionB, optionA) => {\n    switch (optionA._tag) {\n      case \"None\":\n        {\n          return none();\n        }\n      case \"Some\":\n        {\n          switch (optionB._tag) {\n            case \"None\":\n              {\n                return none();\n              }\n            case \"Some\":\n              {\n                return some(exitZipWith(optionA.value, optionB.value, {\n                  onSuccess: (a, chunk) => [a, ...chunk],\n                  onFailure: parallel$1\n                }));\n              }\n          }\n        }\n    }\n  })),\n  interruptAsFork: fiberId => forEachSequentialDiscard(fibers, fiber => fiber.interruptAsFork(fiberId)),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n\n/* @internal */\nconst fiberInterruptFork = self => asUnit(forkDaemon(interruptFiber(self)));\n\n/* @internal */\nconst fiberJoinAll = fibers => asUnit(join(fiberAll(fibers)));\n\n/* @internal */\nconst fiberScoped = self => acquireRelease(succeed(self), interruptFiber);\n\n//\n// circular race\n//\n\n/** @internal */\nconst raceWith = /*#__PURE__*/dual(3, (self, other, options) => raceFibersWith(self, other, {\n  onSelfWin: (winner, loser) => flatMap$1(winner.await(), exit => {\n    switch (exit._tag) {\n      case OP_SUCCESS:\n        {\n          return flatMap$1(winner.inheritAll(), () => options.onSelfDone(exit, loser));\n        }\n      case OP_FAILURE:\n        {\n          return options.onSelfDone(exit, loser);\n        }\n    }\n  }),\n  onOtherWin: (winner, loser) => flatMap$1(winner.await(), exit => {\n    switch (exit._tag) {\n      case OP_SUCCESS:\n        {\n          return flatMap$1(winner.inheritAll(), () => options.onOtherDone(exit, loser));\n        }\n      case OP_FAILURE:\n        {\n          return options.onOtherDone(exit, loser);\n        }\n    }\n  })\n}));\n\n/** @internal */\nconst disconnect = self => uninterruptibleMask(restore => fiberIdWith(fiberId => flatMap$1(forkDaemon(restore(self)), fiber => pipe(restore(join(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId)))))));\n\n/** @internal */\nconst race = /*#__PURE__*/dual(2, (self, that) => fiberIdWith(parentFiberId => raceWith(self, that, {\n  onSelfDone: (exit, right) => exitMatchEffect(exit, {\n    onFailure: cause => pipe(join(right), mapErrorCause(cause2 => parallel$1(cause, cause2))),\n    onSuccess: value => pipe(right, interruptAsFiber(parentFiberId), as(value))\n  }),\n  onOtherDone: (exit, left) => exitMatchEffect(exit, {\n    onFailure: cause => pipe(join(left), mapErrorCause(cause2 => parallel$1(cause2, cause))),\n    onSuccess: value => pipe(left, interruptAsFiber(parentFiberId), as(value))\n  })\n})));\n\n/** @internal */\nconst raceFibersWith = /*#__PURE__*/dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {\n  const parentRuntimeFlags = parentStatus.runtimeFlags;\n  const raceIndicator = make$4(true);\n  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);\n  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);\n  return async(cb => {\n    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));\n    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));\n    leftFiber.startFork(self);\n    rightFiber.startFork(other);\n  }, combine(leftFiber.id(), rightFiber.id()));\n}));\nconst completeRace = (winner, loser, cont, ab, cb) => {\n  if (compareAndSet(true, false)(ab)) {\n    cb(cont(winner, loser));\n  }\n};\n\n/** @internal */\nconst ensuring = /*#__PURE__*/dual(2, (self, finalizer) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {\n  onFailure: cause1 => matchCauseEffect(finalizer, {\n    onFailure: cause2 => failCause(sequential$1(cause1, cause2)),\n    onSuccess: () => failCause(cause1)\n  }),\n  onSuccess: a => as(finalizer, a)\n})));\n\n/** @internal */\nconst invokeWithInterrupt = (dataSource, all) => fiberIdWith(id => flatMap$1(flatMap$1(forkDaemon(interruptible(dataSource)), processing => async(cb => {\n  const counts = all.map(_ => _.listeners.count);\n  const checkDone = () => {\n    if (counts.every(count => count === 0)) {\n      cleanup.forEach(f => f());\n      cb(interruptFiber(processing));\n    }\n  };\n  processing.addObserver(exit => {\n    cleanup.forEach(f => f());\n    cb(exit);\n  });\n  const cleanup = all.map((r, i) => {\n    const observer = count => {\n      counts[i] = count;\n      checkDone();\n    };\n    r.listeners.addObserver(observer);\n    return () => r.listeners.removeObserver(observer);\n  });\n  checkDone();\n  return sync(() => {\n    cleanup.forEach(f => f());\n  });\n})), () => suspend(() => {\n  const residual = all.flatMap(entry => {\n    if (!entry.state.completed) {\n      return [entry];\n    }\n    return [];\n  });\n  return forEachSequentialDiscard(residual, entry => complete(entry.request, exitInterrupt(id)));\n})));\n\n/** @internal */\nconst interruptWhenPossible = /*#__PURE__*/dual(2, (self, all) => fiberRefGetWith(currentRequestMap, map => suspend(() => {\n  const entries = fromIterable(all).flatMap(_ => map.has(_) ? [map.get(_)] : []);\n  return invokeWithInterrupt(self, entries);\n})));\n\n// circular Tracer\n\n/** @internal */\nconst makeSpanScoped = (name, options) => acquireRelease(makeSpan(name, options), (span, exit) => flatMap$1(currentTimeNanosTracing, endTime => sync(() => span.end(endTime, exit))));\n\n/* @internal */\nconst setSpan = (name, options) => tap(makeSpanScoped(name, options), span => setParentSpan(span));\n\n/* @internal */\nconst withTracerScoped = value => fiberRefLocallyScopedWith(currentServices, add(tracerTag, value));\n\n/* @internal */\nconst setParentSpan = span => fiberRefLocallyScopedWith(currentTracerSpan, prepend$1(span));\n\n/** @internal */\nconst withSpanScoped = /*#__PURE__*/dual(args => typeof args[0] !== \"string\", (self, name, options) => flatMap$1(makeSpanScoped(name, options), span => fiberRefLocallyWith(self, currentTracerSpan, prepend$1(span))));\n\nexport { FiberRuntime, acquireRelease, acquireReleaseInterruptible, addFinalizer, all, allSuccesses, allWith, currentLoggers, currentMinimumLogLevel, currentRuntimeFlags, currentSupervisor, daemonChildren, defaultLogger, disconnect, ensuring, exists, fiberActive, fiberAll, fiberAwaitAll, fiberFailures, fiberInterruptFork, fiberJoinAll, fiberLifetimes, fiberRefLocallyScoped, fiberRefLocallyScopedWith, fiberRefMake, fiberRefMakeContext, fiberRefMakeRuntimeFlags, fiberRefMakeWith, fiberRefUnsafeMakeSupervisor, fiberScoped, fiberStarted, fiberSuccesses, filter, finalizersMask, forEachOptions, forEachParN, forEachParNDiscard, forEachParUnbounded, forEachParUnboundedDiscard, fork, forkDaemon, forkWithErrorHandler, getConsole, interruptWhenPossible, invokeWithInterrupt, labelMetricsScoped, labelMetricsScopedSet, logFmtLogger, makeSpanScoped, mergeAll, parallelFinalizers, parallelNFinalizers, partition, race, raceAll, raceFibersWith, raceWith, reduceEffect, releaseMapReleaseAll, replicate, replicateEffect, runtimeFiberVariance, scope, scopeExtend, scopeMake, scopeTag, scopeUse, scopeWith, scopedEffect, sequentialFinalizers, setParentSpan, setSpan, tagMetricsScoped, tracerLogger, unsafeFork, unsafeMakeChildFiber, using, validate, validateAll, validateFirst, validateWith, withClockScoped, withConfigProviderScoped, withEarlyRelease, withRuntimeFlagsScoped, withSpanScoped, withTracerScoped, zipLeftOptions, zipOptions, zipRightOptions, zipWithOptions };\n","import { millis } from '../../Duration/dist/effect-Duration.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { none, some } from '../../Option/dist/effect-Option.esm.js';\n\n/** @internal */\nconst IntervalSymbolKey = \"effect/ScheduleInterval\";\n\n/** @internal */\nconst IntervalTypeId = /*#__PURE__*/Symbol.for(IntervalSymbolKey);\n\n/** @internal */\nconst empty = {\n  [IntervalTypeId]: IntervalTypeId,\n  startMillis: 0,\n  endMillis: 0\n};\n\n/** @internal */\nconst make = (startMillis, endMillis) => {\n  if (startMillis > endMillis) {\n    return empty;\n  }\n  return {\n    [IntervalTypeId]: IntervalTypeId,\n    startMillis,\n    endMillis\n  };\n};\n\n/** @internal */\nconst lessThan = /*#__PURE__*/dual(2, (self, that) => min(self, that) === self);\n\n/** @internal */\nconst min = /*#__PURE__*/dual(2, (self, that) => {\n  if (self.endMillis <= that.startMillis) return self;\n  if (that.endMillis <= self.startMillis) return that;\n  if (self.startMillis < that.startMillis) return self;\n  if (that.startMillis < self.startMillis) return that;\n  if (self.endMillis <= that.endMillis) return self;\n  return that;\n});\n\n/** @internal */\nconst max = /*#__PURE__*/dual(2, (self, that) => min(self, that) === self ? that : self);\n\n/** @internal */\nconst isEmpty = self => {\n  return self.startMillis >= self.endMillis;\n};\n\n/** @internal */\nconst isNonEmpty = self => {\n  return !isEmpty(self);\n};\n\n/** @internal */\nconst intersect = /*#__PURE__*/dual(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis);\n  const end = Math.min(self.endMillis, that.endMillis);\n  return make(start, end);\n});\n\n/** @internal */\nconst size = self => {\n  return millis(self.endMillis - self.startMillis);\n};\n\n/** @internal */\nconst union = /*#__PURE__*/dual(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis);\n  const end = Math.min(self.endMillis, that.endMillis);\n  return start < end ? none() : some(make(start, end));\n});\n\n/** @internal */\nconst after = startMilliseconds => {\n  return make(startMilliseconds, Number.POSITIVE_INFINITY);\n};\n\n/** @internal */\nconst before = endMilliseconds => {\n  return make(Number.NEGATIVE_INFINITY, endMilliseconds);\n};\n\nexport { IntervalTypeId, after, before, empty, intersect, isEmpty, isNonEmpty, lessThan, make, max, min, size, union };\n","import { IntervalTypeId as IntervalTypeId$1, make as make$1, empty as empty$1, lessThan as lessThan$1, min as min$1, max as max$1, isEmpty as isEmpty$1, isNonEmpty as isNonEmpty$1, intersect as intersect$1, size as size$1, union as union$1, after as after$1, before as before$1 } from '../../internal/schedule/interval.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst IntervalTypeId = IntervalTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * An `Interval` represents an interval of time. Intervals can encompass all\n * time, or no time at all.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Constructs a new interval from the two specified endpoints. If the start\n * endpoint greater than the end endpoint, then a zero size interval will be\n * returned.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * An `Interval` of zero-width.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Returns `true` if this `Interval` is less than `that` interval, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst lessThan = lessThan$1;\n\n/**\n * Returns the minimum of two `Interval`s.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst min = min$1;\n\n/**\n * Returns the maximum of two `Interval`s.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst max = max$1;\n\n/**\n * Returns `true` if the specified `Interval` is empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst isEmpty = isEmpty$1;\n\n/**\n * Returns `true` if the specified `Interval` is non-empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst isNonEmpty = isNonEmpty$1;\n\n/**\n * Computes a new `Interval` which is the intersection of this `Interval` and\n * that `Interval`.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst intersect = intersect$1;\n\n/**\n * Calculates the size of the `Interval` as the `Duration` from the start of the\n * interval to the end of the interval.\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = size$1;\n\n/**\n * Computes a new `Interval` which is the union of this `Interval` and that\n * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\n * form a union.\n *\n * @since 2.0.0\n * @category utils\n */\nconst union = union$1;\n\n/**\n * Construct an `Interval` that includes all time equal to and after the\n * specified start time.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst after = after$1;\n\n/**\n * Construct an `Interval` that includes all time equal to and before the\n * specified end time.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst before = before$1;\n\nexport { IntervalTypeId, after, before, empty, intersect, isEmpty, isNonEmpty, lessThan, make, max, min, size, union };\n","import { empty as empty$1, of, isNonEmpty as isNonEmpty$1, headNonEmpty, tailNonEmpty, prepend, isEmpty, reverse, head } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { pipe, dual } from '../../Function/dist/effect-Function.esm.js';\nimport { getOrElse } from '../../Option/dist/effect-Option.esm.js';\nimport { make as make$1, intersect as intersect$1, isEmpty as isEmpty$1, lessThan as lessThan$1, empty as empty$2 } from '../../ScheduleInterval/dist/effect-ScheduleInterval.esm.js';\n\n/** @internal */\nconst IntervalsSymbolKey = \"effect/ScheduleIntervals\";\n\n/** @internal */\nconst IntervalsTypeId = /*#__PURE__*/Symbol.for(IntervalsSymbolKey);\n\n/** @internal */\nconst make = intervals => {\n  return {\n    [IntervalsTypeId]: IntervalsTypeId,\n    intervals\n  };\n};\n/** @internal */\nconst empty = /*#__PURE__*/make( /*#__PURE__*/empty$1());\n\n/** @internal */\nconst fromIterable = intervals => Array.from(intervals).reduce((intervals, interval) => pipe(intervals, union(make(of(interval)))), empty);\n\n/** @internal */\nconst union = /*#__PURE__*/dual(2, (self, that) => {\n  if (!isNonEmpty$1(that.intervals)) {\n    return self;\n  }\n  if (!isNonEmpty$1(self.intervals)) {\n    return that;\n  }\n  if (headNonEmpty(self.intervals).startMillis < headNonEmpty(that.intervals).startMillis) {\n    return unionLoop(tailNonEmpty(self.intervals), that.intervals, headNonEmpty(self.intervals), empty$1());\n  }\n  return unionLoop(self.intervals, tailNonEmpty(that.intervals), headNonEmpty(that.intervals), empty$1());\n});\n\n/** @internal */\nconst unionLoop = (_self, _that, _interval, _acc) => {\n  let self = _self;\n  let that = _that;\n  let interval = _interval;\n  let acc = _acc;\n  while (isNonEmpty$1(self) || isNonEmpty$1(that)) {\n    if (!isNonEmpty$1(self) && isNonEmpty$1(that)) {\n      if (interval.endMillis < headNonEmpty(that).startMillis) {\n        acc = pipe(acc, prepend(interval));\n        interval = headNonEmpty(that);\n        that = tailNonEmpty(that);\n        self = empty$1();\n      } else {\n        interval = make$1(interval.startMillis, headNonEmpty(that).endMillis);\n        that = tailNonEmpty(that);\n        self = empty$1();\n      }\n    } else if (isNonEmpty$1(self) && isEmpty(that)) {\n      if (interval.endMillis < headNonEmpty(self).startMillis) {\n        acc = pipe(acc, prepend(interval));\n        interval = headNonEmpty(self);\n        that = empty$1();\n        self = tailNonEmpty(self);\n      } else {\n        interval = make$1(interval.startMillis, headNonEmpty(self).endMillis);\n        that = empty$1();\n        self = tailNonEmpty(self);\n      }\n    } else if (isNonEmpty$1(self) && isNonEmpty$1(that)) {\n      if (headNonEmpty(self).startMillis < headNonEmpty(that).startMillis) {\n        if (interval.endMillis < headNonEmpty(self).startMillis) {\n          acc = pipe(acc, prepend(interval));\n          interval = headNonEmpty(self);\n          self = tailNonEmpty(self);\n        } else {\n          interval = make$1(interval.startMillis, headNonEmpty(self).endMillis);\n          self = tailNonEmpty(self);\n        }\n      } else if (interval.endMillis < headNonEmpty(that).startMillis) {\n        acc = pipe(acc, prepend(interval));\n        interval = headNonEmpty(that);\n        that = tailNonEmpty(that);\n      } else {\n        interval = make$1(interval.startMillis, headNonEmpty(that).endMillis);\n        that = tailNonEmpty(that);\n      }\n    } else {\n      throw new Error(\"BUG: Intervals.unionLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n    }\n  }\n  return make(pipe(acc, prepend(interval), reverse));\n};\n\n/** @internal */\nconst intersect = /*#__PURE__*/dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty$1()));\n\n/** @internal */\nconst intersectLoop = (_left, _right, _acc) => {\n  let left = _left;\n  let right = _right;\n  let acc = _acc;\n  while (isNonEmpty$1(left) && isNonEmpty$1(right)) {\n    const interval = pipe(headNonEmpty(left), intersect$1(headNonEmpty(right)));\n    const intervals = isEmpty$1(interval) ? acc : pipe(acc, prepend(interval));\n    if (pipe(headNonEmpty(left), lessThan$1(headNonEmpty(right)))) {\n      left = tailNonEmpty(left);\n    } else {\n      right = tailNonEmpty(right);\n    }\n    acc = intervals;\n  }\n  return make(reverse(acc));\n};\n\n/** @internal */\nconst start = self => {\n  return pipe(self.intervals, head, getOrElse(() => empty$2)).startMillis;\n};\n\n/** @internal */\nconst end = self => {\n  return pipe(self.intervals, head, getOrElse(() => empty$2)).endMillis;\n};\n\n/** @internal */\nconst lessThan = /*#__PURE__*/dual(2, (self, that) => start(self) < start(that));\n\n/** @internal */\nconst isNonEmpty = self => {\n  return isNonEmpty$1(self.intervals);\n};\n\n/** @internal */\nconst max = /*#__PURE__*/dual(2, (self, that) => lessThan(self, that) ? that : self);\n\nexport { IntervalsTypeId, empty, end, fromIterable, intersect, isNonEmpty, lessThan, make, max, start, union };\n","import { IntervalsTypeId as IntervalsTypeId$1, make as make$1, empty as empty$1, fromIterable as fromIterable$1, union as union$1, intersect as intersect$1, start as start$1, end as end$1, lessThan as lessThan$1, isNonEmpty as isNonEmpty$1, max as max$1 } from '../../internal/schedule/intervals.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst IntervalsTypeId = IntervalsTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * An `Intervals` represents a list of several `Interval`s.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Creates a new `Intervals` from a `List` of `Interval`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Constructs an empty list of `Interval`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Constructs `Intervals` from the specified `Iterable<Interval>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = fromIterable$1;\n\n/**\n * Computes the union of this `Intervals` and  that `Intervals`\n *\n * @since 2.0.0\n * @category utils\n */\nconst union = union$1;\n\n/**\n * Produces the intersection of this `Intervals` and that `Intervals`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst intersect = intersect$1;\n\n/**\n * The start of the earliest interval in the specified `Intervals`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst start = start$1;\n\n/**\n * The end of the latest interval in the specified `Intervals`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst end = end$1;\n\n/**\n * Returns `true` if the start of this `Intervals` is before the start of that\n * `Intervals`, `false` otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nconst lessThan = lessThan$1;\n\n/**\n * Returns `true` if this `Intervals` is non-empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isNonEmpty = isNonEmpty$1;\n\n/**\n * Returns the maximum of the two `Intervals` (i.e. which has the latest start).\n *\n * @since 2.0.0\n * @category ordering\n */\nconst max = max$1;\n\nexport { IntervalsTypeId, empty, end, fromIterable, intersect, isNonEmpty, lessThan, make, max, start, union };\n","import { of } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { make } from '../../ScheduleIntervals/dist/effect-ScheduleIntervals.esm.js';\n\n/** @internal */\nconst OP_CONTINUE = \"Continue\";\n\n/** @internal */\n\n/** @internal */\nconst OP_DONE = \"Done\";\n\n/** @internal */\n\n/** @internal */\nconst _continue = intervals => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals\n  };\n};\n\n/** @internal */\nconst continueWith = interval => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals: make(of(interval))\n  };\n};\n\n/** @internal */\nconst done = {\n  _tag: OP_DONE\n};\n\n/** @internal */\nconst isContinue = self => {\n  return self._tag === OP_CONTINUE;\n};\n\n/** @internal */\nconst isDone = self => {\n  return self._tag === OP_DONE;\n};\n\nexport { OP_CONTINUE, OP_DONE, _continue, continueWith, done, isContinue, isDone };\n","import { _continue as _continue$1, continueWith as continueWith$1, done as done$1, isContinue as isContinue$1, isDone as isDone$1 } from '../../internal/schedule/decision.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\nconst _continue = _continue$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst continueWith = continueWith$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst done = done$1;\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isContinue = isContinue$1;\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nconst isDone = isDone$1;\n\nexport { _continue as continue, continueWith, done, isContinue, isDone };\n","import { empty, append, reverse, fromIterable, isNonEmpty as isNonEmpty$1, headNonEmpty, tailNonEmpty, prepend } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { currentTimeMillis } from '../Clock/dist/effect-Clock.esm.js';\nimport { add } from '../Context/dist/effect-Context.esm.js';\nimport { sum, decode, zero, millis, toMillis, times, lessThan as lessThan$1, greaterThanOrEqualTo } from '../Duration/dist/effect-Duration.esm.js';\nimport { merge, right, left } from '../Either/dist/effect-Either.esm.js';\nimport { equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { dual, constVoid, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { NoSuchElementException, IllegalArgumentException } from './cause.esm.js';\nimport { sync as sync$1, map as map$1, flatMap, succeed as succeed$1, zipWith as zipWith$1, mapInputContext as mapInputContext$1, dieSync, as as as$1, provideContext as provideContext$1, contextWithEffect, zipRight as zipRight$1, tap, fail, matchEffect, orDie, yieldNow, catchAll, failSync, suspend } from './core.esm.js';\nimport { make as make$1, get, set } from './ref.esm.js';\nimport { none, some, isSome } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { next } from '../Random/dist/effect-Random.esm.js';\nimport { isDone, isContinue, continue as _continue, done, continueWith } from '../ScheduleDecision/dist/effect-ScheduleDecision.esm.js';\nimport { make, after, size } from '../ScheduleInterval/dist/effect-ScheduleInterval.esm.js';\nimport { union as union$1, max, start, intersect as intersect$1, isNonEmpty, lessThan, end } from '../ScheduleIntervals/dist/effect-ScheduleIntervals.esm.js';\nimport { negate, sleep } from './core-effect.esm.js';\n\n/** @internal */\nconst ScheduleSymbolKey = \"effect/Schedule\";\n\n/** @internal */\nconst ScheduleTypeId = /*#__PURE__*/Symbol.for(ScheduleSymbolKey);\n\n/** @internal */\nconst ScheduleDriverSymbolKey = \"effect/ScheduleDriver\";\n\n/** @internal */\nconst ScheduleDriverTypeId = /*#__PURE__*/Symbol.for(ScheduleDriverSymbolKey);\n\n/** @internal */\nconst scheduleVariance = {\n  _Env: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\nconst scheduleDriverVariance = {\n  _Env: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\n\n/** @internal */\nclass ScheduleImpl {\n  [ScheduleTypeId] = scheduleVariance;\n  constructor(initial, step) {\n    this.initial = initial;\n    this.step = step;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nclass ScheduleDriverImpl {\n  [ScheduleDriverTypeId] = scheduleDriverVariance;\n  constructor(schedule, ref) {\n    this.schedule = schedule;\n    this.ref = ref;\n  }\n  state() {\n    return map$1(get(this.ref), tuple => tuple[1]);\n  }\n  last() {\n    return flatMap(get(this.ref), ([element, _]) => {\n      switch (element._tag) {\n        case \"None\":\n          {\n            return failSync(() => NoSuchElementException());\n          }\n        case \"Some\":\n          {\n            return succeed$1(element.value);\n          }\n      }\n    });\n  }\n  reset() {\n    return set(this.ref, [none(), this.schedule.initial]);\n  }\n  next(input) {\n    return pipe(map$1(get(this.ref), tuple => tuple[1]), flatMap(state => pipe(currentTimeMillis, flatMap(now => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap(([state, out, decision]) => isDone(decision) ? pipe(set(this.ref, [some(out), state]), zipRight$1(fail(none()))) : pipe(set(this.ref, [some(out), state]), zipRight$1(sleep(millis(start(decision.intervals) - now))), as$1(out))))))));\n  }\n}\n\n/** @internal */\nconst makeWithState = (initial, step) => new ScheduleImpl(initial, step);\n\n/** @internal */\nconst addDelay = /*#__PURE__*/dual(2, (self, f) => addDelayEffect(self, out => sync$1(() => f(out))));\n\n/** @internal */\nconst addDelayEffect = /*#__PURE__*/dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => map$1(f(out), delay => sum(duration, decode(delay)))));\n\n/** @internal */\nconst andThen = /*#__PURE__*/dual(2, (self, that) => map(andThenEither(self, that), merge));\n\n/** @internal */\nconst andThenEither = /*#__PURE__*/dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? flatMap(self.step(now, input, state[0]), ([lState, out, decision]) => {\n  if (isDone(decision)) {\n    return map$1(that.step(now, input, state[1]), ([rState, out, decision]) => [[lState, rState, false], right(out), decision]);\n  }\n  return succeed$1([[lState, state[1], true], left(out), decision]);\n}) : map$1(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right(out), decision])));\n\n/** @internal */\nconst as = /*#__PURE__*/dual(2, (self, out) => map(self, () => out));\n\n/** @internal */\nconst asUnit = self => map(self, constVoid);\n\n/** @internal */\nconst bothInOut = /*#__PURE__*/dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => zipWith$1(self.step(now, in1, state[0]), that.step(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {\n  if (isContinue(lDecision) && isContinue(rDecision)) {\n    const interval = pipe(lDecision.intervals, union$1(rDecision.intervals));\n    return [[lState, rState], [out, out2], _continue(interval)];\n  }\n  return [[lState, rState], [out, out2], done];\n})));\n\n/** @internal */\nconst check = /*#__PURE__*/dual(2, (self, test) => checkEffect(self, (input, out) => sync$1(() => test(input, out))));\n\n/** @internal */\nconst checkEffect = /*#__PURE__*/dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap(self.step(now, input, state), ([state, out, decision]) => {\n  if (isDone(decision)) {\n    return succeed$1([state, out, done]);\n  }\n  return map$1(test(input, out), cont => cont ? [state, out, decision] : [state, out, done]);\n})));\n/** @internal */\nconst collectAllInputs = () => collectAllOutputs(identity());\n\n/** @internal */\nconst collectAllOutputs = self => reduce(self, empty(), (outs, out) => pipe(outs, append(out)));\n\n/** @internal */\nconst collectUntil = f => collectAllOutputs(recurUntil(f));\n\n/** @internal */\nconst collectUntilEffect = f => collectAllOutputs(recurUntilEffect(f));\n\n/** @internal */\nconst collectWhile = f => collectAllOutputs(recurWhile(f));\n\n/** @internal */\nconst collectWhileEffect = f => collectAllOutputs(recurWhileEffect(f));\n\n/** @internal */\nconst compose = /*#__PURE__*/dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => flatMap(self.step(now, input, state[0]), ([lState, out, lDecision]) => map$1(that.step(now, out, state[1]), ([rState, out2, rDecision]) => isDone(lDecision) ? [[lState, rState], out2, done] : isDone(rDecision) ? [[lState, rState], out2, done] : [[lState, rState], out2, _continue(pipe(lDecision.intervals, max(rDecision.intervals)))]))));\n\n/** @internal */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => mapInputEffect(self, input2 => sync$1(() => f(input2))));\n\n/** @internal */\nconst mapInputContext = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => mapInputContext$1(self.step(now, input, state), f)));\n\n/** @internal */\nconst mapInputEffect = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input2, state) => flatMap(f(input2), input => self.step(now, input, state))));\n\n/** @internal */\nconst dayOfMonth = day => {\n  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 31 < day) {\n      return dieSync(() => IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDayOfMonth(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = make(start, end);\n    return succeed$1([[end, n + 1], n, continueWith(interval)]);\n  });\n};\n\n/** @internal */\nconst dayOfWeek = day => {\n  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 7 < day) {\n      return dieSync(() => IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDay(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = make(start, end);\n    return succeed$1([[end, n + 1], n, continueWith(interval)]);\n  });\n};\n\n/** @internal */\nconst delayed = /*#__PURE__*/dual(2, (self, f) => delayedEffect(self, duration => sync$1(() => f(duration))));\n\n/** @internal */\nconst delayedEffect = /*#__PURE__*/dual(2, (self, f) => modifyDelayEffect(self, (_, delay) => f(delay)));\n\n/** @internal */\nconst delayedSchedule = schedule => addDelay(schedule, x => x);\n\n/** @internal */\nconst delays = self => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), flatMap(([state, _, decision]) => {\n  if (isDone(decision)) {\n    return succeed$1([state, zero, decision]);\n  }\n  return succeed$1([state, millis(start(decision.intervals) - now), decision]);\n})));\n\n/** @internal */\nconst mapBoth = /*#__PURE__*/dual(2, (self, {\n  onInput,\n  onOutput\n}) => map(mapInput(self, onInput), onOutput));\n\n/** @internal */\nconst mapBothEffect = /*#__PURE__*/dual(2, (self, {\n  onInput,\n  onOutput\n}) => mapEffect(mapInputEffect(self, onInput), onOutput));\n\n/** @internal */\nconst driver = self => pipe(make$1([none(), self.initial]), map$1(ref => new ScheduleDriverImpl(self, ref)));\n\n/** @internal */\nconst duration = durationInput => {\n  const duration = decode(durationInput);\n  const durationMillis = toMillis(duration);\n  return makeWithState(true, (now, _, state) => succeed$1(state ? [false, duration, continueWith(after(now + durationMillis))] : [false, zero, done]));\n};\n\n/** @internal */\nconst either = /*#__PURE__*/dual(2, (self, that) => union(self, that));\n\n/** @internal */\nconst eitherWith = /*#__PURE__*/dual(3, (self, that, f) => unionWith(self, that, f));\n\n/** @internal */\nconst ensuring = /*#__PURE__*/dual(2, (self, finalizer) => makeWithState(self.initial, (now, input, state) => flatMap(self.step(now, input, state), ([state, out, decision]) => isDone(decision) ? as$1(finalizer, [state, out, decision]) : succeed$1([state, out, decision]))));\n\n/** @internal */\nconst exponential = (baseInput, factor = 2.0) => {\n  const base = decode(baseInput);\n  return delayedSchedule(map(forever, i => times(base, Math.pow(factor, i))));\n};\n\n/** @internal */\nconst fibonacci = oneInput => {\n  const one = decode(oneInput);\n  return delayedSchedule(pipe(unfold([one, one], ([a, b]) => [b, sum(a, b)]), map(out => out[0])));\n};\n\n/** @internal */\nconst fixed = intervalInput => {\n  const interval = decode(intervalInput);\n  const intervalMillis = toMillis(interval);\n  return makeWithState([none(), 0], (now, _, [option, n]) => sync$1(() => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return [[some([now, now + intervalMillis]), n + 1], n, continueWith(after(now + intervalMillis))];\n        }\n      case \"Some\":\n        {\n          const [startMillis, lastRun] = option.value;\n          const runningBehind = now > lastRun + intervalMillis;\n          const boundary = equals(interval, zero) ? interval : millis(intervalMillis - (now - startMillis) % intervalMillis);\n          const sleepTime = equals(boundary, zero) ? interval : boundary;\n          const nextRun = runningBehind ? now : now + toMillis(sleepTime);\n          return [[some([startMillis, nextRun]), n + 1], n, continueWith(after(nextRun))];\n        }\n    }\n  }));\n};\n\n/** @internal */\nconst fromDelay = delay => duration(delay);\n\n/** @internal */\nconst fromDelays = (delay, ...delays) => makeWithState([[delay, ...delays].map(_ => decode(_)), true], (now, _, [durations, cont]) => sync$1(() => {\n  if (cont) {\n    const x = durations[0];\n    const interval = after(now + toMillis(x));\n    if (durations.length >= 2) {\n      return [[durations.slice(1), true], x, continueWith(interval)];\n    }\n    const y = durations.slice(1);\n    return [[[x, ...y], false], x, continueWith(interval)];\n  }\n  return [[durations, false], zero, done];\n}));\n\n/** @internal */\nconst fromFunction = f => map(identity(), f);\n\n/** @internal */\nconst hourOfDay = hour => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {\n    return dieSync(() => IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const hour0 = nextHour(now, hour, initial);\n  const start = beginningOfHour(hour0);\n  const end = endOfHour(hour0);\n  const interval = make(start, end);\n  return succeed$1([[end, n + 1], n, continueWith(interval)]);\n});\n\n/** @internal */\nconst identity = () => makeWithState(void 0, (now, input, state) => succeed$1([state, input, continueWith(after(now))]));\n\n/** @internal */\nconst intersect = /*#__PURE__*/dual(2, (self, that) => intersectWith(self, that, intersect$1));\n\n/** @internal */\nconst intersectWith = /*#__PURE__*/dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith$1(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap(([[lState, out, lDecision], [rState, out2, rDecision]]) => {\n  if (isContinue(lDecision) && isContinue(rDecision)) {\n    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);\n  }\n  return succeed$1([[lState, rState], [out, out2], done]);\n}))));\n\n/** @internal */\nconst intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {\n  const combined = f(lInterval, rInterval);\n  if (isNonEmpty(combined)) {\n    return succeed$1([[lState, rState], [out, out2], _continue(combined)]);\n  }\n  if (pipe(lInterval, lessThan(rInterval))) {\n    return flatMap(self.step(end(lInterval), input, lState), ([lState, out, decision]) => {\n      if (isDone(decision)) {\n        return succeed$1([[lState, rState], [out, out2], done]);\n      }\n      return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);\n    });\n  }\n  return flatMap(that.step(end(rInterval), input, rState), ([rState, out2, decision]) => {\n    if (isDone(decision)) {\n      return succeed$1([[lState, rState], [out, out2], done]);\n    }\n    return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);\n  });\n};\n\n/** @internal */\nconst jittered = self => jitteredWith(self, {\n  min: 0.8,\n  max: 1.2\n});\n\n/** @internal */\nconst jitteredWith = /*#__PURE__*/dual(2, (self, options) => {\n  const {\n    max,\n    min\n  } = Object.assign({\n    min: 0.8,\n    max: 1.2\n  }, options);\n  return delayedEffect(self, duration => map$1(next, random => {\n    const d = toMillis(duration);\n    const jittered = d * min * (1 - random) + d * max * random;\n    return millis(jittered);\n  }));\n});\n\n/** @internal */\nconst linear = baseInput => {\n  const base = decode(baseInput);\n  return delayedSchedule(map(forever, i => times(base, i + 1)));\n};\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => mapEffect(self, out => sync$1(() => f(out))));\n\n/** @internal */\nconst mapEffect = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap(self.step(now, input, state), ([state, out, decision]) => map$1(f(out), out2 => [state, out2, decision]))));\n\n/** @internal */\nconst minuteOfHour = minute => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {\n    return dieSync(() => IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const minute0 = nextMinute(now, minute, initial);\n  const start = beginningOfMinute(minute0);\n  const end = endOfMinute(minute0);\n  const interval = make(start, end);\n  return succeed$1([[end, n + 1], n, continueWith(interval)]);\n});\n\n/** @internal */\nconst modifyDelay = /*#__PURE__*/dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => sync$1(() => f(out, duration))));\n\n/** @internal */\nconst modifyDelayEffect = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap(self.step(now, input, state), ([state, out, decision]) => {\n  if (isDone(decision)) {\n    return succeed$1([state, out, decision]);\n  }\n  const intervals = decision.intervals;\n  const delay = size(make(now, start(intervals)));\n  return map$1(f(out, delay), durationInput => {\n    const duration = decode(durationInput);\n    const oldStart = start(intervals);\n    const newStart = now + toMillis(duration);\n    const delta = newStart - oldStart;\n    const newEnd = Math.min(Math.max(0, end(intervals) + delta), Number.MAX_SAFE_INTEGER);\n    const newInterval = make(newStart, newEnd);\n    return [state, out, continueWith(newInterval)];\n  });\n})));\n\n/** @internal */\nconst onDecision = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap(self.step(now, input, state), ([state, out, decision]) => as$1(f(out, decision), [state, out, decision]))));\n\n/** @internal */\nconst passthrough = self => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map$1(([state, _, decision]) => [state, input, decision])));\n\n/** @internal */\nconst provideContext = /*#__PURE__*/dual(2, (self, context) => makeWithState(self.initial, (now, input, state) => provideContext$1(self.step(now, input, state), context)));\n\n/** @internal */\nconst provideService = /*#__PURE__*/dual(3, (self, tag, service) => makeWithState(self.initial, (now, input, state) => contextWithEffect(env => provideContext$1(\n// @ts-expect-error\nself.step(now, input, state), add(env, tag, service)))));\n\n/** @internal */\nconst recurUntil = f => untilInput(identity(), f);\n\n/** @internal */\nconst recurUntilEffect = f => untilInputEffect(identity(), f);\n\n/** @internal */\nconst recurUntilOption = pf => untilOutput(map(identity(), pf), isSome);\n\n/** @internal */\nconst recurUpTo = durationInput => {\n  const duration = decode(durationInput);\n  return whileOutput(elapsed, elapsed => lessThan$1(elapsed, duration));\n};\n\n/** @internal */\nconst recurWhile = f => whileInput(identity(), f);\n\n/** @internal */\nconst recurWhileEffect = f => whileInputEffect(identity(), f);\n\n/** @internal */\nconst recurs = n => whileOutput(forever, out => out < n);\n\n/** @internal */\nconst reduce = /*#__PURE__*/dual(3, (self, zero, f) => reduceEffect(self, zero, (z, out) => sync$1(() => f(z, out))));\n\n/** @internal */\nconst reduceEffect = /*#__PURE__*/dual(3, (self, zero, f) => makeWithState([self.initial, zero], (now, input, [s, z]) => flatMap(self.step(now, input, s), ([s, out, decision]) => isDone(decision) ? succeed$1([[s, z], z, decision]) : map$1(f(z, out), z2 => [[s, z2], z, decision]))));\n\n/** @internal */\nconst repetitions = self => reduce(self, 0, (n, _) => n + 1);\n\n/** @internal */\nconst resetAfter = /*#__PURE__*/dual(2, (self, durationInput) => {\n  const duration = decode(durationInput);\n  return pipe(self, intersect(elapsed), resetWhen(([, time]) => greaterThanOrEqualTo(time, duration)), map(out => out[0]));\n});\n\n/** @internal */\nconst resetWhen = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap(self.step(now, input, state), ([state, out, decision]) => f(out) ? self.step(now, input, self.initial) : succeed$1([state, out, decision]))));\n\n/** @internal */\nconst run = /*#__PURE__*/dual(3, (self, now, input) => pipe(runLoop(self, now, fromIterable(input), self.initial, empty()), map$1(list => reverse(list))));\n\n/** @internal */\nconst runLoop = (self, now, inputs, state, acc) => {\n  if (!isNonEmpty$1(inputs)) {\n    return succeed$1(acc);\n  }\n  const input = headNonEmpty(inputs);\n  const nextInputs = tailNonEmpty(inputs);\n  return flatMap(self.step(now, input, state), ([state, out, decision]) => {\n    if (isDone(decision)) {\n      return sync$1(() => pipe(acc, prepend(out)));\n    }\n    return runLoop(self, start(decision.intervals), nextInputs, state, prepend(acc, out));\n  });\n};\n\n/** @internal */\nconst secondOfMinute = second => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(second) || second < 0 || 59 < second) {\n    return dieSync(() => IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const second0 = nextSecond(now, second, initial);\n  const start = beginningOfSecond(second0);\n  const end = endOfSecond(second0);\n  const interval = make(start, end);\n  return succeed$1([[end, n + 1], n, continueWith(interval)]);\n});\n\n/** @internal */\nconst spaced = duration => addDelay(forever, () => duration);\n\n/** @internal */\nconst succeed = value => map(forever, () => value);\n\n/** @internal */\nconst sync = evaluate => map(forever, evaluate);\n\n/** @internal */\nconst tapInput = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => zipRight$1(f(input), self.step(now, input, state))));\n\n/** @internal */\nconst tapOutput = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => tap(self.step(now, input, state), ([, out]) => f(out))));\n\n/** @internal */\nconst unfold = (initial, f) => makeWithState(initial, (now, _, state) => sync$1(() => [f(state), state, continueWith(after(now))]));\n\n/** @internal */\nconst union = /*#__PURE__*/dual(2, (self, that) => unionWith(self, that, union$1));\n\n/** @internal */\nconst unionWith = /*#__PURE__*/dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => zipWith$1(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {\n  if (isDone(lDecision) && isDone(rDecision)) {\n    return [[lState, rState], [l, r], done];\n  }\n  if (isDone(lDecision) && isContinue(rDecision)) {\n    return [[lState, rState], [l, r], _continue(rDecision.intervals)];\n  }\n  if (isContinue(lDecision) && isDone(rDecision)) {\n    return [[lState, rState], [l, r], _continue(lDecision.intervals)];\n  }\n  if (isContinue(lDecision) && isContinue(rDecision)) {\n    const combined = f(lDecision.intervals, rDecision.intervals);\n    return [[lState, rState], [l, r], _continue(combined)];\n  }\n  throw new Error(\"BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/io/issues\");\n})));\n\n/** @internal */\nconst untilInput = /*#__PURE__*/dual(2, (self, f) => check(self, (input, _) => !f(input)));\n\n/** @internal */\nconst untilInputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));\n\n/** @internal */\nconst untilOutput = /*#__PURE__*/dual(2, (self, f) => check(self, (_, out) => !f(out)));\n\n/** @internal */\nconst untilOutputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (_, out) => negate(f(out))));\n\n/** @internal */\nconst upTo = /*#__PURE__*/dual(2, (self, duration) => zipLeft(self, recurUpTo(duration)));\n\n/** @internal */\nconst whileInput = /*#__PURE__*/dual(2, (self, f) => check(self, (input, _) => f(input)));\n\n/** @internal */\nconst whileInputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));\n\n/** @internal */\nconst whileOutput = /*#__PURE__*/dual(2, (self, f) => check(self, (_, out) => f(out)));\n\n/** @internal */\nconst whileOutputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (_, out) => f(out)));\n\n/** @internal */\nconst windowed = intervalInput => {\n  const interval = decode(intervalInput);\n  const millis = toMillis(interval);\n  return makeWithState([none(), 0], (now, _, [option, n]) => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return succeed$1([[some(now), n + 1], n, continueWith(after(now + millis))]);\n        }\n      case \"Some\":\n        {\n          return succeed$1([[some(option.value), n + 1], n, continueWith(after(now + (millis - (now - option.value) % millis)))]);\n        }\n    }\n  });\n};\n\n/** @internal */\nconst zipLeft = /*#__PURE__*/dual(2, (self, that) => map(intersect(self, that), out => out[0]));\n\n/** @internal */\nconst zipRight = /*#__PURE__*/dual(2, (self, that) => map(intersect(self, that), out => out[1]));\n\n/** @internal */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => map(intersect(self, that), ([out, out2]) => f(out, out2)));\n\n// -----------------------------------------------------------------------------\n// Seconds\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst beginningOfSecond = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();\n};\n\n/** @internal */\nconst endOfSecond = now => {\n  const date = new Date(beginningOfSecond(now));\n  return date.setSeconds(date.getSeconds() + 1);\n};\n\n/** @internal */\nconst nextSecond = (now, second, initial) => {\n  const date = new Date(now);\n  if (date.getSeconds() === second && initial) {\n    return now;\n  }\n  if (date.getSeconds() < second) {\n    return date.setSeconds(second);\n  }\n  // Set seconds to the provided value and add one minute\n  const newDate = new Date(date.setSeconds(second));\n  return newDate.setTime(newDate.getTime() + 1000 * 60);\n};\n\n// -----------------------------------------------------------------------------\n// Minutes\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst beginningOfMinute = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();\n};\n\n/** @internal */\nconst endOfMinute = now => {\n  const date = new Date(beginningOfMinute(now));\n  return date.setMinutes(date.getMinutes() + 1);\n};\n\n/** @internal */\nconst nextMinute = (now, minute, initial) => {\n  const date = new Date(now);\n  if (date.getMinutes() === minute && initial) {\n    return now;\n  }\n  if (date.getMinutes() < minute) {\n    return date.setMinutes(minute);\n  }\n  // Set minutes to the provided value and add one hour\n  const newDate = new Date(date.setMinutes(minute));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60);\n};\n\n// -----------------------------------------------------------------------------\n// Hours\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst beginningOfHour = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();\n};\n\n/** @internal */\nconst endOfHour = now => {\n  const date = new Date(beginningOfHour(now));\n  return date.setHours(date.getHours() + 1);\n};\n\n/** @internal */\nconst nextHour = (now, hour, initial) => {\n  const date = new Date(now);\n  if (date.getHours() === hour && initial) {\n    return now;\n  }\n  if (date.getHours() < hour) {\n    return date.setHours(hour);\n  }\n  // Set hours to the provided value and add one day\n  const newDate = new Date(date.setHours(hour));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24);\n};\n\n// -----------------------------------------------------------------------------\n// Days\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst beginningOfDay = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();\n};\n\n/** @internal */\nconst endOfDay = now => {\n  const date = new Date(beginningOfDay(now));\n  return date.setDate(date.getDate() + 1);\n};\n\n/** @internal */\nconst nextDay = (now, dayOfWeek, initial) => {\n  const date = new Date(now);\n  if (date.getDay() === dayOfWeek && initial) {\n    return now;\n  }\n  const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7;\n  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));\n};\n\n/** @internal */\nconst nextDayOfMonth = (now, day, initial) => {\n  const date = new Date(now);\n  if (date.getDate() === day && initial) {\n    return now;\n  }\n  if (date.getDate() < day) {\n    return date.setDate(day);\n  }\n  return findNextMonth(now, day, 1);\n};\n\n/** @internal */\nconst findNextMonth = (now, day, months) => {\n  const d = new Date(now);\n  const tmp1 = new Date(d.setDate(day));\n  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));\n  if (tmp2.getDate() === day) {\n    const d2 = new Date(now);\n    const tmp3 = new Date(d2.setDate(day));\n    return tmp3.setMonth(tmp3.getMonth() + months);\n  }\n  return findNextMonth(now, day, months + 1);\n};\n\n// circular with Effect\n\n/** @internal */\nconst repeat_Effect = /*#__PURE__*/dual(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => fail(e)));\n\n/** @internal */\nconst repeatOrElse_Effect = /*#__PURE__*/dual(3, (self, schedule, orElse) => flatMap(driver(schedule), driver => matchEffect(self, {\n  onFailure: error => orElse(error, none()),\n  onSuccess: value => repeatOrElseEffectLoop(self, driver, orElse, value)\n})));\n\n/** @internal */\nconst repeatOrElseEffectLoop = (self, driver, orElse, value) => {\n  return matchEffect(driver.next(value), {\n    onFailure: () => orDie(driver.last()),\n    onSuccess: b => matchEffect(self, {\n      onFailure: error => orElse(error, some(b)),\n      onSuccess: value => repeatOrElseEffectLoop(self, driver, orElse, value)\n    })\n  });\n};\n\n/** @internal */\nconst repeatUntil_Effect = /*#__PURE__*/dual(2, (self, f) => repeatUntilEffect_Effect(self, a => sync$1(() => f(a))));\n\n/** @internal */\nconst repeatUntilEffect_Effect = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => flatMap(f(a), result => result ? succeed$1(a) : flatMap(yieldNow(), () => repeatUntilEffect_Effect(self, f)))));\n\n/** @internal */\nconst repeatWhile_Effect = /*#__PURE__*/dual(2, (self, f) => repeatWhileEffect_Effect(self, a => sync$1(() => f(a))));\n\n/** @internal */\nconst repeatWhileEffect_Effect = /*#__PURE__*/dual(2, (self, f) => repeatUntilEffect_Effect(self, a => negate(f(a))));\n\n/** @internal */\nconst retry_Effect = /*#__PURE__*/dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail(e)));\n\n/** @internal */\nconst retryN_Effect = /*#__PURE__*/dual(2, (self, n) => retryN_EffectLoop(self, n));\n\n/** @internal */\nconst retryN_EffectLoop = (self, n) => {\n  return catchAll(self, e => n < 0 ? fail(e) : flatMap(yieldNow(), () => retryN_EffectLoop(self, n - 1)));\n};\n\n/** @internal */\nconst retryOrElse_Effect = /*#__PURE__*/dual(3, (self, policy, orElse) => flatMap(driver(policy), driver => retryOrElse_EffectLoop(self, driver, orElse)));\n\n/** @internal */\nconst retryOrElse_EffectLoop = (self, driver, orElse) => {\n  return catchAll(self, e => matchEffect(driver.next(e), {\n    onFailure: () => pipe(driver.last(), orDie, flatMap(out => orElse(e, out))),\n    onSuccess: () => retryOrElse_EffectLoop(self, driver, orElse)\n  }));\n};\n\n/** @internal */\nconst retryUntil_Effect = /*#__PURE__*/dual(2, (self, f) => retryUntilEffect_Effect(self, e => sync$1(() => f(e))));\n\n/** @internal */\nconst retryUntilEffect_Effect = /*#__PURE__*/dual(2, (self, f) => catchAll(self, e => flatMap(f(e), b => b ? fail(e) : flatMap(yieldNow(), () => retryUntilEffect_Effect(self, f)))));\n\n/** @internal */\nconst retryWhile_Effect = /*#__PURE__*/dual(2, (self, f) => retryWhileEffect_Effect(self, e => sync$1(() => f(e))));\n\n/** @internal */\nconst retryWhileEffect_Effect = /*#__PURE__*/dual(2, (self, f) => retryUntilEffect_Effect(self, e => negate(f(e))));\n\n/** @internal */\nconst schedule_Effect = /*#__PURE__*/dual(2, (self, schedule) => scheduleFrom_Effect(self, void 0, schedule));\n\n/** @internal */\nconst scheduleFrom_Effect = /*#__PURE__*/dual(3, (self, initial, schedule) => flatMap(driver(schedule), driver => scheduleFrom_EffectLoop(self, initial, driver)));\n\n/** @internal */\nconst scheduleFrom_EffectLoop = (self, initial, driver) => matchEffect(driver.next(initial), {\n  onFailure: () => orDie(driver.last()),\n  onSuccess: () => flatMap(self, a => scheduleFrom_EffectLoop(self, a, driver))\n});\n\n/** @internal */\nconst count = /*#__PURE__*/unfold(0, n => n + 1);\n\n/** @internal */\nconst elapsed = /*#__PURE__*/makeWithState( /*#__PURE__*/none(), (now, _, state) => {\n  switch (state._tag) {\n    case \"None\":\n      {\n        return succeed$1([some(now), zero, continueWith(after(now))]);\n      }\n    case \"Some\":\n      {\n        return succeed$1([some(state.value), millis(now - state.value), continueWith(after(now))]);\n      }\n  }\n});\n\n/** @internal */\nconst forever = /*#__PURE__*/unfold(0, n => n + 1);\n\n/** @internal */\nconst once = /*#__PURE__*/asUnit( /*#__PURE__*/recurs(1));\n\n/** @internal */\nconst stop = /*#__PURE__*/asUnit( /*#__PURE__*/recurs(0));\n\nexport { ScheduleDriverTypeId, ScheduleTypeId, addDelay, addDelayEffect, andThen, andThenEither, as, asUnit, beginningOfDay, beginningOfHour, beginningOfMinute, beginningOfSecond, bothInOut, check, checkEffect, collectAllInputs, collectAllOutputs, collectUntil, collectUntilEffect, collectWhile, collectWhileEffect, compose, count, dayOfMonth, dayOfWeek, delayed, delayedEffect, delayedSchedule, delays, driver, duration, either, eitherWith, elapsed, endOfDay, endOfHour, endOfMinute, endOfSecond, ensuring, exponential, fibonacci, findNextMonth, fixed, forever, fromDelay, fromDelays, fromFunction, hourOfDay, identity, intersect, intersectWith, jittered, jitteredWith, linear, makeWithState, map, mapBoth, mapBothEffect, mapEffect, mapInput, mapInputContext, mapInputEffect, minuteOfHour, modifyDelay, modifyDelayEffect, nextDay, nextDayOfMonth, nextHour, nextMinute, nextSecond, onDecision, once, passthrough, provideContext, provideService, recurUntil, recurUntilEffect, recurUntilOption, recurUpTo, recurWhile, recurWhileEffect, recurs, reduce, reduceEffect, repeatOrElse_Effect, repeatUntilEffect_Effect, repeatUntil_Effect, repeatWhileEffect_Effect, repeatWhile_Effect, repeat_Effect, repetitions, resetAfter, resetWhen, retryN_Effect, retryOrElse_Effect, retryUntilEffect_Effect, retryUntil_Effect, retryWhileEffect_Effect, retryWhile_Effect, retry_Effect, run, scheduleFrom_Effect, schedule_Effect, secondOfMinute, spaced, stop, succeed, sync, tapInput, tapOutput, unfold, union, unionWith, untilInput, untilInputEffect, untilOutput, untilOutputEffect, upTo, whileInput, whileInputEffect, whileOutput, whileOutputEffect, windowed, zipLeft, zipRight, zipWith };\n","import { decode, toMillis } from '../../Duration/dist/effect-Duration.esm.js';\nimport { left, right } from '../../Either/dist/effect-Either.esm.js';\nimport { equals, symbol } from '../../Equal/dist/effect-Equal.esm.js';\nimport { zipWith as zipWith$1 } from '../../Exit/dist/effect-Exit.esm.js';\nimport { getOrElse } from '../../FiberId/dist/effect-FiberId.esm.js';\nimport { dual, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { symbol as symbol$1, hash } from '../../Hash/dist/effect-Hash.esm.js';\nimport { parallel } from '../cause.esm.js';\nimport { sync, map, flatMap, context, provideContext, uninterruptibleMask, dieMessage, deferredAwait, forEachSequentialDiscard, forEachSequential, tap, fiberIdWith, onExit, suspend, deferredMake, intoDeferred, succeed, as, flatten, exit, fiberRefLocallyWith, failSync, failCauseSync, zipRight, zipWith, asyncEither, withFiberRuntime, currentSchedulingPriority, unit, asUnit, interruptFiber, interruptible, interruptAsFiber, exitFailCause } from '../core.esm.js';\nimport { clockWith, diffFiberRefs, patchFiberRefs, sleep } from '../core-effect.esm.js';\nimport { sequential } from '../executionStrategy.esm.js';\nimport { join, FiberTypeId, fiberVariance } from '../fiber.esm.js';\nimport { fiberAwaitAll, fiberAll, ensuring, fork, forkDaemon, scopeWith, race, currentSupervisor, zipWithOptions, raceFibersWith } from '../fiberRuntime.esm.js';\nimport { globalScope } from '../fiberScope.esm.js';\nimport { set, unsafeMake, RefTypeId, refVariance, get as get$1 } from '../ref.esm.js';\nimport { schedule_Effect } from '../schedule.esm.js';\nimport { track } from '../supervisor.esm.js';\nimport { get, set as set$1, empty } from '../../MutableHashMap/dist/effect-MutableHashMap.esm.js';\nimport { isNone, some, none, flatMap as flatMap$1, map as map$1 } from '../../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isIterable } from '../../Predicate/dist/effect-Predicate.esm.js';\nimport { currentScheduler } from '../../Scheduler/dist/effect-Scheduler.esm.js';\n\n/** @internal */\nclass Semaphore {\n  waiters = new Array();\n  taken = 0;\n  constructor(permits) {\n    this.permits = permits;\n  }\n  get free() {\n    return this.permits - this.taken;\n  }\n  take = n => asyncEither(resume => {\n    if (this.free < n) {\n      const observer = () => {\n        if (this.free >= n) {\n          const observerIndex = this.waiters.findIndex(cb => cb === observer);\n          if (observerIndex !== -1) {\n            this.waiters.splice(observerIndex, 1);\n          }\n          this.taken += n;\n          resume(succeed(n));\n        }\n      };\n      this.waiters.push(observer);\n      return left(sync(() => {\n        const observerIndex = this.waiters.findIndex(cb => cb === observer);\n        if (observerIndex !== -1) {\n          this.waiters.splice(observerIndex, 1);\n        }\n      }));\n    }\n    this.taken += n;\n    return right(succeed(n));\n  });\n  release = n => withFiberRuntime(fiber => {\n    this.taken -= n;\n    fiber.getFiberRef(currentScheduler).scheduleTask(() => {\n      this.waiters.forEach(wake => wake());\n    }, fiber.getFiberRef(currentSchedulingPriority));\n    return unit;\n  });\n  withPermits = n => self => uninterruptibleMask(restore => flatMap(restore(this.take(n)), permits => ensuring(restore(self), this.release(permits))));\n}\n\n/** @internal */\nconst unsafeMakeSemaphore = leases => {\n  return new Semaphore(leases);\n};\n\n/** @internal */\nconst makeSemaphore = permits => sync(() => unsafeMakeSemaphore(permits));\n\n/** @internal */\nconst awaitAllChildren = self => ensuringChildren(self, fiberAwaitAll);\n\n/** @internal */\nconst cached = /*#__PURE__*/dual(2, (self, timeToLive) => map(cachedInvalidate(self, timeToLive), tuple => tuple[0]));\n\n/** @internal */\nconst cachedInvalidate = /*#__PURE__*/dual(2, (self, timeToLive) => {\n  const duration = decode(timeToLive);\n  return flatMap(context(), env => map(makeSynchronized(none()), cache => [provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));\n});\n\n/** @internal */\nconst computeCachedValue = (self, timeToLive, start) => {\n  const timeToLiveMillis = toMillis(decode(timeToLive));\n  return pipe(deferredMake(), tap(deferred => intoDeferred(self, deferred)), map(deferred => some([start + timeToLiveMillis, deferred])));\n};\n\n/** @internal */\nconst getCachedValue = (self, timeToLive, cache) => uninterruptibleMask(restore => pipe(clockWith(clock => clock.currentTimeMillis), flatMap(time => updateSomeAndGetEffectSynchronized(cache, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return some(computeCachedValue(self, timeToLive, time));\n      }\n    case \"Some\":\n      {\n        const [end] = option.value;\n        return end - time <= 0 ? some(computeCachedValue(self, timeToLive, time)) : none();\n      }\n  }\n})), flatMap(option => isNone(option) ? dieMessage(\"BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/io/issues\") : restore(deferredAwait(option.value[1])))));\n\n/** @internal */\nconst invalidateCache = cache => set(cache, none());\n\n/** @internal */\nconst ensuringChild = /*#__PURE__*/dual(2, (self, f) => ensuringChildren(self, children => f(fiberAll(children))));\n\n/** @internal */\nconst ensuringChildren = /*#__PURE__*/dual(2, (self, children) => flatMap(track, supervisor => pipe(supervised(self, supervisor), ensuring(flatMap(supervisor.value(), children)))));\n\n/** @internal */\n// @ts-expect-error\nconst forkAll = /*#__PURE__*/dual(args => isIterable(args[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map(forEachSequential(effects, fork), fiberAll));\n\n/** @internal */\nconst forkIn = /*#__PURE__*/dual(2, (self, scope) => uninterruptibleMask(restore => flatMap(scope.fork(sequential), child => pipe(restore(self), onExit(exit => child.close(exit)), forkDaemon, tap(fiber => child.addFinalizer(() => fiberIdWith(fiberId => equals(fiberId, fiber.id()) ? unit : asUnit(interruptFiber(fiber)))))))));\n\n/** @internal */\nconst forkScoped = self => scopeWith(scope => forkIn(self, scope));\n\n/** @internal */\nconst fromFiber = fiber => join(fiber);\n\n/** @internal */\nconst fromFiberEffect = fiber => suspend(() => flatMap(fiber, join));\nconst memoKeySymbol = /*#__PURE__*/Symbol.for(\"effect/Effect/memoizeFunction.key\");\nclass Key {\n  [memoKeySymbol] = memoKeySymbol;\n  constructor(a, eq) {\n    this.a = a;\n    this.eq = eq;\n  }\n  [symbol](that) {\n    if (typeof that === \"object\" && that !== null && memoKeySymbol in that) {\n      if (this.eq) {\n        return this.eq(this.a, that.a);\n      } else {\n        return equals(this.a, that.a);\n      }\n    }\n    return false;\n  }\n  [symbol$1]() {\n    return this.eq ? 0 : hash(this.a);\n  }\n}\n\n/** @internal */\nconst memoizeFunction = (f, eq) => {\n  return pipe(sync(() => empty()), flatMap(makeSynchronized), map(ref => a => pipe(ref.modifyEffect(map$1 => {\n    const result = pipe(map$1, get(new Key(a, eq)));\n    if (isNone(result)) {\n      return pipe(deferredMake(), tap(deferred => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map(deferred => [deferred, pipe(map$1, set$1(new Key(a, eq), deferred))]));\n    }\n    return succeed([result.value, map$1]);\n  }), flatMap(deferredAwait), flatMap(([patch, b]) => pipe(patchFiberRefs(patch), as(b))))));\n};\n\n/** @internal */\nconst raceFirst = /*#__PURE__*/dual(2, (self, that) => pipe(exit(self), race(exit(that)), effect => flatten(effect)));\n\n/** @internal */\nconst scheduleForked = /*#__PURE__*/dual(2, (self, schedule) => pipe(self, schedule_Effect(schedule), forkScoped));\n\n/** @internal */\nconst supervised = /*#__PURE__*/dual(2, (self, supervisor) => {\n  const supervise = fiberRefLocallyWith(currentSupervisor, s => s.zip(supervisor));\n  return supervise(self);\n});\n\n/** @internal */\nconst timeout = /*#__PURE__*/dual(2, (self, duration) => timeoutTo(self, {\n  onTimeout: none,\n  onSuccess: some,\n  duration\n}));\n\n/** @internal */\nconst timeoutFail = /*#__PURE__*/dual(2, (self, {\n  duration,\n  onTimeout\n}) => flatten(timeoutTo(self, {\n  onTimeout: () => failSync(onTimeout),\n  onSuccess: succeed,\n  duration\n})));\n\n/** @internal */\nconst timeoutFailCause = /*#__PURE__*/dual(2, (self, {\n  duration,\n  onTimeout\n}) => flatten(timeoutTo(self, {\n  onTimeout: () => failCauseSync(onTimeout),\n  onSuccess: succeed,\n  duration\n})));\n\n/** @internal */\nconst timeoutTo = /*#__PURE__*/dual(2, (self, {\n  duration,\n  onSuccess,\n  onTimeout\n}) => fiberIdWith(parentFiberId => raceFibersWith(self, interruptible(sleep(duration)), {\n  onSelfWin: (winner, loser) => flatMap(winner.await(), exit => {\n    if (exit._tag === \"Success\") {\n      return flatMap(winner.inheritAll(), () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit.value)));\n    } else {\n      return flatMap(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit.cause));\n    }\n  }),\n  onOtherWin: (winner, loser) => flatMap(winner.await(), exit => {\n    if (exit._tag === \"Success\") {\n      return flatMap(winner.inheritAll(), () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));\n    } else {\n      return flatMap(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit.cause));\n    }\n  }),\n  otherScope: globalScope\n})));\n\n// circular with Synchronized\n\n/** @internal */\nconst SynchronizedSymbolKey = \"effect/Ref/SynchronizedRef\";\n\n/** @internal */\nconst SynchronizedTypeId = /*#__PURE__*/Symbol.for(SynchronizedSymbolKey);\n\n/** @internal */\nconst synchronizedVariance = {\n  _A: _ => _\n};\n\n/** @internal */\nclass SynchronizedImpl {\n  [SynchronizedTypeId] = synchronizedVariance;\n  [RefTypeId] = refVariance;\n  constructor(ref, withLock) {\n    this.ref = ref;\n    this.withLock = withLock;\n  }\n  modify(f) {\n    return this.modifyEffect(a => succeed(f(a)));\n  }\n  modifyEffect(f) {\n    return this.withLock(pipe(flatMap(get$1(this.ref), f), flatMap(([b, a]) => as(set(this.ref, a), b))));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst makeSynchronized = value => sync(() => unsafeMakeSynchronized(value));\n\n/** @internal */\nconst unsafeMakeSynchronized = value => {\n  const ref = unsafeMake(value);\n  const sem = unsafeMakeSemaphore(1);\n  return new SynchronizedImpl(ref, sem.withPermits(1));\n};\n\n/** @internal */\nconst updateSomeAndGetEffectSynchronized = /*#__PURE__*/dual(2, (self, pf) => self.modifyEffect(value => {\n  const result = pf(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return map(result.value, a => [a, a]);\n      }\n  }\n}));\n\n// circular with Fiber\n\n/** @internal */\nconst zipFiber = /*#__PURE__*/dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));\n\n/** @internal */\nconst zipLeftFiber = /*#__PURE__*/dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));\n\n/** @internal */\nconst zipRightFiber = /*#__PURE__*/dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));\n\n/** @internal */\nconst zipWithFiber = /*#__PURE__*/dual(3, (self, that, f) => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => pipe(self.id(), getOrElse(that.id())),\n  await: () => pipe(self.await(), flatten, zipWithOptions(flatten(that.await()), f, {\n    concurrent: true\n  }), exit),\n  children: () => self.children(),\n  inheritAll: () => zipRight(that.inheritAll(), self.inheritAll()),\n  poll: () => zipWith(self.poll(), that.poll(), (optionA, optionB) => pipe(optionA, flatMap$1(exitA => pipe(optionB, map$1(exitB => zipWith$1(exitA, exitB, {\n    onSuccess: f,\n    onFailure: parallel\n  })))))),\n  interruptAsFork: id => zipRight(self.interruptAsFork(id), that.interruptAsFork(id)),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}));\n\nexport { SynchronizedTypeId, awaitAllChildren, cached, cachedInvalidate, ensuringChild, ensuringChildren, forkAll, forkIn, forkScoped, fromFiber, fromFiberEffect, makeSemaphore, makeSynchronized, memoizeFunction, raceFirst, scheduleForked, supervised, synchronizedVariance, timeout, timeoutFail, timeoutFailCause, timeoutTo, unsafeMakeSemaphore, unsafeMakeSynchronized, updateSomeAndGetEffectSynchronized, zipFiber, zipLeftFiber, zipRightFiber, zipWithFiber };\n","import { CauseTypeId as CauseTypeId$1, RuntimeExceptionTypeId as RuntimeExceptionTypeId$1, InterruptedExceptionTypeId as InterruptedExceptionTypeId$1, IllegalArgumentExceptionTypeId as IllegalArgumentExceptionTypeId$1, NoSuchElementExceptionTypeId as NoSuchElementExceptionTypeId$1, InvalidPubSubCapacityExceptionTypeId as InvalidPubSubCapacityExceptionTypeId$1, empty as empty$1, fail as fail$1, die as die$1, interrupt as interrupt$1, parallel as parallel$1, sequential as sequential$1, isCause as isCause$1, isEmptyType as isEmptyType$1, isFailType as isFailType$1, isDieType as isDieType$1, isInterruptType as isInterruptType$1, isSequentialType as isSequentialType$1, isParallelType as isParallelType$1, size as size$1, isEmpty as isEmpty$1, isFailure as isFailure$1, isDie as isDie$1, isInterrupted as isInterrupted$1, isInterruptedOnly as isInterruptedOnly$1, failures as failures$1, defects as defects$1, interruptors as interruptors$1, failureOption as failureOption$1, failureOrCause as failureOrCause$1, flipCauseOption as flipCauseOption$1, dieOption as dieOption$1, interruptOption as interruptOption$1, keepDefects as keepDefects$1, linearize as linearize$1, stripFailures as stripFailures$1, stripSomeDefects as stripSomeDefects$1, as as as$1, map as map$1, flatMap as flatMap$1, flatten as flatten$1, contains as contains$1, squash as squash$1, squashWith as squashWith$1, find as find$1, filter as filter$1, match as match$1, reduce as reduce$1, reduceWithContext as reduceWithContext$1, InterruptedException as InterruptedException$1, isInterruptedException as isInterruptedException$1, IllegalArgumentException as IllegalArgumentException$1, isIllegalArgumentException as isIllegalArgumentException$1, NoSuchElementException as NoSuchElementException$1, isNoSuchElementException as isNoSuchElementException$1, RuntimeException as RuntimeException$1, isRuntimeException as isRuntimeException$1, pretty as pretty$1 } from '../../internal/cause.esm.js';\nimport { originalInstance } from '../../internal/core.esm.js';\n\n/**\n * The `Effect<R, E, A>` type is polymorphic in values of type `E` and we can\n * work with any error type that we want. However, there is a lot of information\n * that is not inside an arbitrary `E` value. So as a result, an `Effect` needs\n * somewhere to store things like unexpected errors or defects, stack and\n * execution traces, causes of fiber interruptions, and so forth.\n *\n * Effect-TS is very strict about preserving the full information related to a\n * failure. It captures all type of errors into the `Cause` data type. `Effect`\n * uses the `Cause<E>` data type to store the full story of failure. So its\n * error model is lossless. It doesn't throw information related to the failure\n * result. So we can figure out exactly what happened during the operation of\n * our effects.\n *\n * It is important to note that `Cause` is an underlying data type representing\n * errors occuring within an `Effect` workflow. Thus, we don't usually deal with\n * `Cause`s directly. Even though it is not a data type that we deal with very\n * often, the `Cause` of a failing `Effect` workflow can be accessed at any\n * time, which gives us total access to all parallel and sequential errors in\n * occurring within our codebase.\n *\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst CauseTypeId = CauseTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst RuntimeExceptionTypeId = RuntimeExceptionTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst InterruptedExceptionTypeId = InterruptedExceptionTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst IllegalArgumentExceptionTypeId = IllegalArgumentExceptionTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst NoSuchElementExceptionTypeId = NoSuchElementExceptionTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst InvalidPubSubCapacityExceptionTypeId = InvalidPubSubCapacityExceptionTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * A `Cause` represents the full history of a failure resulting from running an\n * `Effect` workflow.\n *\n * Effect-TS uses a data structure from functional programming called a semiring\n * to represent the `Cause` data type. This allows us to take a base type `E`\n * (which represents the error type of an `Effect`) and capture the sequential\n * and parallel composition of errors in a fully lossless fashion.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Represents a set of methods that can be used to reduce a `Cause<E>` to a\n * specified value of type `Z` with access to a context of type `C`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Represents a generic checked exception which occurs at runtime.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Represents a checked exception which occurs when a `Fiber` is interrupted.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Represents a checked exception which occurs when an invalid argument is\n * provided to a method.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Represents a checked exception which occurs when attempting to construct a\n * `PubSub` with an invalid capacity.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The `Empty` cause represents a lack of errors.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The `Fail` cause represents a `Cause` which failed with an expected error of\n * type `E`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The `Die` cause represents a `Cause` which failed as a result of a defect, or\n * in other words, an unexpected error.\n *\n * type `E`.\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The `Interrupt` cause represents failure due to `Fiber` interruption, which\n * contains the `FiberId` of the interrupted `Fiber`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The `Parallel` cause represents the composition of two causes which occurred\n * in parallel.\n *\n * In Effect-TS programs, it is possible that two operations may be performed in\n * parallel. In these cases, the `Effect` workflow can fail for more than one\n * reason. If both computations fail, then there are actually two errors which\n * occurred in parallel. In these cases, the errors can be represented by the\n * `Parallel` cause.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The `Sequential` cause represents the composition of two causes which occurred\n * sequentially.\n *\n * For example, if we perform Effect-TS's analog of `try-finally` (i.e.\n * `Effect.ensuring`), and both the `try` and `finally` blocks fail, we have two\n * errors which occurred sequentially. In these cases, the errors can be\n * represented by the `Sequential` cause.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Constructs a new `Empty` cause.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Constructs a new `Fail` cause from the specified `error`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fail = fail$1;\n\n/**\n * Constructs a new `Die` cause from the specified `defect`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst die = die$1;\n\n/**\n * Constructs a new `Interrupt` cause from the specified `fiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst interrupt = interrupt$1;\n\n/**\n * Constructs a new `Parallel` cause from the specified `left` and `right`\n * causes.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst parallel = parallel$1;\n\n/**\n * Constructs a new `Sequential` cause from the specified pecified `left` and\n * `right` causes.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst sequential = sequential$1;\n\n/**\n * Returns `true` if the specified value is a `Cause`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isCause = isCause$1;\n\n/**\n * Returns `true` if the specified `Cause` is an `Empty` type, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isEmptyType = isEmptyType$1;\n\n/**\n * Returns `true` if the specified `Cause` is a `Fail` type, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isFailType = isFailType$1;\n\n/**\n * Returns `true` if the specified `Cause` is a `Die` type, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isDieType = isDieType$1;\n\n/**\n * Returns `true` if the specified `Cause` is an `Interrupt` type, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isInterruptType = isInterruptType$1;\n\n/**\n * Returns `true` if the specified `Cause` is a `Sequential` type, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isSequentialType = isSequentialType$1;\n\n/**\n * Returns `true` if the specified `Cause` is a `Parallel` type, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isParallelType = isParallelType$1;\n\n/**\n * Returns the size of the cause, calculated as the number of individual `Cause`\n * nodes found in the `Cause` semiring structure.\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = size$1;\n\n/**\n * Returns `true` if the specified cause is empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isEmpty = isEmpty$1;\n\n/**\n * Returns `true` if the specified cause contains a failure, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isFailure = isFailure$1;\n\n/**\n * Returns `true` if the specified cause contains a defect, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isDie = isDie$1;\n\n/**\n * Returns `true` if the specified cause contains an interruption, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isInterrupted = isInterrupted$1;\n\n/**\n * Returns `true` if the specified cause contains only interruptions (without\n * any `Die` or `Fail` causes), `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isInterruptedOnly = isInterruptedOnly$1;\n\n/**\n * Returns a `List` of all recoverable errors of type `E` in the specified\n * cause.\n *\n * @since 2.0.0\n * @category getters\n */\nconst failures = failures$1;\n\n/**\n * Returns a `List` of all unrecoverable defects in the specified cause.\n *\n * @since 2.0.0\n * @category getters\n */\nconst defects = defects$1;\n\n/**\n * Returns a `HashSet` of `FiberId`s for all fibers that interrupted the fiber\n * described by the specified cause.\n *\n * @since 2.0.0\n * @category getters\n */\nconst interruptors = interruptors$1;\n\n/**\n * Returns the `E` associated with the first `Fail` in this `Cause`, if one\n * exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst failureOption = failureOption$1;\n\n/**\n * Returns the first checked error on the `Left` if available, if there are\n * no checked errors return the rest of the `Cause` that is known to contain\n * only `Die` or `Interrupt` causes.\n *\n * @since 2.0.0\n * @category getters\n */\nconst failureOrCause = failureOrCause$1;\n\n/**\n * Converts the specified `Cause<Option<E>>` to an `Option<Cause<E>>` by\n * recursively stripping out any failures with the error `None`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst flipCauseOption = flipCauseOption$1;\n\n/**\n * Returns the defect associated with the first `Die` in this `Cause`, if one\n * exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst dieOption = dieOption$1;\n\n/**\n * Returns the `FiberId` associated with the first `Interrupt` in the specified\n * cause, if one exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst interruptOption = interruptOption$1;\n\n/**\n * Remove all `Fail` and `Interrupt` nodes from the specified cause, and return\n * a cause containing only `Die` cause/finalizer defects.\n *\n * @since 2.0.0\n * @category getters\n */\nconst keepDefects = keepDefects$1;\n\n/**\n * Linearizes the specified cause into a `HashSet` of parallel causes where each\n * parallel cause contains a linear sequence of failures.\n *\n * @since 2.0.0\n * @category getters\n */\nconst linearize = linearize$1;\n\n/**\n * Remove all `Fail` and `Interrupt` nodes from the specified cause, and return\n * a cause containing only `Die` cause/finalizer defects.\n *\n * @since 2.0.0\n * @category getters\n */\nconst stripFailures = stripFailures$1;\n\n/**\n * Remove all `Die` causes that the specified partial function is defined at,\n * returning `Some` with the remaining causes or `None` if there are no\n * remaining causes.\n *\n * @since 2.0.0\n * @category getters\n */\nconst stripSomeDefects = stripSomeDefects$1;\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nconst as = as$1;\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = flatMap$1;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatten = flatten$1;\n\n/**\n * Returns `true` if the `self` cause contains or is equal to `that` cause,\n * `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nconst contains = contains$1;\n\n/**\n * Squashes a `Cause` down to a single defect, chosen to be the \"most important\"\n * defect.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst squash = squash$1;\n\n/**\n * Squashes a `Cause` down to a single defect, chosen to be the \"most important\"\n * defect. If a recoverable error is found, the provided function will be used\n * to map the error a defect, and the resulting value will be returned.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst squashWith = squashWith$1;\n\n/**\n * Uses the provided partial function to search the specified cause and attempt\n * to extract information from it.\n *\n * @since 2.0.0\n * @category elements\n */\nconst find = find$1;\n\n/**\n * Filters causes which match the provided predicate out of the specified cause.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filter = filter$1;\n\n/**\n * Folds the specified cause into a value of type `Z`.\n *\n * @since 2.0.0\n * @category folding\n */\nconst match = match$1;\n\n/**\n * Reduces the specified cause into a value of type `Z`, beginning with the\n * provided `zero` value.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduce = reduce$1;\n\n/**\n * Reduces the specified cause into a value of type `Z` using a `Cause.Reducer`.\n * Also allows for accessing the provided context during reduction.\n *\n * @since 2.0.0\n * @category folding\n */\nconst reduceWithContext = reduceWithContext$1;\n\n/**\n * Represents a checked exception which occurs when a `Fiber` is interrupted.\n *\n * @since 2.0.0\n * @category errors\n */\nconst InterruptedException = InterruptedException$1;\n\n/**\n * Returns `true` if the specified value is an `InterruptedException`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isInterruptedException = isInterruptedException$1;\n\n/**\n * Represents a checked exception which occurs when an invalid argument is\n * provided to a method.\n *\n * @since 2.0.0\n * @category errors\n */\nconst IllegalArgumentException = IllegalArgumentException$1;\n\n/**\n * Returns `true` if the specified value is an `IllegalArgumentException`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isIllegalArgumentException = isIllegalArgumentException$1;\n\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 2.0.0\n * @category errors\n */\nconst NoSuchElementException = NoSuchElementException$1;\n\n/**\n * Returns `true` if the specified value is an `NoSuchElementException`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isNoSuchElementException = isNoSuchElementException$1;\n\n/**\n * Represents a generic checked exception which occurs at runtime.\n *\n * @since 2.0.0\n * @category errors\n */\nconst RuntimeException = RuntimeException$1;\n\n/**\n * Returns `true` if the specified value is an `RuntimeException`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isRuntimeException = isRuntimeException$1;\n\n/**\n * Returns the specified `Cause` as a pretty-printed string.\n *\n * @since 2.0.0\n * @category rendering\n */\nconst pretty = pretty$1;\n\n/**\n * Returns the original, unproxied, instance of a thrown error\n *\n * @since 2.0.0\n * @category errors\n */\nconst originalError = originalInstance;\n\nexport { CauseTypeId, IllegalArgumentException, IllegalArgumentExceptionTypeId, InterruptedException, InterruptedExceptionTypeId, InvalidPubSubCapacityExceptionTypeId, NoSuchElementException, NoSuchElementExceptionTypeId, RuntimeException, RuntimeExceptionTypeId, as, contains, defects, die, dieOption, empty, fail, failureOption, failureOrCause, failures, filter, find, flatMap, flatten, flipCauseOption, interrupt, interruptOption, interruptors, isCause, isDie, isDieType, isEmpty, isEmptyType, isFailType, isFailure, isIllegalArgumentException, isInterruptType, isInterrupted, isInterruptedException, isInterruptedOnly, isNoSuchElementException, isParallelType, isRuntimeException, isSequentialType, keepDefects, linearize, map, match, originalError, parallel, pretty, reduce, reduceWithContext, sequential, size, squash, squashWith, stripFailures, stripSomeDefects };\n","/** @internal */\nconst OP_EXTEND_SCOPE = \"ExtendScope\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FOLD = \"Fold\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FRESH = \"Fresh\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FROM_EFFECT = \"FromEffect\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SCOPED = \"Scoped\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SUSPEND = \"Suspend\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PROVIDE_TO = \"ProvideTo\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ZIP_WITH = \"ZipWith\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ZIP_WITH_PAR = \"ZipWithPar\";\n\n/** @internal */\n\nexport { OP_EXTEND_SCOPE, OP_FOLD, OP_FRESH, OP_FROM_EFFECT, OP_PROVIDE_TO, OP_SCOPED, OP_SUSPEND, OP_ZIP_WITH, OP_ZIP_WITH_PAR };\n","import { interruptFiber, interruptAsFiber } from '../../internal/core.esm.js';\nimport { zipFiber, zipLeftFiber, zipRightFiber, zipWithFiber } from '../../internal/effect/circular.esm.js';\nimport { FiberTypeId as FiberTypeId$1, RuntimeFiberTypeId as RuntimeFiberTypeId$1, Order as Order$1, isFiber as isFiber$1, isRuntimeFiber as isRuntimeFiber$1, id as id$1, _await as _await$1, children as children$1, done as done$1, dump as dump$1, dumpAll as dumpAll$1, fail as fail$1, failCause as failCause$1, fromEffect as fromEffect$1, getCurrentFiber as getCurrentFiber$1, inheritAll as inheritAll$1, interrupted as interrupted$1, interruptAsFork as interruptAsFork$1, interruptAll as interruptAll$1, interruptAllAs as interruptAllAs$1, join as join$1, map as map$1, mapEffect as mapEffect$1, mapFiber as mapFiber$1, match as match$1, never as never$1, orElse as orElse$1, orElseEither as orElseEither$1, poll as poll$1, pretty as pretty$1, roots as roots$1, unsafeRoots as unsafeRoots$1, status as status$1, succeed as succeed$1, unit as unit$1 } from '../../internal/fiber.esm.js';\nimport { fiberAwaitAll, fiberAll, fiberInterruptFork, fiberJoinAll, fiberScoped } from '../../internal/fiberRuntime.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst FiberTypeId = FiberTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst RuntimeFiberTypeId = RuntimeFiberTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * A fiber is a lightweight thread of execution that never consumes more than a\n * whole thread (but may consume much less, depending on contention and\n * asynchronicity). Fibers are spawned by forking effects, which run\n * concurrently with the parent effect.\n *\n * Fibers can be joined, yielding their result to other fibers, or interrupted,\n * which terminates the fiber, safely releasing all resources.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * A runtime fiber that is executing an effect. Runtime fibers have an\n * identity and a trace.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category instances\n */\nconst Order = Order$1;\n\n/**\n * Returns `true` if the specified value is a `Fiber`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isFiber = isFiber$1;\n\n/**\n * Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isRuntimeFiber = isRuntimeFiber$1;\n\n/**\n * The identity of the fiber.\n *\n * @since 2.0.0\n * @category getters\n */\nconst id = id$1;\nconst _await = _await$1;\n\n/**\n * Awaits on all fibers to be completed, successfully or not.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst awaitAll = fiberAwaitAll;\n\n/**\n * Retrieves the immediate children of the fiber.\n *\n * @since 2.0.0\n * @category getters\n */\nconst children = children$1;\n\n/**\n * Collects all fibers into a single fiber producing an in-order list of the\n * results.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst all = fiberAll;\n\n/**\n * A fiber that is done with the specified `Exit` value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst done = done$1;\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nconst dump = dump$1;\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nconst dumpAll = dumpAll$1;\n\n/**\n * A fiber that has already failed with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fail = fail$1;\n\n/**\n * Creates a `Fiber` that has already failed with the specified cause.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failCause = failCause$1;\n\n/**\n * Lifts an `Effect` into a `Fiber`.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst fromEffect = fromEffect$1;\n\n/**\n * Gets the current fiber if one is running.\n *\n * @since 2.0.0\n * @category utilities\n */\nconst getCurrentFiber = getCurrentFiber$1;\n\n/**\n * Inherits values from all `FiberRef` instances into current fiber. This\n * will resume immediately.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst inheritAll = inheritAll$1;\n\n/**\n * Interrupts the fiber from whichever fiber is calling this method. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst interrupt = interruptFiber;\n\n/**\n * Constructrs a `Fiber` that is already interrupted.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst interrupted = interrupted$1;\n\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst interruptAs = interruptAsFiber;\n\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst interruptAsFork = interruptAsFork$1;\n\n/**\n * Interrupts all fibers, awaiting their interruption.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst interruptAll = interruptAll$1;\n\n/**\n * Interrupts all fibers as by the specified fiber, awaiting their\n * interruption.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst interruptAllAs = interruptAllAs$1;\n\n/**\n * Interrupts the fiber from whichever fiber is calling this method. The\n * interruption will happen in a separate daemon fiber, and the returned\n * effect will always resume immediately without waiting.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst interruptFork = fiberInterruptFork;\n\n/**\n * Joins the fiber, which suspends the joining fiber until the result of the\n * fiber has been determined. Attempting to join a fiber that has erred will\n * result in a catchable error. Joining an interrupted fiber will result in an\n * \"inner interruption\" of this fiber, unlike interruption triggered by\n * another fiber, \"inner interruption\" can be caught and recovered.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst join = join$1;\n\n/**\n * Joins all fibers, awaiting their _successful_ completion. Attempting to\n * join a fiber that has erred will result in a catchable error, _if_ that\n * error does not result from interruption.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst joinAll = fiberJoinAll;\n\n/**\n * Maps over the value the Fiber computes.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * Effectually maps over the value the fiber computes.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapEffect = mapEffect$1;\n\n/**\n * Passes the success of this fiber to the specified callback, and continues\n * with the fiber that it returns.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapFiber = mapFiber$1;\n\n/**\n * Folds over the `Fiber` or `RuntimeFiber`.\n *\n * @since 2.0.0\n * @category folding\n */\nconst match = match$1;\n\n/**\n * A fiber that never fails or succeeds.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst never = never$1;\n\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orElse = orElse$1;\n\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orElseEither = orElseEither$1;\n\n/**\n * Tentatively observes the fiber, but returns immediately if it is not\n * already done.\n *\n * @since 2.0.0\n * @category getters\n */\nconst poll = poll$1;\n\n/**\n * Pretty-prints a `RuntimeFiber`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst pretty = pretty$1;\n\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst roots = roots$1;\n\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unsafeRoots = unsafeRoots$1;\n\n/**\n * Converts this fiber into a scoped effect. The fiber is interrupted when the\n * scope is closed.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst scoped = fiberScoped;\n\n/**\n * Returns the `FiberStatus` of a `RuntimeFiber`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst status = status$1;\n\n/**\n * Returns a fiber that has already succeeded with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeed = succeed$1;\n\n/**\n * A fiber that has already succeeded with unit.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unit = unit$1;\n\n/**\n * Zips this fiber and the specified fiber together, producing a tuple of\n * their output.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zip = zipFiber;\n\n/**\n * Same as `zip` but discards the output of that `Fiber`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipLeft = zipLeftFiber;\n\n/**\n * Same as `zip` but discards the output of this `Fiber`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipRight = zipRightFiber;\n\n/**\n * Zips this fiber with the specified fiber, combining their results using the\n * specified combiner function. Both joins and interruptions are performed in\n * sequential order from left to right.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWith = zipWithFiber;\n\nexport { FiberTypeId, Order, RuntimeFiberTypeId, all, _await as await, awaitAll, children, done, dump, dumpAll, fail, failCause, fromEffect, getCurrentFiber, id, inheritAll, interrupt, interruptAll, interruptAllAs, interruptAs, interruptAsFork, interruptFork, interrupted, isFiber, isRuntimeFiber, join, joinAll, map, mapEffect, mapFiber, match, never, orElse, orElseEither, poll, pretty, roots, scoped, status, succeed, unit, unsafeRoots, zip, zipLeft, zipRight, zipWith };\n","import { empty } from '../Context/dist/effect-Context.esm.js';\nimport { flatten } from '../Exit/dist/effect-Exit.esm.js';\nimport { interruptAs } from '../Fiber/dist/effect-Fiber.esm.js';\nimport { unsafeMake, none as none$2 } from '../FiberId/dist/effect-FiberId.esm.js';\nimport { updatedAs, forkAs, empty as empty$1 } from '../FiberRefs/dist/effect-FiberRefs.esm.js';\nimport { pipe } from '../Function/dist/effect-Function.esm.js';\nimport { toString, NodeInspectSymbol } from '../Inspectable/dist/effect-Inspectable.esm.js';\nimport { prettyErrors, NoSuchElementException } from './cause.esm.js';\nimport { currentContext, withFiberRuntime, flatMap, deferredMake, uninterruptibleMask, zipRight, catchAllCause, intoDeferred, deferredFailCause, deferredAwait, exitFail, exitSucceed, succeed } from './core.esm.js';\nimport { FiberRuntime, fork } from './fiberRuntime.esm.js';\nimport { globalScope } from './fiberScope.esm.js';\nimport { OP_FAILURE, OP_SUCCESS } from './opCodes/effect.esm.js';\nimport { make as make$1, RuntimeMetrics, CooperativeYielding, Interruption } from './runtimeFlags.esm.js';\nimport { none } from './supervisor.esm.js';\nimport { none as none$1 } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isTagged } from '../Predicate/dist/effect-Predicate.esm.js';\nimport { currentScheduler, SyncScheduler } from '../Scheduler/dist/effect-Scheduler.esm.js';\n\n/** @internal */\nconst unsafeFork = runtime => (self, options) => {\n  const fiberId = unsafeMake();\n  const effect = self;\n  let fiberRefs = updatedAs(runtime.fiberRefs, {\n    fiberId,\n    fiberRef: currentContext,\n    value: runtime.context\n  });\n  if (options?.scheduler) {\n    fiberRefs = updatedAs(fiberRefs, {\n      fiberId,\n      fiberRef: currentScheduler,\n      value: options.scheduler\n    });\n  }\n  if (options?.updateRefs) {\n    fiberRefs = options.updateRefs(fiberRefs, fiberId);\n  }\n  const fiberRuntime = new FiberRuntime(fiberId, forkAs(fiberRefs, fiberId), runtime.runtimeFlags);\n  const supervisor = fiberRuntime._supervisor;\n\n  // we can compare by reference here as _supervisor.none is wrapped with globalValue\n  if (supervisor !== none) {\n    supervisor.onStart(runtime.context, effect, none$1(), fiberRuntime);\n    fiberRuntime.addObserver(exit => supervisor.onEnd(exit, fiberRuntime));\n  }\n  globalScope.add(runtime.runtimeFlags, fiberRuntime);\n  fiberRuntime.start(effect);\n  return fiberRuntime;\n};\n\n/** @internal */\nconst unsafeRunCallback = runtime => (effect, onExit) => {\n  const fiberRuntime = unsafeFork(runtime)(effect);\n  if (onExit) {\n    fiberRuntime.addObserver(exit => {\n      onExit(exit);\n    });\n  }\n  return (id, onExitInterrupt) => unsafeRunCallback(runtime)(pipe(fiberRuntime, interruptAs(id ?? none$2)), onExitInterrupt ? exit => onExitInterrupt(flatten(exit)) : void 0);\n};\n\n/** @internal */\nconst unsafeRunSync = runtime => effect => {\n  const result = unsafeRunSyncExit(runtime)(effect);\n  if (result._tag === \"Failure\") {\n    throw fiberFailure(result.i0);\n  } else {\n    return result.i0;\n  }\n};\n\n/** @internal */\nconst asyncFiberException = fiber => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  const error = new Error();\n  Error.stackTraceLimit = limit;\n  const message = `Fiber #${fiber.id().id} cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work`;\n  const _tag = \"AsyncFiberException\";\n  Object.defineProperties(error, {\n    _tag: {\n      value: _tag\n    },\n    fiber: {\n      value: fiber\n    },\n    message: {\n      value: message\n    },\n    name: {\n      value: _tag\n    },\n    toString: {\n      get() {\n        return () => message;\n      }\n    },\n    [NodeInspectSymbol]: {\n      get() {\n        return () => message;\n      }\n    }\n  });\n  return error;\n};\n\n/** @internal */\nconst isAsyncFiberException = u => isTagged(u, \"AsyncFiberException\") && \"fiber\" in u;\n\n/** @internal */\nconst FiberFailureId = /*#__PURE__*/Symbol.for(\"effect/Runtime/FiberFailure\");\n/** @internal */\nconst FiberFailureCauseId = /*#__PURE__*/Symbol.for(\"effect/Runtime/FiberFailure/Cause\");\n/** @internal */\nconst fiberFailure = cause => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  const error = new Error();\n  Error.stackTraceLimit = limit;\n  const prettyErrors$1 = prettyErrors(cause);\n  if (prettyErrors$1.length > 0) {\n    const head = prettyErrors$1[0];\n    error.name = head.message.split(\":\")[0];\n    error.message = head.message.substring(error.name.length + 2);\n    error.stack = `${error.name}: ${error.message}\\n${head.stack}`;\n  }\n  error[FiberFailureId] = FiberFailureId;\n  error[FiberFailureCauseId] = cause;\n  error.toJSON = () => {\n    return {\n      _id: \"FiberFailure\",\n      cause: cause.toJSON()\n    };\n  };\n  error.toString = () => {\n    return toString(error.toJSON());\n  };\n  error[NodeInspectSymbol] = () => {\n    return error.toJSON();\n  };\n  return error;\n};\n\n/** @internal */\nconst isFiberFailure = u => typeof u === \"object\" && u !== null && FiberFailureId in u;\nconst fastPath = effect => {\n  const op = effect;\n  switch (op._op) {\n    case \"Failure\":\n    case \"Success\":\n      {\n        // @ts-expect-error\n        return op;\n      }\n    case \"Left\":\n      {\n        return exitFail(op.left);\n      }\n    case \"Right\":\n      {\n        return exitSucceed(op.right);\n      }\n    case \"Some\":\n      {\n        return exitSucceed(op.value);\n      }\n    case \"None\":\n      {\n        // @ts-expect-error\n        return exitFail(NoSuchElementException());\n      }\n  }\n};\n\n/** @internal */\nconst unsafeRunSyncExit = runtime => effect => {\n  const op = fastPath(effect);\n  if (op) {\n    return op;\n  }\n  const scheduler = new SyncScheduler();\n  const fiberRuntime = unsafeFork(runtime)(effect, {\n    scheduler\n  });\n  scheduler.flush();\n  const result = fiberRuntime.unsafePoll();\n  if (result) {\n    return result;\n  }\n  throw asyncFiberException(fiberRuntime);\n};\n\n/** @internal */\nconst unsafeRunPromise = runtime => effect => unsafeRunPromiseExit(runtime)(effect).then(result => {\n  switch (result._tag) {\n    case OP_SUCCESS:\n      {\n        return result.i0;\n      }\n    case OP_FAILURE:\n      {\n        throw fiberFailure(result.i0);\n      }\n  }\n});\n\n/** @internal */\nconst unsafeRunPromiseExit = runtime => effect => new Promise(resolve => {\n  const op = fastPath(effect);\n  if (op) {\n    resolve(op);\n  }\n  unsafeFork(runtime)(effect).addObserver(exit => {\n    resolve(exit);\n  });\n});\n\n/** @internal */\nclass RuntimeImpl {\n  constructor(context, runtimeFlags, fiberRefs) {\n    this.context = context;\n    this.runtimeFlags = runtimeFlags;\n    this.fiberRefs = fiberRefs;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst make = options => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);\n\n/** @internal */\nconst runtime = () => withFiberRuntime((state, status) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status.runtimeFlags, state.getFiberRefs())));\n\n/** @internal */\nconst defaultRuntimeFlags = /*#__PURE__*/make$1(Interruption, CooperativeYielding, RuntimeMetrics);\n\n/** @internal */\nconst defaultRuntime = /*#__PURE__*/make({\n  context: /*#__PURE__*/empty(),\n  runtimeFlags: defaultRuntimeFlags,\n  fiberRefs: /*#__PURE__*/empty$1()\n});\n\n/** @internal */\nconst unsafeRunEffect = /*#__PURE__*/unsafeRunCallback(defaultRuntime);\n\n/** @internal */\nconst unsafeForkEffect = /*#__PURE__*/unsafeFork(defaultRuntime);\n\n/** @internal */\nconst unsafeRunPromiseEffect = /*#__PURE__*/unsafeRunPromise(defaultRuntime);\n\n/** @internal */\nconst unsafeRunPromiseExitEffect = /*#__PURE__*/unsafeRunPromiseExit(defaultRuntime);\n\n/** @internal */\nconst unsafeRunSyncEffect = /*#__PURE__*/unsafeRunSync(defaultRuntime);\n\n/** @internal */\nconst unsafeRunSyncExitEffect = /*#__PURE__*/unsafeRunSyncExit(defaultRuntime);\n\n// circular with Effect\n\n/** @internal */\nconst asyncEffect = register => flatMap(deferredMake(), deferred => flatMap(runtime(), runtime => uninterruptibleMask(restore => zipRight(fork(restore(catchAllCause(register(cb => unsafeRunCallback(runtime)(intoDeferred(cb, deferred))), cause => deferredFailCause(deferred, cause)))), restore(deferredAwait(deferred))))));\n\nexport { FiberFailureCauseId, FiberFailureId, RuntimeImpl, asyncEffect, defaultRuntime, defaultRuntimeFlags, fiberFailure, isAsyncFiberException, isFiberFailure, make, runtime, unsafeFork, unsafeForkEffect, unsafeRunCallback, unsafeRunEffect, unsafeRunPromise, unsafeRunPromiseEffect, unsafeRunPromiseExit, unsafeRunPromiseExitEffect, unsafeRunSync, unsafeRunSyncEffect, unsafeRunSyncExit, unsafeRunSyncExitEffect };\n","import { dual, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { map, succeed } from './core.esm.js';\nimport { getOrElse } from '../Option/dist/effect-Option.esm.js';\n\n/** @internal */\nconst getAndUpdateEffect = /*#__PURE__*/dual(2, (self, f) => self.modifyEffect(value => map(f(value), result => [value, result])));\n\n/** @internal */\nconst getAndUpdateSomeEffect = /*#__PURE__*/dual(2, (self, pf) => self.modifyEffect(value => {\n  const result = pf(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return map(result.value, newValue => [value, newValue]);\n      }\n  }\n}));\n\n/** @internal */\nconst modify = /*#__PURE__*/dual(2, (self, f) => self.modify(f));\n\n/** @internal */\nconst modifyEffect = /*#__PURE__*/dual(2, (self, f) => self.modifyEffect(f));\n\n/** @internal */\nconst modifySomeEffect = /*#__PURE__*/dual(3, (self, fallback, pf) => self.modifyEffect(value => pipe(pf(value), getOrElse(() => succeed([fallback, value])))));\n\n/** @internal */\nconst updateEffect = /*#__PURE__*/dual(2, (self, f) => self.modifyEffect(value => map(f(value), result => [undefined, result])));\n\n/** @internal */\nconst updateAndGetEffect = /*#__PURE__*/dual(2, (self, f) => self.modifyEffect(value => map(f(value), result => [result, result])));\n\n/** @internal */\nconst updateSomeEffect = /*#__PURE__*/dual(2, (self, pf) => self.modifyEffect(value => {\n  const result = pf(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return succeed([void 0, value]);\n      }\n    case \"Some\":\n      {\n        return map(result.value, a => [void 0, a]);\n      }\n  }\n}));\n\nexport { getAndUpdateEffect, getAndUpdateSomeEffect, modify, modifyEffect, modifySomeEffect, updateAndGetEffect, updateEffect, updateSomeEffect };\n","import { ScopeTypeId as ScopeTypeId$1, CloseableScopeTypeId as CloseableScopeTypeId$1, scopeAddFinalizer, scopeAddFinalizerExit, scopeClose, scopeFork } from '../../internal/core.esm.js';\nimport { scopeTag, scopeExtend, scopeUse, scopeMake } from '../../internal/fiberRuntime.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst ScopeTypeId = ScopeTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst CloseableScopeTypeId = CloseableScopeTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst Scope = scopeTag;\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Adds a finalizer to this scope. The finalizer is guaranteed to be run when\n * the scope is closed.\n *\n * @since 2.0.0\n * @category utils\n */\nconst addFinalizer = scopeAddFinalizer;\n\n/**\n * A simplified version of `addFinalizerWith` when the `finalizer` does not\n * depend on the `Exit` value that the scope is closed with.\n *\n * @since 2.0.0\n * @category utils\n */\nconst addFinalizerExit = scopeAddFinalizerExit;\n\n/**\n * Closes a scope with the specified exit value, running all finalizers that\n * have been added to the scope.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst close = scopeClose;\n\n/**\n * Extends the scope of an `Effect` workflow that needs a scope into this\n * scope by providing it to the workflow but not closing the scope when the\n * workflow completes execution. This allows extending a scoped value into a\n * larger scope.\n *\n * @since 2.0.0\n * @category utils\n */\nconst extend = scopeExtend;\n\n/**\n * Forks a new scope that is a child of this scope. The child scope will\n * automatically be closed when this scope is closed.\n *\n * @since 2.0.0\n * @category utils\n */\nconst fork = scopeFork;\n\n/**\n * Uses the scope by providing it to an `Effect` workflow that needs a scope,\n * guaranteeing that the scope is closed with the result of that workflow as\n * soon as the workflow completes execution, whether by success, failure, or\n * interruption.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst use = scopeUse;\n\n/**\n * Creates a Scope where Finalizers will run according to the `ExecutionStrategy`.\n *\n * If an ExecutionStrategy is not provided `sequential` will be used.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = scopeMake;\n\nexport { CloseableScopeTypeId, Scope, ScopeTypeId, addFinalizer, addFinalizerExit, close, extend, fork, make, use };\n","import { die as die$1, fail as fail$1, failureOrCause } from '../Cause/dist/effect-Cause.esm.js';\nimport { sleep, currentTimeMillis } from '../Clock/dist/effect-Clock.esm.js';\nimport { empty, get, make, merge as merge$1, unsafeGet, Tag, isContext, isTag } from '../Context/dist/effect-Context.esm.js';\nimport { millis } from '../Duration/dist/effect-Duration.esm.js';\nimport { diff as diff$1 } from '../FiberRefsPatch/dist/effect-FiberRefsPatch.esm.js';\nimport { dual, pipe } from '../Function/dist/effect-Function.esm.js';\nimport { flatMap as flatMap$1, sync as sync$1, zipWith, provideContext, matchCauseEffect, context as context$1, failCause as failCause$1, failCauseSync as failCauseSync$1, map as map$1, fiberRefLocally as fiberRefLocally$1, fiberRefLocallyWith as fiberRefLocallyWith$1, zipRight, never, as, succeed as succeed$1, fail as fail$2, tap as tap$1, currentTracerSpan, provideSomeContext, acquireUseRelease, scopeClose, updateRuntimeFlags, flatten as flatten$1, onExit, exitMatch, unit, scopeAddFinalizerExit, deferredMake, uninterruptibleMask, exit, whenEffect, asUnit, deferredSucceed, deferredFailCause, deferredAwait, exitMatchEffect } from './core.esm.js';\nimport { memoize as memoize$1, patchFiberRefs, diffFiberRefs } from './core-effect.esm.js';\nimport { makeSynchronized } from './effect/circular.esm.js';\nimport { scopeWith, zipWithOptions, scopeExtend, fiberRefLocallyScoped as fiberRefLocallyScoped$1, fiberRefLocallyScopedWith as fiberRefLocallyScopedWith$1, scopedEffect, acquireRelease, scopeMake, makeSpanScoped, addFinalizer } from './fiberRuntime.esm.js';\nimport { OP_SUCCESS, OP_FAILURE } from './opCodes/effect.esm.js';\nimport { OP_FRESH, OP_EXTEND_SCOPE, OP_FROM_EFFECT, OP_FOLD, OP_ZIP_WITH, OP_SCOPED, OP_SUSPEND, OP_PROVIDE_TO, OP_ZIP_WITH_PAR } from './opCodes/layer.esm.js';\nimport { make as make$1, set, modify, update, get as get$1 } from './ref.esm.js';\nimport { runtime, defaultRuntime } from './runtime.esm.js';\nimport { modifyEffect } from './synchronizedRef.esm.js';\nimport { prepend } from '../List/dist/effect-List.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { isDone } from '../ScheduleDecision/dist/effect-ScheduleDecision.esm.js';\nimport { start } from '../ScheduleIntervals/dist/effect-ScheduleIntervals.esm.js';\nimport { Scope } from '../Scope/dist/effect-Scope.esm.js';\nimport { diff } from './runtimeFlags.esm.js';\n\n/** @internal */\nconst LayerSymbolKey = \"effect/Layer\";\n\n/** @internal */\nconst LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);\n\n/** @internal */\nconst layerVariance = {\n  _RIn: _ => _,\n  _E: _ => _,\n  _ROut: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [LayerTypeId]: layerVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst isLayer = u => {\n  return typeof u === \"object\" && u != null && LayerTypeId in u;\n};\n\n/** @internal */\nconst isFresh = self => {\n  return self._tag === OP_FRESH;\n};\n\n// -----------------------------------------------------------------------------\n// MemoMap\n// -----------------------------------------------------------------------------\n\n/** @internal */\nclass MemoMap {\n  constructor(ref) {\n    this.ref = ref;\n  }\n\n  /**\n   * Checks the memo map to see if a layer exists. If it is, immediately\n   * returns it. Otherwise, obtains the layer, stores it in the memo map,\n   * and adds a finalizer to the `Scope`.\n   */\n  getOrElseMemoize(layer, scope) {\n    return pipe(modifyEffect(this.ref, map => {\n      const inMap = map.get(layer);\n      if (inMap !== undefined) {\n        const [acquire, release] = inMap;\n        const cached = pipe(acquire, flatMap$1(([patch, b]) => pipe(patchFiberRefs(patch), as(b))), onExit(exitMatch({\n          onFailure: () => unit,\n          onSuccess: () => scopeAddFinalizerExit(scope, release)\n        })));\n        return succeed$1([cached, map]);\n      }\n      return pipe(make$1(0), flatMap$1(observers => pipe(deferredMake(), flatMap$1(deferred => pipe(make$1(() => unit), map$1(finalizerRef => {\n        const resource = uninterruptibleMask(restore => pipe(scopeMake(), flatMap$1(innerScope => pipe(restore(flatMap$1(withScope(layer, innerScope), f => diffFiberRefs(f(this)))), exit, flatMap$1(exit => {\n          switch (exit._tag) {\n            case OP_FAILURE:\n              {\n                return pipe(deferredFailCause(deferred, exit.i0), zipRight(scopeClose(innerScope, exit)), zipRight(failCause$1(exit.i0)));\n              }\n            case OP_SUCCESS:\n              {\n                return pipe(set(finalizerRef, exit => pipe(scopeClose(innerScope, exit), whenEffect(modify(observers, n => [n === 1, n - 1])), asUnit)), zipRight(update(observers, n => n + 1)), zipRight(scopeAddFinalizerExit(scope, exit => pipe(get$1(finalizerRef), flatMap$1(finalizer => finalizer(exit))))), zipRight(deferredSucceed(deferred, exit.i0)), as(exit.i0[1]));\n              }\n          }\n        })))));\n        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({\n          onFailure: () => unit,\n          onSuccess: () => update(observers, n => n + 1)\n        }))), exit => pipe(get$1(finalizerRef), flatMap$1(finalizer => finalizer(exit)))];\n        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];\n      }))))));\n    }), flatten$1);\n  }\n}\nconst makeMemoMap = () => map$1(makeSynchronized(new Map()), ref => new MemoMap(ref));\n\n/** @internal */\nconst build = self => scopeWith(scope => buildWithScope(self, scope));\n\n/** @internal */\nconst buildWithScope = /*#__PURE__*/dual(2, (self, scope) => flatMap$1(makeMemoMap(), memoMap => flatMap$1(withScope(self, scope), run => run(memoMap))));\nconst withScope = (self, scope) => {\n  const op = self;\n  switch (op._tag) {\n    case \"Locally\":\n      {\n        return sync$1(() => memoMap => op.f(memoMap.getOrElseMemoize(op.self, scope)));\n      }\n    case \"ExtendScope\":\n      {\n        return sync$1(() => memoMap => scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));\n      }\n    case \"Fold\":\n      {\n        return sync$1(() => memoMap => pipe(memoMap.getOrElseMemoize(op.layer, scope), matchCauseEffect({\n          onFailure: cause => memoMap.getOrElseMemoize(op.failureK(cause), scope),\n          onSuccess: value => memoMap.getOrElseMemoize(op.successK(value), scope)\n        })));\n      }\n    case \"Fresh\":\n      {\n        return sync$1(() => _ => pipe(op.layer, buildWithScope(scope)));\n      }\n    case \"FromEffect\":\n      {\n        return sync$1(() => _ => op.effect);\n      }\n    case \"ProvideTo\":\n      {\n        return sync$1(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), flatMap$1(env => pipe(memoMap.getOrElseMemoize(op.second, scope), provideContext(env)))));\n      }\n    case \"Scoped\":\n      {\n        return sync$1(() => _ => scopeExtend(op.effect, scope));\n      }\n    case \"Suspend\":\n      {\n        return sync$1(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));\n      }\n    case \"ZipWith\":\n      {\n        return sync$1(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)));\n      }\n    case \"ZipWithPar\":\n      {\n        return sync$1(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope), op.zipK, {\n          concurrent: true\n        })));\n      }\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Layer\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst catchAll = /*#__PURE__*/dual(2, (self, onFailure) => match(self, {\n  onFailure,\n  onSuccess: succeedContext\n}));\n\n/** @internal */\nconst catchAllCause = /*#__PURE__*/dual(2, (self, onFailure) => matchCause(self, {\n  onFailure,\n  onSuccess: succeedContext\n}));\n\n/** @internal */\nconst die = defect => failCause(die$1(defect));\n\n/** @internal */\nconst dieSync = evaluate => failCauseSync(() => die$1(evaluate()));\n\n/** @internal */\nconst discard = self => map(self, () => empty());\n\n/** @internal */\nconst context = () => fromEffectContext(context$1());\n\n/** @internal */\nconst extendScope = self => {\n  const extendScope = Object.create(proto);\n  extendScope._tag = OP_EXTEND_SCOPE;\n  extendScope.layer = self;\n  return extendScope;\n};\n\n/** @internal */\nconst fail = error => failCause(fail$1(error));\n\n/** @internal */\nconst failSync = evaluate => failCauseSync(() => fail$1(evaluate()));\n\n/** @internal */\nconst failCause = cause => fromEffectContext(failCause$1(cause));\n\n/** @internal */\nconst failCauseSync = evaluate => fromEffectContext(failCauseSync$1(evaluate));\n\n/** @internal */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {\n  onFailure: fail,\n  onSuccess: f\n}));\n\n/** @internal */\nconst flatten = /*#__PURE__*/dual(2, (self, tag) => flatMap(self, get(tag)));\n\n/** @internal */\nconst fresh = self => {\n  const fresh = Object.create(proto);\n  fresh._tag = OP_FRESH;\n  fresh.layer = self;\n  return fresh;\n};\n\n/** @internal */\nconst fromEffect = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = isTag(a);\n  const tag = tagFirst ? a : b;\n  const effect = tagFirst ? b : a;\n  return fromEffectContext(map$1(effect, service => make(tag, service)));\n});\n\n/** @internal */\nconst fromEffectDiscard = effect => fromEffectContext(map$1(effect, () => empty()));\n\n/** @internal */\nfunction fromEffectContext(effect) {\n  const fromEffect = Object.create(proto);\n  fromEffect._tag = OP_FROM_EFFECT;\n  fromEffect.effect = effect;\n  return fromEffect;\n}\n\n/** @internal */\nconst fiberRefLocally = /*#__PURE__*/dual(3, (self, ref, value) => locallyEffect(self, fiberRefLocally$1(ref, value)));\n\n/** @internal */\nconst locallyEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const locally = Object.create(proto);\n  locally._tag = \"Locally\";\n  locally.self = self;\n  locally.f = f;\n  return locally;\n});\n\n/** @internal */\nconst fiberRefLocallyWith = /*#__PURE__*/dual(3, (self, ref, value) => locallyEffect(self, fiberRefLocallyWith$1(ref, value)));\n\n/** @internal */\nconst fiberRefLocallyScoped = (self, value) => scopedDiscard(fiberRefLocallyScoped$1(self, value));\n\n/** @internal */\nconst fiberRefLocallyScopedWith = (self, value) => scopedDiscard(fiberRefLocallyScopedWith$1(self, value));\n\n/** @internal */\nconst fromFunction = (tagA, tagB, f) => fromEffectContext(map$1(tagA, a => make(tagB, f(a))));\n\n/** @internal */\nconst launch = self => scopedEffect(zipRight(scopeWith(scope => pipe(self, buildWithScope(scope))), never));\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, context => succeedContext(f(context))));\n\n/** @internal */\nconst mapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, error => failSync(() => f(error))));\n\n/** @internal */\nconst matchCause = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  const fold = Object.create(proto);\n  fold._tag = OP_FOLD;\n  fold.layer = self;\n  fold.failureK = onFailure;\n  fold.successK = onSuccess;\n  return fold;\n});\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchCause(self, {\n  onFailure: cause => {\n    const failureOrCause$1 = failureOrCause(cause);\n    switch (failureOrCause$1._tag) {\n      case \"Left\":\n        {\n          return onFailure(failureOrCause$1.left);\n        }\n      case \"Right\":\n        {\n          return failCause(failureOrCause$1.right);\n        }\n    }\n  },\n  onSuccess\n}));\n\n/** @internal */\nconst memoize = self => scopeWith(scope => map$1(memoize$1(buildWithScope(self, scope)), fromEffectContext));\n\n/** @internal */\nconst merge = /*#__PURE__*/dual(2, (self, that) => zipWithPar(self, that, (a, b) => pipe(a, merge$1(b))));\n\n/** @internal */\nconst mergeAll = (...layers) => {\n  let final = layers[0];\n  for (let i = 1; i < layers.length; i++) {\n    final = merge(layers[i])(final);\n  }\n  return final;\n};\n\n/** @internal */\nconst orDie = self => catchAll(self, defect => die(defect));\n\n/** @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => catchAll(self, that));\n\n/** @internal */\nconst passthrough = self => merge(context(), self);\n\n/** @internal */\nconst project = /*#__PURE__*/dual(4, (self, tagA, tagB, f) => map(self, context => make(tagB, f(unsafeGet(context, tagA)))));\n\n/** @internal */\nconst provide = /*#__PURE__*/dual(2, (self, that) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._tag = OP_PROVIDE_TO;\n  provideTo.first = Object.create(proto, {\n    _tag: {\n      value: OP_ZIP_WITH,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: self\n    },\n    zipK: {\n      value: (a, b) => merge$1(a, b)\n    }\n  });\n  provideTo.second = that;\n  return provideTo;\n}));\n\n/** @internal */\nconst provideMerge = /*#__PURE__*/dual(2, (self, that) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = pipe(self, provide(that));\n  zipWith.zipK = (a, b) => merge$1(a, b);\n  return zipWith;\n});\n\n/** @internal */\nconst retry = /*#__PURE__*/dual(2, (self, schedule) => suspend(() => {\n  const stateTag = Tag();\n  return pipe(succeed(stateTag, {\n    state: schedule.initial\n  }), flatMap(env => retryLoop(self, schedule, stateTag, pipe(env, get(stateTag)).state)));\n}));\n\n/** @internal */\nconst retryLoop = (self, schedule, stateTag, state) => {\n  return pipe(self, catchAll(error => pipe(retryUpdate(schedule, stateTag, error, state), flatMap(env => fresh(retryLoop(self, schedule, stateTag, pipe(env, get(stateTag)).state))))));\n};\n\n/** @internal */\nconst retryUpdate = (schedule, stateTag, error, state) => {\n  return fromEffect(stateTag, pipe(currentTimeMillis, flatMap$1(now => pipe(schedule.step(now, error, state), flatMap$1(([state, _, decision]) => isDone(decision) ? fail$2(error) : pipe(sleep(millis(start(decision.intervals) - now)), as({\n    state\n  })))))));\n};\n\n/** @internal */\nconst scoped = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = isTag(a);\n  const tag = tagFirst ? a : b;\n  const effect = tagFirst ? b : a;\n  return scopedContext(map$1(effect, service => make(tag, service)));\n});\n\n/** @internal */\nconst scopedDiscard = effect => {\n  return scopedContext(pipe(effect, as(empty())));\n};\n\n/** @internal */\nconst scopedContext = effect => {\n  const scoped = Object.create(proto);\n  scoped._tag = OP_SCOPED;\n  scoped.effect = effect;\n  return scoped;\n};\n\n/** @internal */\nconst scope = /*#__PURE__*/scopedContext( /*#__PURE__*/map$1( /*#__PURE__*/acquireRelease( /*#__PURE__*/scopeMake(), (scope, exit) => scope.close(exit)), scope => make(Scope, scope)));\n\n/** @internal */\nconst service = tag => {\n  return fromEffect(tag, tag);\n};\n\n/** @internal */\nconst succeed = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = isTag(a);\n  const tag = tagFirst ? a : b;\n  const resource = tagFirst ? b : a;\n  return fromEffectContext(succeed$1(make(tag, resource)));\n});\n\n/** @internal */\nconst succeedContext = context => {\n  return fromEffectContext(succeed$1(context));\n};\n\n/** @internal */\nconst suspend = evaluate => {\n  const suspend = Object.create(proto);\n  suspend._tag = OP_SUSPEND;\n  suspend.evaluate = evaluate;\n  return suspend;\n};\n\n/** @internal */\nconst sync = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = isTag(a);\n  const tag = tagFirst ? a : b;\n  const evaluate = tagFirst ? b : a;\n  return fromEffectContext(sync$1(() => make(tag, evaluate())));\n});\n\n/** @internal */\nconst syncContext = evaluate => {\n  return fromEffectContext(sync$1(evaluate));\n};\n\n/** @internal */\nconst tap = /*#__PURE__*/dual(2, (self, f) => flatMap(self, context => fromEffectContext(as(f(context), context))));\n\n/** @internal */\nconst tapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, e => fromEffectContext(flatMap$1(f(e), () => fail$2(e)))));\n\n/** @internal */\nconst tapErrorCause = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => fromEffectContext(flatMap$1(f(cause), () => failCause$1(cause)))));\n\n/** @internal */\nconst toRuntime = self => {\n  return pipe(scopeWith(scope => pipe(self, buildWithScope(scope))), flatMap$1(context => pipe(runtime(), provideContext(context))));\n};\n\n/** @internal */\nconst use = /*#__PURE__*/dual(2, (that, self) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._tag = OP_PROVIDE_TO;\n  provideTo.first = Object.create(proto, {\n    _tag: {\n      value: OP_ZIP_WITH,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: self\n    },\n    zipK: {\n      value: (a, b) => pipe(a, merge$1(b))\n    }\n  });\n  provideTo.second = that;\n  return provideTo;\n}));\n\n/** @internal */\nconst useMerge = /*#__PURE__*/dual(2, (that, self) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = pipe(self, provide(that));\n  zipWith.zipK = (a, b) => {\n    return pipe(a, merge$1(b));\n  };\n  return zipWith;\n});\n\n/** @internal */\nconst zipWithPar = /*#__PURE__*/dual(3, (self, that, f) => suspend(() => {\n  const zipWithPar = Object.create(proto);\n  zipWithPar._tag = OP_ZIP_WITH_PAR;\n  zipWithPar.first = self;\n  zipWithPar.second = that;\n  zipWithPar.zipK = f;\n  return zipWithPar;\n}));\n\n/** @internal */\nconst unwrapEffect = self => {\n  const tag = Tag();\n  return flatMap(fromEffect(tag, self), context => get(context, tag));\n};\n\n/** @internal */\nconst unwrapScoped = self => {\n  const tag = Tag();\n  return flatMap(scoped(tag, self), context => get(context, tag));\n};\n\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst withSpan = /*#__PURE__*/dual(args => isLayer(args[0]), (self, name, options) => unwrapScoped(map$1(options?.onEnd ? tap$1(makeSpanScoped(name, options), span => addFinalizer(exit => options.onEnd(span, exit))) : makeSpanScoped(name, options), span => withParentSpan(self, span))));\n\n/** @internal */\nconst withParentSpan = /*#__PURE__*/dual(2, (self, span) => fiberRefLocallyWith(self, currentTracerSpan, prepend(span)));\n\n// circular with Effect\n\nconst provideSomeLayer = /*#__PURE__*/dual(2, (self, layer) => acquireUseRelease(scopeMake(), scope => flatMap$1(buildWithScope(layer, scope), context => provideSomeContext(self, context)), (scope, exit) => scopeClose(scope, exit)));\nconst provideSomeRuntime = /*#__PURE__*/dual(2, (self, rt) => {\n  const patchFlags = diff(defaultRuntime.runtimeFlags, rt.runtimeFlags);\n  const inversePatchFlags = diff(rt.runtimeFlags, defaultRuntime.runtimeFlags);\n  const patchRefs = diff$1(defaultRuntime.fiberRefs, rt.fiberRefs);\n  const inversePatchRefs = diff$1(rt.fiberRefs, defaultRuntime.fiberRefs);\n  return acquireUseRelease(flatMap$1(updateRuntimeFlags(patchFlags), () => patchFiberRefs(patchRefs)), () => provideSomeContext(self, rt.context), () => flatMap$1(updateRuntimeFlags(inversePatchFlags), () => patchFiberRefs(inversePatchRefs)));\n});\n\n/** @internal */\nconst effect_provide = /*#__PURE__*/dual(2, (self, source) => isLayer(source) ? provideSomeLayer(self, source) : isContext(source) ? provideSomeContext(self, source) : provideSomeRuntime(self, source));\n\nexport { LayerTypeId, build, buildWithScope, catchAll, catchAllCause, context, die, dieSync, discard, effect_provide, extendScope, fail, failCause, failCauseSync, failSync, fiberRefLocally, fiberRefLocallyScoped, fiberRefLocallyScopedWith, fiberRefLocallyWith, flatMap, flatten, fresh, fromEffect, fromEffectContext, fromEffectDiscard, fromFunction, isFresh, isLayer, launch, locallyEffect, map, mapError, match, matchCause, memoize, merge, mergeAll, orDie, orElse, passthrough, project, provide, provideMerge, retry, scope, scoped, scopedContext, scopedDiscard, service, succeed, succeedContext, suspend, sync, syncContext, tap, tapError, tapErrorCause, toRuntime, unwrapEffect, unwrapScoped, use, useMerge, withParentSpan, withSpan, zipWithPar };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableList\");\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category model\n */\n\nconst MutableListProto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    let done = false;\n    let head = this.head;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (head == null) {\n          done = true;\n          return this.return();\n        }\n        const value = head.value;\n        head = head.next;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableList\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nclass LinkedListNode {\n  removed = false;\n  prev = undefined;\n  next = undefined;\n  constructor(value) {\n    this.value = value;\n  }\n}\n\n/**\n * Creates an empty `MutableList`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = () => {\n  const list = Object.create(MutableListProto);\n  list.head = undefined;\n  list.tail = undefined;\n  list._length = 0;\n  return list;\n};\n\n/**\n * Creates a new `MutableList` from an `Iterable`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = iterable => {\n  const list = empty();\n  for (const element of iterable) {\n    append(list, element);\n  }\n  return list;\n};\n\n/**\n * Creates a new `MutableList` from the specified elements.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = (...elements) => fromIterable(elements);\n\n/**\n * Returns `true` if the list contains zero elements, `false`, otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isEmpty = self => length(self) === 0;\n\n/**\n * Returns the length of the list.\n *\n * @since 2.0.0\n * @category getters\n */\nconst length = self => self._length;\n\n/**\n * Returns the last element of the list, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst tail = self => self.tail === undefined ? undefined : self.tail.value;\n\n/**\n * Returns the first element of the list, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nconst head = self => self.head === undefined ? undefined : self.head.value;\n\n/**\n * Executes the specified function `f` for each element in the list.\n *\n * @since 2.0.0\n * @category traversing\n */\nconst forEach = /*#__PURE__*/dual(2, (self, f) => {\n  let current = self.head;\n  while (current !== undefined) {\n    f(current.value);\n    current = current.next;\n  }\n});\n\n/**\n * Removes all elements from the doubly-linked list.\n *\n * @since 2.0.0\n */\nconst reset = self => {\n  self._length = 0;\n  self.head = undefined;\n  self.tail = undefined;\n  return self;\n};\n\n/**\n * Appends the specified element to the end of the `MutableList`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst append = /*#__PURE__*/dual(2, (self, value) => {\n  const node = new LinkedListNode(value);\n  if (self.head === undefined) {\n    self.head = node;\n  }\n  if (self.tail === undefined) {\n    self.tail = node;\n  } else {\n    self.tail.next = node;\n    node.prev = self.tail;\n    self.tail = node;\n  }\n  self._length += 1;\n  return self;\n});\n\n/**\n * Removes the first value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n */\nconst shift = self => {\n  const head = self.head;\n  if (head !== undefined) {\n    remove(self, head);\n    return head.value;\n  }\n  return undefined;\n};\n\n/**\n * Removes the last value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n */\nconst pop = self => {\n  const tail = self.tail;\n  if (tail !== undefined) {\n    remove(self, tail);\n    return tail.value;\n  }\n  return undefined;\n};\n\n/**\n * Prepends the specified value to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nconst prepend = /*#__PURE__*/dual(2, (self, value) => {\n  const node = new LinkedListNode(value);\n  node.next = self.head;\n  if (self.head !== undefined) {\n    self.head.prev = node;\n  }\n  self.head = node;\n  if (self.tail === undefined) {\n    self.tail = node;\n  }\n  self._length += 1;\n  return self;\n});\nconst remove = (self, node) => {\n  if (node.removed) {\n    return;\n  }\n  node.removed = true;\n  if (node.prev !== undefined && node.next !== undefined) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  } else if (node.prev !== undefined) {\n    self.tail = node.prev;\n    node.prev.next = undefined;\n  } else if (node.next !== undefined) {\n    self.head = node.next;\n    node.next.prev = undefined;\n  } else {\n    self.tail = undefined;\n    self.head = undefined;\n  }\n  if (self._length > 0) {\n    self._length -= 1;\n  }\n};\n\nexport { append, empty, forEach, fromIterable, head, isEmpty, length, make, pop, prepend, reset, shift, tail };\n","import { prepend, reverse, empty as empty$1 } from '../../Chunk/dist/effect-Chunk.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { toString, toJSON, NodeInspectSymbol } from '../../Inspectable/dist/effect-Inspectable.esm.js';\nimport { length as length$1, isEmpty as isEmpty$1, append, shift, empty } from '../../MutableList/dist/effect-MutableList.esm.js';\nimport { pipeArguments } from '../../Pipeable/dist/effect-Pipeable.esm.js';\n\n/**\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableQueue\");\n\n/**\n * @since 2.0.0\n * @category symbol\n */\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nconst EmptyMutableQueue = /*#__PURE__*/Symbol.for(\"effect/mutable/MutableQueue/Empty\");\n\n/**\n * @since 2.0.0\n * @category model\n */\n\n/**\n * @since 2.0.0\n */\n\nconst MutableQueueProto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    return Array.from(this.queue)[Symbol.iterator]();\n  },\n  toString() {\n    return toString(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableQueue\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst make = capacity => {\n  const queue = Object.create(MutableQueueProto);\n  queue.queue = empty();\n  queue.capacity = capacity;\n  return queue;\n};\n\n/**\n * Creates a new bounded `MutableQueue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst bounded = capacity => make(capacity);\n\n/**\n * Creates a new unbounded `MutableQueue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unbounded = () => make(undefined);\n\n/**\n * Returns the current number of elements in the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nconst length = self => length$1(self.queue);\n\n/**\n * Returns `true` if the queue is empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isEmpty = self => isEmpty$1(self.queue);\n\n/**\n * Returns `true` if the queue is full, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isFull = self => self.capacity === undefined ? false : length$1(self.queue) === self.capacity;\n\n/**\n * The **maximum** number of elements that a queue can hold.\n *\n * **Note**: unbounded queues can still implement this interface with\n * `capacity = Infinity`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst capacity = self => self.capacity === undefined ? Infinity : self.capacity;\n\n/**\n * Offers an element to the queue.\n *\n * Returns whether the enqueue was successful or not.\n *\n * @since 2.0.0\n */\nconst offer = /*#__PURE__*/dual(2, (self, value) => {\n  const queueLength = length$1(self.queue);\n  if (self.capacity !== undefined && queueLength === self.capacity) {\n    return false;\n  }\n  append(value)(self.queue);\n  return true;\n});\n\n/**\n * Enqueues a collection of values into the queue.\n *\n * Returns a `Chunk` of the values that were **not** able to be enqueued.\n *\n * @since 2.0.0\n */\nconst offerAll = /*#__PURE__*/dual(2, (self, values) => {\n  const iterator = values[Symbol.iterator]();\n  let next;\n  let remainder = empty$1();\n  let offering = true;\n  while (offering && (next = iterator.next()) && !next.done) {\n    offering = offer(next.value)(self);\n  }\n  while (next != null && !next.done) {\n    remainder = prepend(next.value)(remainder);\n    next = iterator.next();\n  }\n  return reverse(remainder);\n});\n\n/**\n * Dequeues an element from the queue.\n *\n * Returns either an element from the queue, or the `def` param.\n *\n * **Note**: if there is no meaningful default for your type, you can always\n * use `poll(MutableQueue.EmptyMutableQueue)`.\n *\n * @since 2.0.0\n */\nconst poll = /*#__PURE__*/dual(2, (self, def) => {\n  if (isEmpty$1(self.queue)) {\n    return def;\n  }\n  return shift(self.queue);\n});\n\n/**\n * Dequeues up to `n` elements from the queue.\n *\n * Returns a `List` of up to `n` elements.\n *\n * @since 2.0.0\n */\nconst pollUpTo = /*#__PURE__*/dual(2, (self, n) => {\n  let result = empty$1();\n  let count = 0;\n  while (count < n) {\n    const element = poll(EmptyMutableQueue)(self);\n    if (element === EmptyMutableQueue) {\n      break;\n    }\n    result = prepend(element)(result);\n    count += 1;\n  }\n  return reverse(result);\n});\n\nexport { EmptyMutableQueue, bounded, capacity, isEmpty, isFull, length, offer, offerAll, poll, pollUpTo, unbounded };\n","import { getOption } from '../../Context/dist/effect-Context.esm.js';\nimport { identity, dual } from '../../Function/dist/effect-Function.esm.js';\nimport { EffectTypeId as EffectTypeId$1, isEffect as isEffect$1, async as async$1, asyncEither as asyncEither$1, fail as fail$1, failSync as failSync$1, failCause as failCause$1, failCauseSync as failCauseSync$1, die as die$1, dieMessage as dieMessage$1, dieSync as dieSync$1, never as never$1, succeed as succeed$1, suspend as suspend$1, sync as sync$1, unit as unit$1, yieldNow as yieldNow$1, catchAll as catchAll$1, catchAllCause as catchAllCause$1, catchIf as catchIf$1, catchSome as catchSome$1, checkInterruptible as checkInterruptible$1, interrupt as interrupt$1, interruptWith as interruptWith$1, interruptible as interruptible$1, interruptibleMask as interruptibleMask$1, onInterrupt as onInterrupt$1, uninterruptible as uninterruptible$1, uninterruptibleMask as uninterruptibleMask$1, as as as$1, asUnit as asUnit$1, flip as flip$1, map as map$1, mapBoth as mapBoth$1, mapError as mapError$1, acquireUseRelease as acquireUseRelease$1, onError as onError$1, onExit as onExit$1, fiberId as fiberId$1, fiberIdWith as fiberIdWith$1, transplant as transplant$1, withConcurrency as withConcurrency$1, withSchedulingPriority as withSchedulingPriority$1, withMaxOpsBeforeYield as withMaxOpsBeforeYield$1, context as context$1, contextWithEffect as contextWithEffect$1, mapInputContext as mapInputContext$1, either as either$1, exit as exit$1, intoDeferred as intoDeferred$1, if_ as if_$1, whenEffect as whenEffect$1, flatMap as flatMap$1, flatten as flatten$1, tap as tap$1, whileLoop as whileLoop$1, fiberRefLocally, fiberRefLocallyWith, matchCause as matchCause$1, matchCauseEffect as matchCauseEffect$1, matchEffect as matchEffect$1, withUnhandledErrorLogLevel as withUnhandledErrorLogLevel$1, orDie as orDie$1, orDieWith as orDieWith$1, orElse as orElse$1, runtimeFlags, updateRuntimeFlags, withRuntimeFlags, metricLabels as metricLabels$1, unified as unified$1, blocked as blocked$1, runRequestBlock as runRequestBlock$1, step as step$1, flatMapStep as flatMapStep$1, withRequestBatching as withRequestBatching$1, withTracerTiming as withTracerTiming$1 } from '../../internal/core.esm.js';\nimport { memoize, once as once$1, dropUntil as dropUntil$1, dropWhile as dropWhile$1, every as every$1, findFirst as findFirst$1, firstSuccessOf as firstSuccessOf$1, head as head$1, reduce as reduce$1, reduceRight as reduceRight$1, reduceWhile as reduceWhile$1, takeUntil as takeUntil$1, takeWhile as takeWhile$1, asyncOption as asyncOption$1, gen as gen$1, none as none$1, promise as promise$1, succeedNone as succeedNone$1, succeedSome as succeedSome$1, _catch as _catch$1, catchAllDefect as catchAllDefect$1, catchSomeCause as catchSomeCause$1, catchSomeDefect as catchSomeDefect$1, catchTag as catchTag$1, catchTags as catchTags$1, cause as cause$1, eventually as eventually$1, ignore as ignore$1, ignoreLogged as ignoreLogged$1, parallelErrors as parallelErrors$1, sandbox as sandbox$1, try_ as try_$1, tryMap as tryMap$1, tryMapPromise as tryMapPromise$1, tryPromise as tryPromise$1, unsandbox as unsandbox$1, allowInterrupt as allowInterrupt$1, asSome as asSome$1, asSomeError as asSomeError$1, flipWith as flipWith$1, mapAccum as mapAccum$1, mapErrorCause as mapErrorCause$1, merge as merge$1, negate as negate$1, descriptor as descriptor$1, descriptorWith as descriptorWith$1, diffFiberRefs as diffFiberRefs$1, clock as clock$1, clockWith as clockWith$1, delay as delay$1, sleep as sleep$1, timed as timed$1, timedWith as timedWith$1, contextWith as contextWith$1, provideService as provideService$1, provideServiceEffect as provideServiceEffect$1, serviceFunction as serviceFunction$1, serviceFunctionEffect as serviceFunctionEffect$1, serviceFunctions as serviceFunctions$1, serviceConstants as serviceConstants$1, serviceMembers as serviceMembers$1, updateService as updateService$1, Do as Do$1, bind as bind$1, bindTo as bindTo$1, bindValue, option as option$1, filterOrDie as filterOrDie$1, filterOrDieMessage as filterOrDieMessage$1, filterOrElse as filterOrElse$1, filterOrFail as filterOrFail$1, unless as unless$1, unlessEffect as unlessEffect$1, when as when$1, whenFiberRef as whenFiberRef$1, whenRef as whenRef$1, summarized as summarized$1, tapBoth as tapBoth$1, tapDefect as tapDefect$1, tapError as tapError$1, tapErrorTag as tapErrorTag$1, tapErrorCause as tapErrorCause$1, forever as forever$1, iterate as iterate$1, loop as loop$1, repeatN as repeatN$1, fiberRefs, inheritFiberRefs as inheritFiberRefs$1, patchFiberRefs as patchFiberRefs$1, setFiberRefs as setFiberRefs$1, updateFiberRefs as updateFiberRefs$1, isFailure as isFailure$1, isSuccess as isSuccess$1, match as match$1, log as log$1, logTrace as logTrace$1, logDebug as logDebug$1, logInfo as logInfo$1, logWarning as logWarning$1, logError as logError$1, logFatal as logFatal$1, withLogSpan as withLogSpan$1, annotateLogs as annotateLogs$1, logAnnotations as logAnnotations$1, orElseFail as orElseFail$1, orElseSucceed as orElseSucceed$1, random as random$1, tagMetrics as tagMetrics$1, labelMetrics as labelMetrics$1, labelMetricsSet as labelMetricsSet$1, withMetric as withMetric$1, tracer as tracer$1, annotateSpans as annotateSpans$1, annotateCurrentSpan as annotateCurrentSpan$1, currentSpan as currentSpan$1, currentParentSpan as currentParentSpan$1, spanAnnotations as spanAnnotations$1, spanLinks as spanLinks$1, linkSpans as linkSpans$1, makeSpan as makeSpan$1, useSpan as useSpan$1, withSpan as withSpan$1, withParentSpan as withParentSpan$1, fromNullable as fromNullable$1, optionFromOptional as optionFromOptional$1 } from '../../internal/core-effect.esm.js';\nimport { withClock as withClock$1, config as config$1, configProviderWith as configProviderWith$1, withConfigProvider as withConfigProvider$1, randomWith as randomWith$1, tracerWith as tracerWith$1, withTracer as withTracer$1 } from '../../internal/defaultServices.esm.js';\nimport { cached as cached$1, cachedInvalidate, memoizeFunction, awaitAllChildren as awaitAllChildren$1, ensuringChild as ensuringChild$1, ensuringChildren as ensuringChildren$1, forkAll as forkAll$1, forkIn as forkIn$1, forkScoped as forkScoped$1, fromFiber as fromFiber$1, fromFiberEffect as fromFiberEffect$1, supervised as supervised$1, timeout as timeout$1, timeoutFail as timeoutFail$1, timeoutFailCause as timeoutFailCause$1, timeoutTo as timeoutTo$1, raceFirst as raceFirst$1, scheduleForked as scheduleForked$1, unsafeMakeSemaphore as unsafeMakeSemaphore$1, makeSemaphore as makeSemaphore$1 } from '../../internal/effect/circular.esm.js';\nimport { all as all$1, allWith as allWith$1, allSuccesses as allSuccesses$1, exists as exists$1, filter as filter$1, forEachOptions, mergeAll as mergeAll$1, partition as partition$1, reduceEffect as reduceEffect$1, replicate as replicate$1, replicateEffect as replicateEffect$1, validateAll as validateAll$1, validateFirst as validateFirst$1, disconnect as disconnect$1, acquireRelease as acquireRelease$1, acquireReleaseInterruptible as acquireReleaseInterruptible$1, addFinalizer as addFinalizer$1, ensuring as ensuring$1, parallelFinalizers as parallelFinalizers$1, finalizersMask as finalizersMask$1, sequentialFinalizers as sequentialFinalizers$1, scope as scope$1, scopeWith as scopeWith$1, scopedEffect, using as using$1, withEarlyRelease as withEarlyRelease$1, daemonChildren as daemonChildren$1, fork as fork$1, forkDaemon as forkDaemon$1, forkWithErrorHandler as forkWithErrorHandler$1, withClockScoped as withClockScoped$1, withConfigProviderScoped as withConfigProviderScoped$1, raceAll as raceAll$1, race as race$1, raceWith as raceWith$1, fiberRefLocallyScoped, fiberRefLocallyScopedWith, withRuntimeFlagsScoped, tagMetricsScoped as tagMetricsScoped$1, labelMetricsScoped as labelMetricsScoped$1, labelMetricsScopedSet as labelMetricsScopedSet$1, validate as validate$1, validateWith as validateWith$1, zipOptions, zipLeftOptions, zipRightOptions, zipWithOptions, withTracerScoped as withTracerScoped$1, makeSpanScoped as makeSpanScoped$1, withSpanScoped as withSpanScoped$1, setSpan as setSpan$1, setParentSpan as setParentSpan$1 } from '../../internal/fiberRuntime.esm.js';\nimport { effect_provide } from '../../internal/layer.esm.js';\nimport { fromRequest, cacheRequest, withRequestCaching as withRequestCaching$1, withRequestCache as withRequestCache$1 } from '../../internal/query.esm.js';\nimport { asyncEffect as asyncEffect$1, runtime as runtime$1, unsafeForkEffect, unsafeRunEffect, unsafeRunPromiseEffect, unsafeRunPromiseExitEffect, unsafeRunSyncEffect, unsafeRunSyncExitEffect } from '../../internal/runtime.esm.js';\nimport { retry_Effect, retryN_Effect, retryOrElse_Effect, retryUntil_Effect, retryUntilEffect_Effect, retryWhile_Effect, retryWhileEffect_Effect, repeat_Effect, repeatOrElse_Effect, repeatUntil_Effect, repeatUntilEffect_Effect, repeatWhile_Effect, repeatWhileEffect_Effect, schedule_Effect, scheduleFrom_Effect } from '../../internal/schedule.esm.js';\nimport { withScheduler as withScheduler$1 } from '../../Scheduler/dist/effect-Scheduler.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n// -------------------------------------------------------------------------------------\n// models\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst EffectTypeId = EffectTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * The `Effect` interface defines a value that lazily describes a workflow or job.\n * The workflow requires some context `R`, and may fail with an error of type `E`,\n * or succeed with a value of type `A`.\n *\n * `Effect` values model resourceful interaction with the outside world, including\n * synchronous, asynchronous, concurrent, and parallel interaction. They use a\n * fiber-based concurrency model, with built-in support for scheduling, fine-grained\n * interruption, structured concurrency, and high scalability.\n *\n * To run an `Effect` value, you need a `Runtime`, which is a type that is capable\n * of executing `Effect` values.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * This function returns `true` if the specified value is an `Effect` value,\n * `false` otherwise.\n *\n * This function can be useful for checking the type of a value before\n * attempting to operate on it as an `Effect` value. For example, you could\n * use `isEffect` to check the type of a value before using it as an\n * argument to a function that expects an `Effect` value.\n *\n * @param u - The value to check for being an `Effect` value.\n *\n * @returns `true` if the specified value is an `Effect` value, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isEffect = isEffect$1;\n\n// -------------------------------------------------------------------------------------\n// caching\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns an effect that, if evaluated, will return the cached result of this\n * effect. Cached results will expire after `timeToLive` duration.\n *\n * @since 2.0.0\n * @category caching\n */\nconst cachedWithTTL = cached$1;\n\n/**\n * Returns an effect that, if evaluated, will return the cached result of this\n * effect. Cached results will expire after `timeToLive` duration. In\n * addition, returns an effect that can be used to invalidate the current\n * cached value before the `timeToLive` duration expires.\n *\n * @since 2.0.0\n * @category caching\n */\nconst cachedInvalidateWithTTL = cachedInvalidate;\n\n/**\n * Returns an effect that, if evaluated, will return the lazily computed\n * result of this effect.\n *\n * @since 2.0.0\n * @category caching\n */\nconst cached = memoize;\n\n/**\n * Returns a memoized version of the specified effectual function.\n *\n * @since 2.0.0\n * @category caching\n */\nconst cachedFunction = memoizeFunction;\n\n/**\n * Returns an effect that will be executed at most once, even if it is\n * evaluated multiple times.\n *\n * @since 2.0.0\n * @category caching\n */\nconst once = once$1;\n\n// -------------------------------------------------------------------------------------\n// collecting & elements\n// -------------------------------------------------------------------------------------\n\n/**\n * Runs all the provided effects in sequence respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst all = all$1;\n\n/**\n * Data-last variant of `Effect.all`.\n *\n * Runs all the provided effects in sequence respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst allWith = allWith$1;\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Evaluate and run each effect in the structure and collect the results,\n * discarding results from failed effects.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst allSuccesses = allSuccesses$1;\n\n/**\n * Drops all elements until the effectful predicate returns true.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst dropUntil = dropUntil$1;\n\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst dropWhile = dropWhile$1;\n\n/**\n * Determines whether all elements of the `Collection<A>` satisfies the effectual\n * predicate `f`.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst every = every$1;\n\n/**\n * Determines whether any element of the `Iterable<A>` satisfies the effectual\n * predicate `f`.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst exists = exists$1;\n\n/**\n * Filters the collection using the specified effectful predicate.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst filter = filter$1;\n\n/**\n * Returns the first element that satisfies the effectful predicate.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst findFirst = findFirst$1;\n\n/**\n * This function takes an iterable of `Effect` values and returns a new\n * `Effect` value that represents the first `Effect` value in the iterable\n * that succeeds. If all of the `Effect` values in the iterable fail, then\n * the resulting `Effect` value will fail as well.\n *\n * This function is sequential, meaning that the `Effect` values in the\n * iterable will be executed in sequence, and the first one that succeeds\n * will determine the outcome of the resulting `Effect` value.\n *\n * @param effects - The iterable of `Effect` values to evaluate.\n *\n * @returns A new `Effect` value that represents the first successful\n * `Effect` value in the iterable, or a failed `Effect` value if all of the\n * `Effect` values in the iterable fail.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst firstSuccessOf = firstSuccessOf$1;\n\n/**\n * @since 2.0.0\n * @category collecting & elements\n */\nconst forEach = forEachOptions;\n\n/**\n * Returns a successful effect with the head of the collection if the collection\n * is non-empty, or fails with the error `None` if the collection is empty.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst head = head$1;\n\n/**\n * Merges an `Iterable<Effect<R, E, A>>` to a single effect, working\n * sequentially.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst mergeAll = mergeAll$1;\n\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in a tupled fashion.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst partition = partition$1;\n\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from left to right.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst reduce = reduce$1;\n\n/**\n * Reduces an `Iterable<Effect<R, E, A>>` to a single effect.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst reduceEffect = reduceEffect$1;\n\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially from left to right.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst reduceRight = reduceRight$1;\n\n/**\n * Folds over the elements in this chunk from the left, stopping the fold early\n * when the predicate is not satisfied.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst reduceWhile = reduceWhile$1;\n\n/**\n * Replicates the given effect `n` times.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst replicate = replicate$1;\n\n/**\n * Performs this effect the specified number of times and collects the\n * results.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst replicateEffect = replicateEffect$1;\n\n/**\n * Takes elements until the effectual predicate returns true.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst takeUntil = takeUntil$1;\n\n/**\n * Takes all elements so long as the effectual predicate returns true.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst takeWhile = takeWhile$1;\n\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors in error\n * channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use `partition`.\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst validateAll = validateAll$1;\n\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * If `elements` is empty then `Effect.fail([])` is returned.\n *\n * @example\n * import * as Effect from \"effect/Effect\"\n * import * as Exit from \"effect/Exit\"\n *\n * const f = (n: number) => (n > 0 ? Effect.succeed(n) : Effect.fail(`${n} is negative`))\n *\n * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([], f)), Exit.fail([]))\n * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([1, 2], f)), Exit.succeed(1))\n * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([1, -1], f)), Exit.succeed(1))\n * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([-1, 2], f)), Exit.succeed(2))\n * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([-1, -2], f)), Exit.fail(['-1 is negative', '-2 is negative']))\n *\n * @since 2.0.0\n * @category collecting & elements\n */\nconst validateFirst = validateFirst$1;\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Imports an asynchronous side-effect into a pure `Effect` value.\n * The callback function `Effect<R, E, A> => void` must be called at most once.\n *\n * If an Effect is returned by the registration function, it will be executed\n * if the fiber executing the effect is interrupted.\n *\n * The registration function can also receive an `AbortSignal` if required for\n * interruption.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst async = async$1;\n\n/**\n * Converts an asynchronous, callback-style API into an `Effect`, which will\n * be executed asynchronously.\n *\n * With this variant, the registration function may return a an `Effect`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncEffect = asyncEffect$1;\n\n/**\n * Imports an asynchronous effect into a pure `Effect` value, possibly returning\n * the value synchronously.\n *\n * If the register function returns a value synchronously, then the callback\n * function `Effect<R, E, A> => void` must not be called. Otherwise the callback\n * function must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncOption = asyncOption$1;\n\n/**\n * Imports an asynchronous side-effect into an effect. It has the option of\n * returning the value synchronously, which is useful in cases where it cannot\n * be determined if the effect is synchronous or asynchronous until the register\n * is actually executed. It also has the option of returning a canceler,\n * which will be used by the runtime to cancel the asynchronous effect if the fiber\n * executing the effect is interrupted.\n *\n * If the register function returns a value synchronously, then the callback\n * function `Effect<R, E, A> => void` must not be called. Otherwise the callback\n * function must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncEither = asyncEither$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst fail = fail$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst failSync = failSync$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst failCause = failCause$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst failCauseSync = failCauseSync$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst die = die$1;\n\n/**\n * Returns an effect that dies with a `RuntimeException` having the specified\n * text message. This method can be used for terminating a fiber because a\n * defect has been detected in the code.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst dieMessage = dieMessage$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst dieSync = dieSync$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst gen = gen$1;\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * Returns a effect that will never produce anything. The moral equivalent of\n * `while(true) {}`, only without the wasted CPU cycles.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst never = never$1;\n\n/**\n * Requires the option produced by this value to be `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst none = none$1;\n\n/**\n * Like `tryPromise` but produces a defect in case of errors.\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped Promise api.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst promise = promise$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst succeed = succeed$1;\n\n/**\n * Returns an effect which succeeds with `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeedNone = succeedNone$1;\n\n/**\n * Returns an effect which succeeds with the value wrapped in a `Some`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeedSome = succeedSome$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst suspend = suspend$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst sync = sync$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst unit = unit$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst yieldNow = yieldNow$1;\n\n// -------------------------------------------------------------------------------------\n// error handling\n// -------------------------------------------------------------------------------------\n\nconst _catch = _catch$1;\n\n/**\n * Recovers from all recoverable errors.\n *\n * **Note**: that `Effect.catchAll` will not recover from unrecoverable defects. To\n * recover from both recoverable and unrecoverable errors use\n * `Effect.catchAllCause`.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAll = catchAll$1;\n\n/**\n * Recovers from both recoverable and unrecoverable errors.\n *\n * See `absorb`, `sandbox`, `mapErrorCause` for other functions that can\n * recover from defects.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAllCause = catchAllCause$1;\n\n/**\n * Recovers from all defects with provided function.\n *\n * **WARNING**: There is no sensible way to recover from defects. This\n * method should be used only at the boundary between Effect and an external\n * system, to transmit information on a defect for diagnostic or explanatory\n * purposes.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAllDefect = catchAllDefect$1;\n\n/**\n * Recovers from errors that match the given predicate.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchIf = catchIf$1;\n\n/**\n * Recovers from some or all of the error cases.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchSome = catchSome$1;\n\n/**\n * Recovers from some or all of the error cases with provided cause.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchSomeCause = catchSomeCause$1;\n\n/**\n * Recovers from some or all of the defects with provided partial function.\n *\n * **WARNING**: There is no sensible way to recover from defects. This\n * method should be used only at the boundary between Effect and an external\n * system, to transmit information on a defect for diagnostic or explanatory\n * purposes.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchSomeDefect = catchSomeDefect$1;\n\n/**\n * Recovers from the specified tagged error.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchTag = catchTag$1;\n\n/**\n * Recovers from the specified tagged errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchTags = catchTags$1;\n\n/**\n * Returns an effect that succeeds with the cause of failure of this effect,\n * or `Cause.empty` if the effect did succeed.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst cause = cause$1;\n\n/**\n * Returns an effect that ignores errors and runs repeatedly until it\n * eventually succeeds.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst eventually = eventually$1;\n\n/**\n * Returns a new effect that ignores the success or failure of this effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst ignore = ignore$1;\n\n/**\n * Returns a new effect that ignores the success or failure of this effect,\n * but which also logs failures at the Debug level, just in case the failure\n * turns out to be important.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst ignoreLogged = ignoreLogged$1;\n\n/**\n * Exposes all parallel errors in a single call.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst parallelErrors = parallelErrors$1;\n\n/**\n * Exposes the full `Cause` of failure for the specified effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst sandbox = sandbox$1;\n\n/**\n * Retries with the specified retry policy. Retries are done following the\n * failure of the original `io` (up to a fixed maximum with `once` or `recurs`\n * for example), so that that `io.retry(Schedule.once)` means \"execute `io`\n * and in case of failure, try again once\".\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retry = retry_Effect;\n\n/**\n * Retries this effect the specified number of times.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retryN = retryN_Effect;\n\n/**\n * Retries with the specified schedule, until it fails, and then both the\n * value produced by the schedule together with the last error are passed to\n * the recovery function.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retryOrElse = retryOrElse_Effect;\n\n/**\n * Retries this effect until its error satisfies the specified predicate.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retryUntil = retryUntil_Effect;\n\n/**\n * Retries this effect until its error satisfies the specified effectful\n * predicate.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retryUntilEffect = retryUntilEffect_Effect;\n\n/**\n * Retries this effect while its error satisfies the specified predicate.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retryWhile = retryWhile_Effect;\n\n/**\n * Retries this effect while its error satisfies the specified effectful\n * predicate.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst retryWhileEffect = retryWhileEffect_Effect;\nconst try_ = try_$1;\n\n/**\n * Returns an effect whose success is mapped by the specified side effecting\n * `try` function, translating any promise rejections into typed failed effects\n * via the `catch` function.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst tryMap = tryMap$1;\n\n/**\n * Returns an effect whose success is mapped by the specified side effecting\n * `try` function, translating any promise rejections into typed failed effects\n * via the `catch` function.\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped Promise api.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst tryMapPromise = tryMapPromise$1;\n\n/**\n * Create an `Effect` that when executed will construct `promise` and wait for\n * its result, errors will produce failure as `unknown`.\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped Promise api.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst tryPromise = tryPromise$1;\n\n/**\n * The inverse operation `sandbox(effect)`\n *\n * Terminates with exceptions on the `Left` side of the `Either` error, if it\n * exists. Otherwise extracts the contained `Effect<R, E, A>`\n *\n * @since 2.0.0\n * @category error handling\n */\nconst unsandbox = unsandbox$1;\n\n// -------------------------------------------------------------------------------------\n// interuption\n// -------------------------------------------------------------------------------------\n\n/**\n * This function checks if any fibers are attempting to interrupt the current\n * fiber, and if so, performs self-interruption.\n *\n * Note that this allows for interruption to occur in uninterruptible regions.\n *\n * @returns A new `Effect` value that represents the check for interruption\n * and the potential self-interruption of the current fiber.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst allowInterrupt = allowInterrupt$1;\n\n/**\n * Checks the interrupt status, and produces the effect returned by the\n * specified callback.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst checkInterruptible = checkInterruptible$1;\n\n/**\n * Returns an effect whose interruption will be disconnected from the\n * fiber's own interruption, being performed in the background without\n * slowing down the fiber's interruption.\n *\n * This method is useful to create \"fast interrupting\" effects. For\n * example, if you call this on a bracketed effect, then even if the\n * effect is \"stuck\" in acquire or release, its interruption will return\n * immediately, while the acquire / release are performed in the\n * background.\n *\n * See timeout and race for other applications.\n *\n * @since 2.0.0\n * @category interruption\n */\nconst disconnect = disconnect$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst interrupt = interrupt$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst interruptWith = interruptWith$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst interruptible = interruptible$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst interruptibleMask = interruptibleMask$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst onInterrupt = onInterrupt$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst uninterruptible = uninterruptible$1;\n\n/**\n * @since 2.0.0\n * @category interruption\n */\nconst uninterruptibleMask = uninterruptibleMask$1;\n\n// -------------------------------------------------------------------------------------\n// mapping\n// -------------------------------------------------------------------------------------\n\n/**\n * This function maps the success value of an `Effect` value to a specified\n * constant value.\n *\n * @param value - The constant value that the success value of the `Effect`\n * value will be mapped to.\n * @param self - The `Effect` value whose success value will be mapped to the\n * specified constant value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to the specified constant value.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst as = as$1;\n\n/**\n * This function maps the success value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value fails, the returned\n * `Effect` value will also fail.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Some` value in an `Option` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Some` value in an `Option`\n * value. The returned `Effect` value may fail if the original `Effect` value\n * fails.\n *\n * @category mapping\n * @since 2.0.0\n */\nconst asSome = asSome$1;\n\n/**\n * This function maps the error value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value succeeds, the returned\n * `Effect` value will also succeed.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Some` value in an `Option` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Some` value in an `Option`\n * value. The returned `Effect` value may succeed if the original `Effect`\n * value succeeds.\n *\n * @category mapping\n * @since 2.0.0\n */\nconst asSomeError = asSomeError$1;\n\n/**\n * This function maps the success value of an `Effect` value to `void`. If the\n * original `Effect` value succeeds, the returned `Effect` value will also\n * succeed. If the original `Effect` value fails, the returned `Effect` value\n * will fail with the same error.\n *\n * @param self - The `Effect` value whose success value will be mapped to `void`.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to `void`.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst asUnit = asUnit$1;\n\n/**\n * Returns an effect that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst flip = flip$1;\n\n/**\n * Swaps the error/value parameters, applies the function `f` and flips the\n * parameters back\n *\n * @since 2.0.0\n * @category mapping\n */\nconst flipWith = flipWith$1;\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * Statefully and effectfully maps over the elements of this chunk to produce\n * new elements.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapAccum = mapAccum$1;\n\n/**\n * Returns an effect whose failure and success channels have been mapped by\n * the specified `onFailure` and `onSuccess` functions.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapBoth = mapBoth$1;\n\n/**\n * Returns an effect with its error channel mapped using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapError = mapError$1;\n\n/**\n * Returns an effect with its full cause of failure mapped using the specified\n * function. This can be used to transform errors while preserving the\n * original structure of `Cause`.\n *\n * See `absorb`, `sandbox`, `catchAllCause` for other functions for dealing\n * with defects.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapErrorCause = mapErrorCause$1;\n\n/**\n * Returns a new effect where the error channel has been merged into the\n * success channel to their common combined type.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst merge = merge$1;\n\n/**\n * Returns a new effect where boolean value of this effect is negated.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst negate = negate$1;\n\n// -------------------------------------------------------------------------------------\n// scoping, resources & finalization\n// -------------------------------------------------------------------------------------\n\n/**\n * This function constructs a scoped resource from an `acquire` and `release`\n * `Effect` value.\n *\n * If the `acquire` `Effect` value successfully completes execution, then the\n * `release` `Effect` value will be added to the finalizers associated with the\n * scope of this `Effect` value, and it is guaranteed to be run when the scope\n * is closed.\n *\n * The `acquire` and `release` `Effect` values will be run uninterruptibly.\n * Additionally, the `release` `Effect` value may depend on the `Exit` value\n * specified when the scope is closed.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the scoped resource.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst acquireRelease = acquireRelease$1;\n\n/**\n * This function constructs a scoped resource from an `acquire` and `release`\n * `Effect` value.\n *\n * If the `acquire` `Effect` value successfully completes execution, then the\n * `release` `Effect` value will be added to the finalizers associated with the\n * scope of this `Effect` value, and it is guaranteed to be run when the scope\n * is closed.\n *\n * The `acquire` `Effect` values will be run interruptibly.\n * The `release` `Effect` values will be run uninterruptibly.\n *\n * Additionally, the `release` `Effect` value may depend on the `Exit` value\n * specified when the scope is closed.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the scoped resource.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst acquireReleaseInterruptible = acquireReleaseInterruptible$1;\n\n/**\n * This function is used to ensure that an `Effect` value that represents the\n * acquisition of a resource (for example, opening a file, launching a thread,\n * etc.) will not be interrupted, and that the resource will always be released\n * when the `Effect` value completes execution.\n *\n * `acquireUseRelease` does the following:\n *\n *   1. Ensures that the `Effect` value that acquires the resource will not be\n *      interrupted. Note that acquisition may still fail due to internal\n *      reasons (such as an uncaught exception).\n *   2. Ensures that the `release` `Effect` value will not be interrupted,\n *      and will be executed as long as the acquisition `Effect` value\n *      successfully acquires the resource.\n *\n * During the time period between the acquisition and release of the resource,\n * the `use` `Effect` value will be executed.\n *\n * If the `release` `Effect` value fails, then the entire `Effect` value will\n * fail, even if the `use` `Effect` value succeeds. If this fail-fast behavior\n * is not desired, errors produced by the `release` `Effect` value can be caught\n * and ignored.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param use - The `Effect` value that is executed between the acquisition\n * and release of the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the acquisition, use, and\n * release of the resource.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst acquireUseRelease = acquireUseRelease$1;\n\n/**\n * This function adds a finalizer to the scope of the calling `Effect` value.\n * The finalizer is guaranteed to be run when the scope is closed, and it may\n * depend on the `Exit` value that the scope is closed with.\n *\n * @param finalizer - The finalizer to add to the scope of the calling\n * `Effect` value. This function must take an `Exit` value as its parameter,\n * and return a new `Effect` value.\n *\n * @returns A new `Effect` value that represents the addition of the finalizer\n * to the scope of the calling `Effect` value.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst addFinalizer = addFinalizer$1;\n\n/**\n * Returns an effect that, if this effect _starts_ execution, then the\n * specified `finalizer` is guaranteed to be executed, whether this effect\n * succeeds, fails, or is interrupted.\n *\n * For use cases that need access to the effect's result, see `onExit`.\n *\n * Finalizers offer very powerful guarantees, but they are low-level, and\n * should generally not be used for releasing resources. For higher-level\n * logic built on `ensuring`, see the `acquireRelease` family of methods.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst ensuring = ensuring$1;\n\n/**\n * Runs the specified effect if this effect fails, providing the error to the\n * effect if it exists. The provided effect will not be interrupted.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst onError = onError$1;\n\n/**\n * Ensures that a cleanup functions runs, whether this effect succeeds, fails,\n * or is interrupted.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst onExit = onExit$1;\n\n/**\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst parallelFinalizers = parallelFinalizers$1;\n\n/**\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst finalizersMask = finalizersMask$1;\n\n/**\n * Returns a new scoped workflow that runs finalizers added to the scope of\n * this workflow sequentially in the reverse of the order in which they were\n * added. Note that finalizers are run sequentially by default so this only\n * has meaning if used within a scope where finalizers are being run in\n * parallel.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst sequentialFinalizers = sequentialFinalizers$1;\n\n/**\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst scope = scope$1;\n\n/**\n * Accesses the current scope and uses it to perform the specified effect.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst scopeWith = scopeWith$1;\n\n/**\n * Scopes all resources uses in this workflow to the lifetime of the workflow,\n * ensuring that their finalizers are run as soon as this workflow completes\n * execution, whether by success, failure, or interruption.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst scoped = scopedEffect;\n\n/**\n * Scopes all resources acquired by `resource` to the lifetime of `use`\n * without effecting the scope of any resources acquired by `use`.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst using = using$1;\n\n/**\n * Returns a new scoped workflow that returns the result of this workflow as\n * well as a finalizer that can be run to close the scope of this workflow.\n *\n * @since 2.0.0\n * @category scoping, resources & finalization\n */\nconst withEarlyRelease = withEarlyRelease$1;\n\n// -------------------------------------------------------------------------------------\n// supervision & fibers\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a new effect that will not succeed with its value before first\n * waiting for the end of all child fibers forked by the effect.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst awaitAllChildren = awaitAllChildren$1;\n\n/**\n * Returns a new workflow that will not supervise any fibers forked by this\n * workflow.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst daemonChildren = daemonChildren$1;\n\n/**\n * Constructs an effect with information about the current `Fiber`.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst descriptor = descriptor$1;\n\n/**\n * Constructs an effect based on information about the current `Fiber`.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst descriptorWith = descriptorWith$1;\n\n/**\n * Returns a new workflow that executes this one and captures the changes in\n * `FiberRef` values.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst diffFiberRefs = diffFiberRefs$1;\n\n/**\n * Acts on the children of this fiber (collected into a single fiber),\n * guaranteeing the specified callback will be invoked, whether or not this\n * effect succeeds.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst ensuringChild = ensuringChild$1;\n\n/**\n * Acts on the children of this fiber, guaranteeing the specified callback\n * will be invoked, whether or not this effect succeeds.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst ensuringChildren = ensuringChildren$1;\n\n/**\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst fiberId = fiberId$1;\n\n/**\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst fiberIdWith = fiberIdWith$1;\n\n/**\n * Returns an effect that forks this effect into its own separate fiber,\n * returning the fiber immediately, without waiting for it to begin executing\n * the effect.\n *\n * You can use the `fork` method whenever you want to execute an effect in a\n * new fiber, concurrently and without \"blocking\" the fiber executing other\n * effects. Using fibers can be tricky, so instead of using this method\n * directly, consider other higher-level methods, such as `raceWith`,\n * `zipPar`, and so forth.\n *\n * The fiber returned by this method has methods to interrupt the fiber and to\n * wait for it to finish executing the effect. See `Fiber` for more\n * information.\n *\n * Whenever you use this method to launch a new fiber, the new fiber is\n * attached to the parent fiber's scope. This means when the parent fiber\n * terminates, the child fiber will be terminated as well, ensuring that no\n * fibers leak. This behavior is called \"auto supervision\", and if this\n * behavior is not desired, you may use the `forkDaemon` or `forkIn` methods.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst fork = fork$1;\n\n/**\n * Forks the effect into a new fiber attached to the global scope. Because the\n * new fiber is attached to the global scope, when the fiber executing the\n * returned effect terminates, the forked fiber will continue running.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst forkDaemon = forkDaemon$1;\n\n/**\n * Returns an effect that forks all of the specified values, and returns a\n * composite fiber that produces a list of their results, in order.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst forkAll = forkAll$1;\n\n/**\n * Forks the effect in the specified scope. The fiber will be interrupted\n * when the scope is closed.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst forkIn = forkIn$1;\n\n/**\n * Forks the fiber in a `Scope`, interrupting it when the scope is closed.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst forkScoped = forkScoped$1;\n\n/**\n * Like fork but handles an error with the provided handler.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst forkWithErrorHandler = forkWithErrorHandler$1;\n\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst fromFiber = fromFiber$1;\n\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst fromFiberEffect = fromFiberEffect$1;\n\n/**\n * Returns an effect with the behavior of this one, but where all child fibers\n * forked in the effect are reported to the specified supervisor.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst supervised = supervised$1;\n\n/**\n * Transplants specified effects so that when those effects fork other\n * effects, the forked effects will be governed by the scope of the fiber that\n * executes this effect.\n *\n * This can be used to \"graft\" deep grandchildren onto a higher-level scope,\n * effectively extending their lifespans into the parent scope.\n *\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst transplant = transplant$1;\n\n/**\n * @since 2.0.0\n * @category supervision & fibers\n */\nconst withConcurrency = withConcurrency$1;\n\n// ---------------------------------------------------------------------------------------\n// scheduler\n// ---------------------------------------------------------------------------------------\n\n/**\n * Sets the provided scheduler for usage in the wrapped effect\n *\n * @since 2.0.0\n * @category scheduler\n */\nconst withScheduler = withScheduler$1;\n\n/**\n * Sets the scheduling priority used when yielding\n *\n * @since 2.0.0\n * @category utils\n */\nconst withSchedulingPriority = withSchedulingPriority$1;\n\n/**\n * Sets the maximum number of operations before yield by the default schedulers\n *\n * @since 2.0.0\n * @category utils\n */\nconst withMaxOpsBeforeYield = withMaxOpsBeforeYield$1;\n\n// ---------------------------------------------------------------------------------------\n// clock\n// ---------------------------------------------------------------------------------------\n\n/**\n * Retreives the `Clock` service from the context\n *\n * @since 2.0.0\n * @category clock\n */\nconst clock = clock$1;\n\n/**\n * Retreives the `Clock` service from the context and provides it to the\n * specified effectful function.\n *\n * @since 2.0.0\n * @category clock\n */\nconst clockWith = clockWith$1;\n\n/**\n * Sets the implementation of the clock service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst withClockScoped = withClockScoped$1;\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * clock service.\n *\n * @since 2.0.0\n * @category clock\n */\nconst withClock = withClock$1;\n\n// ---------------------------------------------------------------------------------------\n// delays & timeouts\n// ---------------------------------------------------------------------------------------\n\n/**\n * Returns an effect that is delayed from this effect by the specified\n * `Duration`.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst delay = delay$1;\n\n/**\n * Returns an effect that suspends for the specified duration. This method is\n * asynchronous, and does not actually block the fiber executing the effect.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst sleep = sleep$1;\n\n/**\n * Returns a new effect that executes this one and times the execution.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst timed = timed$1;\n\n/**\n * A more powerful variation of `timed` that allows specifying the clock.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst timedWith = timedWith$1;\n\n/**\n * Returns an effect that will timeout this effect, returning `None` if the\n * timeout elapses before the effect has produced a value; and returning\n * `Some` of the produced value otherwise.\n *\n * If the timeout elapses without producing a value, the running effect will\n * be safely interrupted.\n *\n * WARNING: The effect returned by this method will not itself return until\n * the underlying effect is actually interrupted. This leads to more\n * predictable resource utilization. If early return is desired, then instead\n * of using `effect.timeout(d)`, use `effect.disconnect.timeout(d)`, which\n * first disconnects the effect's interruption signal before performing the\n * timeout, resulting in earliest possible return, before an underlying effect\n * has been successfully interrupted.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst timeout = timeout$1;\n\n/**\n * The same as `timeout`, but instead of producing a `None` in the event of\n * timeout, it will produce the specified error.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst timeoutFail = timeoutFail$1;\n\n/**\n * The same as `timeout`, but instead of producing a `None` in the event of\n * timeout, it will produce the specified failure.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst timeoutFailCause = timeoutFailCause$1;\n\n/**\n * Returns an effect that will timeout this effect, returning either the\n * default value if the timeout elapses before the effect has produced a\n * value or returning the result of applying the function `onSuccess` to the\n * success value of the effect.\n *\n * If the timeout elapses without producing a value, the running effect will\n * be safely interrupted.\n *\n * @since 2.0.0\n * @category delays & timeouts\n */\nconst timeoutTo = timeoutTo$1;\n\n// -------------------------------------------------------------------------------------\n// config\n// -------------------------------------------------------------------------------------\n\n/**\n * Uses the default config provider to load the specified config, or fail with\n * an error of type Config.Error.\n *\n * @since 2.0.0\n * @category config\n */\nconst config = config$1;\n\n/**\n * Retrieves the default config provider, and passes it to the specified\n * function, which may return an effect that uses the provider to perform some\n * work or compute some value.\n *\n * @since 2.0.0\n * @category config\n */\nconst configProviderWith = configProviderWith$1;\n\n/**\n * Executes the specified workflow with the specified configuration provider.\n *\n * @since 2.0.0\n * @category config\n */\nconst withConfigProvider = withConfigProvider$1;\n\n/**\n * Sets the configuration provider to the specified value and restores it to its original value\n * when the scope is closed.\n *\n * @since 2.0.0\n * @category config\n */\nconst withConfigProviderScoped = withConfigProviderScoped$1;\n\n// -------------------------------------------------------------------------------------\n// context\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst context = context$1;\n\n/**\n * Accesses the context of the effect.\n *\n * @since 2.0.0\n * @category context\n */\nconst contextWith = contextWith$1;\n\n/**\n * Effectually accesses the context of the effect.\n *\n * @since 2.0.0\n * @category context\n */\nconst contextWithEffect = contextWithEffect$1;\n\n/**\n * Provides some of the context required to run this effect,\n * leaving the remainder `R0`.\n *\n * @since 2.0.0\n * @category context\n */\nconst mapInputContext = mapInputContext$1;\n\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer/context/runtime and leaving the remainder `R0`\n *\n * @since 2.0.0\n * @category context\n */\nconst provide = effect_provide;\n\n/**\n * Provides the effect with the single service it requires. If the effect\n * requires more than one service use `provideContext` instead.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideService = provideService$1;\n\n/**\n * Provides the effect with the single service it requires. If the effect\n * requires more than one service use `provideContext` instead.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideServiceEffect = provideServiceEffect$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst serviceFunction = serviceFunction$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst serviceFunctionEffect = serviceFunctionEffect$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst serviceFunctions = serviceFunctions$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst serviceConstants = serviceConstants$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst serviceMembers = serviceMembers$1;\n\n/**\n * @since 2.0.0\n * @category context\n */\nconst serviceOption = tag => contextWith(_ => getOption(_, tag));\n\n/**\n * Updates the service with the required service entry.\n *\n * @since 2.0.0\n * @category context\n */\nconst updateService = updateService$1;\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.0.0\n * @category do notation\n */\nconst Do = Do$1;\n\n/**\n * Binds an effectful value in a `do` scope\n *\n * @since 2.0.0\n * @category do notation\n */\nconst bind = bind$1;\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nconst bindTo = bindTo$1;\nconst let_ = bindValue;\n\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns an effect whose failure and success have been lifted into an\n * `Either`. The resulting effect cannot fail, because the failure case has\n * been exposed as part of the `Either` success case.\n *\n * This method is useful for recovering from effects that may fail.\n *\n * The error parameter of the returned `Effect` is `never`, since it is\n * guaranteed the effect does not model failure.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst either = either$1;\n\n/**\n * @since 2.0.0\n * @category conversions\n */\nconst exit = exit$1;\n\n/**\n * @since 2.0.0\n * @category conversions\n */\nconst intoDeferred = intoDeferred$1;\n\n/**\n * Executes this effect, skipping the error but returning optionally the\n * success.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst option = option$1;\n\n// -------------------------------------------------------------------------------------\n// filtering & conditionals\n// -------------------------------------------------------------------------------------\n\nconst if_ = if_$1;\n\n/**\n * Filter the specified effect with the provided function, dying with specified\n * defect if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst filterOrDie = filterOrDie$1;\n\n/**\n * Filter the specified effect with the provided function, dying with specified\n * message if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst filterOrDieMessage = filterOrDieMessage$1;\n\n/**\n * Filters the specified effect with the provided function returning the value\n * of the effect if it is successful, otherwise returns the value of `orElse`.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst filterOrElse = filterOrElse$1;\n\n/**\n * Filter the specified effect with the provided function, failing with specified\n * error if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst filterOrFail = filterOrFail$1;\n\n/**\n * The moral equivalent of `if (!p) exp`.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst unless = unless$1;\n\n/**\n * The moral equivalent of `if (!p) exp` when `p` has side-effects.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst unlessEffect = unlessEffect$1;\n\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst when = when$1;\n\n/**\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst whenEffect = whenEffect$1;\n\n/**\n * Executes this workflow when value of the specified `FiberRef` satisfies the\n * predicate.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst whenFiberRef = whenFiberRef$1;\n\n/**\n * Executes this workflow when the value of the `Ref` satisfies the predicate.\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst whenRef = whenRef$1;\n\n// -------------------------------------------------------------------------------------\n// sequencing\n// -------------------------------------------------------------------------------------\n\n/**\n * This function is a pipeable operator that maps over an `Effect` value,\n * flattening the result of the mapping function into a new `Effect` value.\n *\n * @param f - The mapping function to apply to the `Effect` value.\n * This function must return another `Effect` value.\n *\n * @returns A new `Effect` value that is the result of flattening the\n * mapped `Effect` value.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = flatMap$1;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst flatten = flatten$1;\n\n/**\n * Returns an effect that races this effect with all the specified effects,\n * yielding the value of the first effect to succeed with a value. Losers of\n * the race will be interrupted immediately\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst raceAll = raceAll$1;\n\n/**\n * Returns an effect that races this effect with the specified effect,\n * returning the first successful `A` from the faster side. If one effect\n * succeeds, the other will be interrupted. If neither succeeds, then the\n * effect will fail with some error.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst race = race$1;\n\n/**\n * Returns an effect that races this effect with the specified effect,\n * yielding the first result to complete, whether by success or failure. If\n * neither effect completes, then the composed effect will not complete.\n *\n * WARNING: The raced effect will safely interrupt the \"loser\", but will not\n * resume until the loser has been cleanly terminated. If early return is\n * desired, then instead of performing `l raceFirst r`, perform\n * `l.disconnect raceFirst r.disconnect`, which disconnects left and right\n * interrupt signal, allowing a fast return, with interruption performed\n * in the background.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst raceFirst = raceFirst$1;\n\n/**\n * Returns an effect that races this effect with the specified effect, calling\n * the specified finisher as soon as one result or the other has been computed.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst raceWith = raceWith$1;\n\n/**\n * Summarizes a effect by computing some value before and after execution, and\n * then combining the values to produce a summary, together with the result of\n * execution.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst summarized = summarized$1;\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nconst tap = tap$1;\n\n/**\n * Returns an effect that effectfully \"peeks\" at the failure or success of\n * this effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapBoth = tapBoth$1;\n\n/**\n * Returns an effect that effectually \"peeks\" at the defect of this effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapDefect = tapDefect$1;\n\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapError = tapError$1;\n\n/**\n * Returns an effect that effectfully \"peeks\" at the specific tagged failure of this effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapErrorTag = tapErrorTag$1;\n\n/**\n * Returns an effect that effectually \"peeks\" at the cause of the failure of\n * this effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapErrorCause = tapErrorCause$1;\n\n// -------------------------------------------------------------------------------------\n// repetition / recursion\n// -------------------------------------------------------------------------------------\n\n/**\n * Repeats this effect forever (until the first error).\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst forever = forever$1;\n\n/**\n * Iterates with the specified effectual function. The moral equivalent of:\n *\n * ```ts\n * let s = initial\n *\n * while (cont(s)) {\n *   s = body(s)\n * }\n *\n * return s\n * ```\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst iterate = iterate$1;\n\n/**\n * Loops with the specified effectual function, collecting the results into a\n * list. The moral equivalent of:\n *\n * ```ts\n * let s  = initial\n * let as = [] as readonly A[]\n *\n * while (cont(s)) {\n *   as = [body(s), ...as]\n *   s  = inc(s)\n * }\n *\n * A.reverse(as)\n * ```\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst loop = loop$1;\n\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure. Scheduled recurrences are in addition\n * to the first execution, so that `io.repeat(Schedule.once)` yields an effect\n * that executes `io`, and then if that succeeds, executes `io` an additional\n * time.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeat = repeat_Effect;\n\n/**\n * Returns a new effect that repeats this effect the specified number of times\n * or until the first failure. Repeats are in addition to the first execution,\n * so that `io.repeatN(1)` yields an effect that executes `io`, and then if\n * that succeeds, executes `io` an additional time.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeatN = repeatN$1;\n\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure, at which point, the failure value and\n * schedule output are passed to the specified handler.\n *\n * Scheduled recurrences are in addition to the first execution, so that\n * `pipe(effect, Effect.repeat(Schedule.once()))` yields an effect that executes\n * `effect`, and then if that succeeds, executes `effect` an additional time.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeatOrElse = repeatOrElse_Effect;\n\n/**\n * Repeats this effect until its value satisfies the specified predicate or\n * until the first failure.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeatUntil = repeatUntil_Effect;\n\n/**\n * Repeats this effect until its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeatUntilEffect = repeatUntilEffect_Effect;\n\n/**\n * Repeats this effect while its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeatWhile = repeatWhile_Effect;\n\n/**\n * Repeats this effect while its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst repeatWhileEffect = repeatWhileEffect_Effect;\n\n/**\n * Runs this effect according to the specified schedule.\n *\n * See `scheduleFrom` for a variant that allows the schedule's decision to\n * depend on the result of this effect.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst schedule = schedule_Effect;\n\n/**\n * Runs this effect according to the specified schedule in a new fiber\n * attached to the current scope.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst scheduleForked = scheduleForked$1;\n\n/**\n * Runs this effect according to the specified schedule starting from the\n * specified input value.\n *\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst scheduleFrom = scheduleFrom_Effect;\n\n/**\n * @since 2.0.0\n * @category repetition / recursion\n */\nconst whileLoop = whileLoop$1;\n\n// -------------------------------------------------------------------------------------\n// fiber refs\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a collection of all `FiberRef` values for the fiber running this\n * effect.\n *\n * @since 2.0.0\n * @category fiber refs\n */\nconst getFiberRefs = fiberRefs;\n\n/**\n * Inherits values from all `FiberRef` instances into current fiber.\n *\n * @since 2.0.0\n * @category fiber refs\n */\nconst inheritFiberRefs = inheritFiberRefs$1;\n\n/**\n * @since 2.0.0\n * @category fiber refs\n */\nconst locally = fiberRefLocally;\n\n/**\n * @since 2.0.0\n * @category fiber refs\n */\nconst locallyWith = fiberRefLocallyWith;\n\n/**\n * @since 2.0.0\n * @category fiber refs\n */\nconst locallyScoped = fiberRefLocallyScoped;\n\n/**\n * @since 2.0.0\n * @category fiber refs\n */\nconst locallyScopedWith = fiberRefLocallyScopedWith;\n\n/**\n * Applies the specified changes to the `FiberRef` values for the fiber\n * running this workflow.\n *\n * @since 2.0.0\n * @category fiber refs\n */\nconst patchFiberRefs = patchFiberRefs$1;\n\n/**\n * Sets the `FiberRef` values for the fiber running this effect to the values\n * in the specified collection of `FiberRef` values.\n *\n * @since 2.0.0\n * @category fiber refs\n */\nconst setFiberRefs = setFiberRefs$1;\n\n/**\n * Updates the `FiberRef` values for the fiber running this effect using the\n * specified function.\n *\n * @since 2.0.0\n * @category fiber refs\n */\nconst updateFiberRefs = updateFiberRefs$1;\n\n// -------------------------------------------------------------------------------------\n// getters & folding\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if this effect is a failure, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters & folding\n */\nconst isFailure = isFailure$1;\n\n/**\n * Returns `true` if this effect is a success, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters & folding\n */\nconst isSuccess = isSuccess$1;\n\n/**\n * Folds over the failure value or the success value to yield an effect that\n * does not fail, but succeeds with the value returned by the left or right\n * function passed to `match`.\n *\n * @since 2.0.0\n * @category getters & folding\n */\nconst match = match$1;\n\n/**\n * @since 2.0.0\n * @category getters & folding\n */\nconst matchCause = matchCause$1;\n\n/**\n * @since 2.0.0\n * @category getters & folding\n */\nconst matchCauseEffect = matchCauseEffect$1;\n\n/**\n * @since 2.0.0\n * @category getters & folding\n */\nconst matchEffect = matchEffect$1;\n\n// -------------------------------------------------------------------------------------\n// logging\n// -------------------------------------------------------------------------------------\n\n/**\n * Logs the specified message or cause at the current log level.\n *\n * You can set the current log level using `FiberRef.currentLogLevel`.\n *\n * @since 2.0.0\n * @category logging\n */\nconst log = log$1;\n\n/**\n * Logs the specified message or cause at the Trace log level.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logTrace = logTrace$1;\n\n/**\n * Logs the specified message or cause at the Debug log level.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logDebug = logDebug$1;\n\n/**\n * Logs the specified message or cause at the Info log level.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logInfo = logInfo$1;\n\n/**\n * Logs the specified message or cause at the Warning log level.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logWarning = logWarning$1;\n\n/**\n * Logs the specified message or cause at the Error log level.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logError = logError$1;\n\n/**\n * Logs the specified message or cause at the Fatal log level.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logFatal = logFatal$1;\n\n/**\n * Adjusts the label for the current logging span.\n *\n * @since 2.0.0\n * @category logging\n */\nconst withLogSpan = withLogSpan$1;\n\n/**\n * Annotates each log in this effect with the specified log annotation.\n *\n * @since 2.0.0\n * @category logging\n */\nconst annotateLogs = annotateLogs$1;\n\n/**\n * Retrieves the log annotations associated with the current scope.\n *\n * @since 2.0.0\n * @category logging\n */\nconst logAnnotations = logAnnotations$1;\n\n/**\n * Decides wether child fibers will report or not unhandled errors via the logger\n *\n * @since 2.0.0\n * @category logging\n */\nconst withUnhandledErrorLogLevel = withUnhandledErrorLogLevel$1;\n\n// -------------------------------------------------------------------------------------\n// alternatives\n// -------------------------------------------------------------------------------------\n\n/**\n * Translates effect failure into death of the fiber, making all failures\n * unchecked and not a part of the type of the effect.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orDie = orDie$1;\n\n/**\n * Keeps none of the errors, and terminates the fiber with them, using the\n * specified function to convert the `E` into a `Throwable`.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orDieWith = orDieWith$1;\n\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * executes the specified effect.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orElse = orElse$1;\n\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * fails with the specified error.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orElseFail = orElseFail$1;\n\n/**\n * Executes this effect and returns its value, if it succeeds, but\n * otherwise succeeds with the specified value.\n *\n * @since 2.0.0\n * @category alternatives\n */\nconst orElseSucceed = orElseSucceed$1;\n\n// -------------------------------------------------------------------------------------\n// random\n// -------------------------------------------------------------------------------------\n\n/**\n * Retreives the `Random` service from the context.\n *\n * @since 2.0.0\n * @category random\n */\nconst random = random$1;\n\n/**\n * Retreives the `Random` service from the context and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n * @category random\n */\nconst randomWith = randomWith$1;\n\n// -------------------------------------------------------------------------------------\n// runtime\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns an effect that accesses the runtime, which can be used to\n * (unsafely) execute tasks. This is useful for integration with legacy code\n * that must call back into Effect code.\n *\n * @since 2.0.0\n * @category runtime\n */\nconst runtime = runtime$1;\n\n/**\n * Retrieves an effect that succeeds with the current runtime flags, which\n * govern behavior and features of the runtime system.\n *\n * @since 2.0.0\n * @category runtime\n */\nconst getRuntimeFlags = runtimeFlags;\n\n/**\n * @since 2.0.0\n * @category runtime\n */\nconst patchRuntimeFlags = updateRuntimeFlags;\n\n/**\n * @since 2.0.0\n * @category runtime\n */\nconst withRuntimeFlagsPatch = withRuntimeFlags;\n\n/**\n * @since 2.0.0\n * @category runtime\n */\nconst withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;\n\n// -------------------------------------------------------------------------------------\n// metrics\n// -------------------------------------------------------------------------------------\n\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst tagMetrics = tagMetrics$1;\n\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst labelMetrics = labelMetrics$1;\n\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst labelMetricsSet = labelMetricsSet$1;\n\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst tagMetricsScoped = tagMetricsScoped$1;\n\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst labelMetricsScoped = labelMetricsScoped$1;\n\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst labelMetricsScopedSet = labelMetricsScopedSet$1;\n\n/**\n * Retrieves the metric labels associated with the current scope.\n *\n * @since 2.0.0\n * @category metrics\n */\nconst metricLabels = metricLabels$1;\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nconst withMetric = withMetric$1;\n\n// -------------------------------------------------------------------------------------\n// unify\n// -------------------------------------------------------------------------------------\n\n/**\n * Used to unify functions that would otherwise return `Effect<A, B, C> | Effect<D, E, F>`\n *\n * @category unify\n * @since 2.0.0\n */\nconst unifiedFn = unified$1;\n\n/**\n * Used to unify effects that would otherwise be `Effect<A, B, C> | Effect<D, E, F>`\n *\n * @category unify\n * @since 2.0.0\n */\nconst unified = identity;\n\n// -------------------------------------------------------------------------------------\n// semaphore\n// -------------------------------------------------------------------------------------\n\n/**\n * @category semaphore\n * @since 2.0.0\n */\n/**\n * @category semaphore\n * @since 2.0.0\n */\n/**\n * Unsafely creates a new Semaphore\n *\n * @since 2.0.0\n * @category semaphore\n */\nconst unsafeMakeSemaphore = unsafeMakeSemaphore$1;\n\n/**\n * Creates a new Semaphore\n *\n * @since 2.0.0\n * @category semaphore\n */\nconst makeSemaphore = makeSemaphore$1;\n\n// -------------------------------------------------------------------------------------\n// execution\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.0.0\n * @category execution\n */\nconst runFork = unsafeForkEffect;\n\n/**\n * @since 2.0.0\n * @category execution\n */\nconst runCallback = unsafeRunEffect;\n\n/**\n * Runs an `Effect` workflow, returning a `Promise` which resolves with the\n * result of the workflow or rejects with an error.\n *\n * @since 2.0.0\n * @category execution\n */\nconst runPromise = unsafeRunPromiseEffect;\n\n/**\n * Runs an `Effect` workflow, returning a `Promise` which resolves with the\n * `Exit` value of the workflow.\n *\n * @since 2.0.0\n * @category execution\n */\nconst runPromiseExit = unsafeRunPromiseExitEffect;\n\n/**\n * @since 2.0.0\n * @category execution\n */\nconst runSync = unsafeRunSyncEffect;\n\n/**\n * @since 2.0.0\n * @category execution\n */\nconst runSyncExit = unsafeRunSyncExitEffect;\n\n// -------------------------------------------------------------------------------------\n// zipping\n// -------------------------------------------------------------------------------------\n\n/**\n * Sequentially zips the this result with the specified result. Combines both\n * `Cause`s when both effects fail.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst validate = validate$1;\n\n/**\n * Sequentially zips this effect with the specified effect using the specified\n * combiner function. Combines the causes in case both effect fail.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst validateWith = validateWith$1;\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nconst zip = zipOptions;\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nconst zipLeft = zipLeftOptions;\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nconst zipRight = zipRightOptions;\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nconst zipWith = zipWithOptions;\n\n// -------------------------------------------------------------------------------------\n// applicatives\n// -------------------------------------------------------------------------------------\n/**\n * @category combining\n * @since 2.0.0\n */\nconst ap = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n// -------------------------------------------------------------------------------------\n// requests & batching\n// -------------------------------------------------------------------------------------\n\n/**\n * @category requests & batching\n * @since 2.0.0\n */\nconst blocked = blocked$1;\n\n/**\n * @category requests & batching\n * @since 2.0.0\n */\nconst runRequestBlock = runRequestBlock$1;\n\n/**\n * @category requests & batching\n * @since 2.0.0\n */\nconst step = step$1;\n\n/**\n * @category requests & batching\n * @since 2.0.0\n */\nconst flatMapStep = flatMapStep$1;\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst request = fromRequest;\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst cacheRequestResult = cacheRequest;\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst withRequestBatching = withRequestBatching$1;\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst withRequestCaching = withRequestCaching$1;\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst withRequestCache = withRequestCache$1;\n\n// -------------------------------------------------------------------------------------\n// tracing\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst tracer = tracer$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst tracerWith = tracerWith$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst withTracer = withTracer$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst withTracerScoped = withTracerScoped$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst withTracerTiming = withTracerTiming$1;\n\n/**\n * Adds an annotation to each span in this effect.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst annotateSpans = annotateSpans$1;\n\n/**\n * Adds an annotation to the current span if available\n *\n * @since 2.0.0\n * @category tracing\n */\nconst annotateCurrentSpan = annotateCurrentSpan$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst currentSpan = currentSpan$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst currentParentSpan = currentParentSpan$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst spanAnnotations = spanAnnotations$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst spanLinks = spanLinks$1;\n\n/**\n * For all spans in this effect, add a link with the provided span.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst linkSpans = linkSpans$1;\n\n/**\n * Create a new span for tracing.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst makeSpan = makeSpan$1;\n\n/**\n * Create a new span for tracing, and automatically close it when the Scope\n * finalizes.\n *\n * The span is not added to the current span stack, so no child spans will be\n * created for it.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst makeSpanScoped = makeSpanScoped$1;\n\n/**\n * Create a new span for tracing, and automatically close it when the effect\n * completes.\n *\n * The span is not added to the current span stack, so no child spans will be\n * created for it.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst useSpan = useSpan$1;\n\n/**\n * Wraps the effect with a new span for tracing.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst withSpan = withSpan$1;\n\n/**\n * Wraps the effect with a new span for tracing.\n *\n * The span is ended when the Scope is finalized.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst withSpanScoped = withSpanScoped$1;\n\n/**\n * Create and add a span to the current span stack.\n *\n * The span is ended & removed from the stack when the Scope is finalized.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst setSpan = setSpan$1;\n\n/**\n * Adds the provided span to the current span stack.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst withParentSpan = withParentSpan$1;\n\n/**\n * Adds the provided span to the current span stack.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst setParentSpan = setParentSpan$1;\n\n// -------------------------------------------------------------------------------------\n// optionality\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns an effect that errors with `NoSuchElementException` if the value is\n * null or undefined, otherwise succeeds with the value.\n *\n * @since 2.0.0\n * @category optionality\n */\nconst fromNullable = fromNullable$1;\n\n/**\n * Wraps the success value of this effect with `Option.some`, and maps\n * `Cause.NoSuchElementException` to `Option.none`.\n *\n * @since 2.0.0\n * @category optionality\n */\nconst optionFromOptional = optionFromOptional$1;\n\nexport { Do, EffectTypeId, acquireRelease, acquireReleaseInterruptible, acquireUseRelease, addFinalizer, all, allSuccesses, allWith, allowInterrupt, annotateCurrentSpan, annotateLogs, annotateSpans, ap, as, asSome, asSomeError, asUnit, async, asyncEffect, asyncEither, asyncOption, awaitAllChildren, bind, bindTo, blocked, cacheRequestResult, cached, cachedFunction, cachedInvalidateWithTTL, cachedWithTTL, _catch as catch, catchAll, catchAllCause, catchAllDefect, catchIf, catchSome, catchSomeCause, catchSomeDefect, catchTag, catchTags, cause, checkInterruptible, clock, clockWith, config, configProviderWith, context, contextWith, contextWithEffect, currentParentSpan, currentSpan, daemonChildren, delay, descriptor, descriptorWith, die, dieMessage, dieSync, diffFiberRefs, disconnect, dropUntil, dropWhile, either, ensuring, ensuringChild, ensuringChildren, eventually, every, exists, exit, fail, failCause, failCauseSync, failSync, fiberId, fiberIdWith, filter, filterOrDie, filterOrDieMessage, filterOrElse, filterOrFail, finalizersMask, findFirst, firstSuccessOf, flatMap, flatMapStep, flatten, flip, flipWith, forEach, forever, fork, forkAll, forkDaemon, forkIn, forkScoped, forkWithErrorHandler, fromFiber, fromFiberEffect, fromNullable, gen, getFiberRefs, getRuntimeFlags, head, if_ as if, ignore, ignoreLogged, inheritFiberRefs, interrupt, interruptWith, interruptible, interruptibleMask, intoDeferred, isEffect, isFailure, isSuccess, iterate, labelMetrics, labelMetricsScoped, labelMetricsScopedSet, labelMetricsSet, let_ as let, linkSpans, locally, locallyScoped, locallyScopedWith, locallyWith, log, logAnnotations, logDebug, logError, logFatal, logInfo, logTrace, logWarning, loop, makeSemaphore, makeSpan, makeSpanScoped, map, mapAccum, mapBoth, mapError, mapErrorCause, mapInputContext, match, matchCause, matchCauseEffect, matchEffect, merge, mergeAll, metricLabels, negate, never, none, onError, onExit, onInterrupt, once, option, optionFromOptional, orDie, orDieWith, orElse, orElseFail, orElseSucceed, parallelErrors, parallelFinalizers, partition, patchFiberRefs, patchRuntimeFlags, promise, provide, provideService, provideServiceEffect, race, raceAll, raceFirst, raceWith, random, randomWith, reduce, reduceEffect, reduceRight, reduceWhile, repeat, repeatN, repeatOrElse, repeatUntil, repeatUntilEffect, repeatWhile, repeatWhileEffect, replicate, replicateEffect, request, retry, retryN, retryOrElse, retryUntil, retryUntilEffect, retryWhile, retryWhileEffect, runCallback, runFork, runPromise, runPromiseExit, runRequestBlock, runSync, runSyncExit, runtime, sandbox, schedule, scheduleForked, scheduleFrom, scope, scopeWith, scoped, sequentialFinalizers, serviceConstants, serviceFunction, serviceFunctionEffect, serviceFunctions, serviceMembers, serviceOption, setFiberRefs, setParentSpan, setSpan, sleep, spanAnnotations, spanLinks, step, succeed, succeedNone, succeedSome, summarized, supervised, suspend, sync, tagMetrics, tagMetricsScoped, takeUntil, takeWhile, tap, tapBoth, tapDefect, tapError, tapErrorCause, tapErrorTag, timed, timedWith, timeout, timeoutFail, timeoutFailCause, timeoutTo, tracer, tracerWith, transplant, try_ as try, tryMap, tryMapPromise, tryPromise, unified, unifiedFn, uninterruptible, uninterruptibleMask, unit, unless, unlessEffect, unsafeMakeSemaphore, unsandbox, updateFiberRefs, updateService, useSpan, using, validate, validateAll, validateFirst, validateWith, when, whenEffect, whenFiberRef, whenRef, whileLoop, withClock, withClockScoped, withConcurrency, withConfigProvider, withConfigProviderScoped, withEarlyRelease, withLogSpan, withMaxOpsBeforeYield, withMetric, withParentSpan, withRequestBatching, withRequestCache, withRequestCaching, withRuntimeFlagsPatch, withRuntimeFlagsPatchScoped, withScheduler, withSchedulingPriority, withSpan, withSpanScoped, withTracer, withTracerScoped, withTracerTiming, withUnhandledErrorLogLevel, yieldNow, zip, zipLeft, zipRight, zipWith };\n","import { EffectTypeId as EffectTypeId$1, StreamTypeId as StreamTypeId$1, SinkTypeId as SinkTypeId$1, ChannelTypeId as ChannelTypeId$1, EffectPrototype as EffectPrototype$1, CommitPrototype as CommitPrototype$1, StructuralCommitPrototype as StructuralCommitPrototype$1, Base as Base$1, StructuralBase as StructuralBase$1 } from '../../internal/Effectable.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst EffectTypeId = EffectTypeId$1;\n\n/**\n * @since 2.0.0\n * @category type ids\n */\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst StreamTypeId = StreamTypeId$1;\n\n/**\n * @since 2.0.0\n * @category type ids\n */\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst SinkTypeId = SinkTypeId$1;\n\n/**\n * @since 2.0.0\n * @category type ids\n */\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst ChannelTypeId = ChannelTypeId$1;\n\n/**\n * @since 2.0.0\n * @category type ids\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category prototypes\n */\nconst EffectPrototype = EffectPrototype$1;\n\n/**\n * @since 2.0.0\n * @category prototypes\n */\nconst CommitPrototype = CommitPrototype$1;\n\n/**\n * @since 2.0.0\n * @category prototypes\n */\nconst StructuralCommitPrototype = StructuralCommitPrototype$1;\nconst Base = Base$1;\nconst StructuralBase = StructuralBase$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass Class extends Base {}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass StructuralClass extends StructuralBase {}\n\nexport { ChannelTypeId, Class, CommitPrototype, EffectPrototype, EffectTypeId, SinkTypeId, StreamTypeId, StructuralClass, StructuralCommitPrototype };\n","import { fail } from '../../Effect/dist/effect-Effect.esm.js';\nimport { StructuralCommitPrototype } from '../../Effectable/dist/effect-Effectable.esm.js';\nimport { struct as struct$1, StructProto, ArrayProto, Structural as Structural$1 } from '../../internal/Data.esm.js';\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * `Case` represents a datatype similar to a case class in Scala. Namely, a\n * datatype created using `Case` will, by default, provide an implementation\n * for a constructor, `Hash`, and `Equal`.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst struct = struct$1;\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst unsafeStruct = as => Object.setPrototypeOf(as, StructProto);\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst tuple = (...as) => unsafeArray(as);\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst array = as => unsafeArray(as.slice(0));\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst unsafeArray = as => Object.setPrototypeOf(as, ArrayProto);\nconst _case = () => args => args === undefined ? Object.create(StructProto) : struct(args);\n\n/**\n * Provides a tagged constructor for the specified `Case`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst tagged = tag => args => {\n  const value = args === undefined ? Object.create(StructProto) : struct(args);\n  value._tag = tag;\n  return value;\n};\n\n/**\n * Provides a Tagged constructor for a Case Class.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst TaggedClass = tag => {\n  class Base extends Class {\n    _tag = tag;\n  }\n  return Base;\n};\n\n/**\n * Provides a constructor for a Case Class.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst Class = Structural$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Structural = Structural$1;\n\n/**\n * Create a tagged enum data type, which is a union of `Data` structs.\n *\n * ```ts\n * import * as Data from \"effect/Data\"\n *\n * type HttpError = Data.TaggedEnum<{\n *   BadRequest: { status: 400, message: string }\n *   NotFound: { status: 404, message: string }\n * }>\n *\n * // Equivalent to:\n * type HttpErrorPlain =\n *   | Data.Data<{\n *     readonly _tag: \"BadRequest\"\n *     readonly status: 400\n *     readonly message: string\n *   }>\n *   | Data.Data<{\n *     readonly _tag: \"NotFound\"\n *     readonly status: 404\n *     readonly message: string\n *   }>\n * ```\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Create a constructor for a tagged union of `Data` structs.\n *\n * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n * the constructor.\n *\n * @example\n * import * as Data from \"effect/Data\"\n *\n * const HttpError = Data.taggedEnum<\n *   | Data.Data<{ _tag: \"BadRequest\"; status: 400; message: string }>\n *   | Data.Data<{ _tag: \"NotFound\"; status: 404; message: string }>\n * >()\n *\n * const notFound = HttpError(\"NotFound\")({ status: 404, message: \"Not Found\" })\n *\n * @example\n * import * as Data from \"effect/Data\"\n *\n * type MyResult<E, A> = Data.TaggedEnum<{\n *   Failure: { error: E }\n *   Success: { value: A }\n * }>\n * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n * }\n * const MyResult = Data.taggedEnum<MyResultDefinition>()\n *\n * const success = MyResult(\"Success\")({ value: 1 })\n *\n * @category constructors\n * @since 2.0.0\n */\nconst taggedEnum = () => tagged;\n\n/**\n * @since 2.0.0\n * @category models\n */\n\nconst YieldableErrorMessage = /*#__PURE__*/Symbol.for(\"effect/Data/YieldableError/message\");\nconst YieldableErrorProto = {\n  ...StructuralCommitPrototype,\n  __proto__: globalThis.Error.prototype,\n  commit() {\n    return fail(this);\n  },\n  toString() {\n    return `${this.name}: ${this.message}`;\n  },\n  get message() {\n    return this[YieldableErrorMessage] ?? JSON.stringify(this);\n  },\n  set message(value) {\n    this[YieldableErrorMessage] = value;\n  }\n};\n\n/**\n * Provides a constructor for a Case Class.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst Error = /*#__PURE__*/function () {\n  function Base(args) {\n    if (args) {\n      Object.assign(this, args);\n    }\n    globalThis.Error.captureStackTrace(this, this.constructor);\n  }\n  Base.prototype = YieldableErrorProto;\n  return Base;\n}();\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst TaggedError = tag => {\n  class Base extends Error {\n    _tag = tag;\n  }\n  Base.prototype.name = tag;\n  return Base;\n};\n\nexport { Class, Error, Structural, TaggedClass, TaggedError, array, _case as case, struct, tagged, taggedEnum, tuple, unsafeArray, unsafeStruct };\n","import { string } from '../../Equivalence/dist/effect-Equivalence.esm.js';\nimport { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { isNonEmptyArray } from '../../internal/ReadonlyArray.esm.js';\nimport { greaterThanOrEqualTo, sign } from '../../Number/dist/effect-Number.esm.js';\nimport { filter, some, fromNullable } from '../../Option/dist/effect-Option.esm.js';\nimport { string as string$1 } from '../../Order/dist/effect-Order.esm.js';\nimport { isString as isString$1 } from '../../Predicate/dist/effect-Predicate.esm.js';\n\n/**\n * This module provides utility functions and type class instances for working with the `string` type in TypeScript.\n * It includes functions for basic string manipulation, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @since 2.0.0\n */\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from 'effect/String'\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isString = isString$1;\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Equivalence = string;\n\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Order = string$1;\n\n/**\n * The empty string `\"\"`.\n *\n * @since 2.0.0\n */\nconst empty = \"\";\n\n/**\n * Concatenates two strings at the type level.\n *\n * @since 2.0.0\n */\n\n/**\n * Concatenates two strings at runtime.\n *\n * @since 2.0.0\n */\nconst concat = /*#__PURE__*/dual(2, (self, that) => self + that);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 2.0.0\n */\nconst toUpperCase = self => self.toUpperCase();\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 2.0.0\n */\nconst toLowerCase = self => self.toLowerCase();\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.capitalize), 'Abc')\n *\n * @since 2.0.0\n */\nconst capitalize = self => {\n  if (self.length === 0) return self;\n  return toUpperCase(self[0]) + self.slice(1);\n};\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('ABC', S.uncapitalize), 'aBC')\n *\n * @since 2.0.0\n */\nconst uncapitalize = self => {\n  if (self.length === 0) return self;\n  return toLowerCase(self[0]) + self.slice(1);\n};\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 2.0.0\n */\nconst replace = (searchValue, replaceValue) => self => self.replace(searchValue, replaceValue);\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.trim(' a '), 'a')\n *\n * @since 2.0.0\n */\nconst trim = self => self.trim();\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.trimStart(' a '), 'a ')\n *\n * @since 2.0.0\n */\nconst trimStart = self => self.trimStart();\n\n/**\n * @since 2.0.0\n */\n\n/**\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.trimEnd(' a '), ' a')\n *\n * @since 2.0.0\n */\nconst trimEnd = self => self.trimEnd();\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 2.0.0\n */\nconst slice = (start, end) => self => self.slice(start, end);\n\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.isEmpty(''), true)\n * assert.deepStrictEqual(S.isEmpty('a'), false)\n *\n * @since 2.0.0\n */\nconst isEmpty = self => self.length === 0;\n\n/**\n * Test whether a `string` is non empty.\n *\n * @since 2.0.0\n */\nconst isNonEmpty = self => self.length > 0;\n\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.length('abc'), 3)\n *\n * @since 2.0.0\n */\nconst length = self => self.length;\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 2.0.0\n */\nconst split = /*#__PURE__*/dual(2, (self, separator) => {\n  const out = self.split(separator);\n  return isNonEmptyArray(out) ? out : [self];\n});\n\n/**\n * Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\n * greater than or equal to `position`; otherwise, returns `false`.\n *\n * @since 2.0.0\n */\nconst includes = (searchString, position) => self => self.includes(searchString, position);\n\n/**\n * @since 2.0.0\n */\nconst startsWith = (searchString, position) => self => self.startsWith(searchString, position);\n\n/**\n * @since 2.0.0\n */\nconst endsWith = (searchString, position) => self => self.endsWith(searchString, position);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.charCodeAt(1)), Option.some(98))\n * assert.deepStrictEqual(pipe(\"abc\", S.charCodeAt(4)), Option.none())\n *\n * @since 2.0.0\n */\nconst charCodeAt = /*#__PURE__*/dual(2, (self, index) => filter(some(self.charCodeAt(index)), charCode => !isNaN(charCode)));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abcd\", S.substring(1)), \"bcd\")\n * assert.deepStrictEqual(pipe(\"abcd\", S.substring(1, 3)), \"bc\")\n *\n * @since 2.0.0\n */\nconst substring = (start, end) => self => self.substring(start, end);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.at(1)), Option.some(\"b\"))\n * assert.deepStrictEqual(pipe(\"abc\", S.at(4)), Option.none())\n *\n * @since 2.0.0\n */\nconst at = /*#__PURE__*/dual(2, (self, index) => fromNullable(self.at(index)));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.charAt(1)), Option.some(\"b\"))\n * assert.deepStrictEqual(pipe(\"abc\", S.charAt(4)), Option.none())\n *\n * @since 2.0.0\n */\nconst charAt = /*#__PURE__*/dual(2, (self, index) => filter(some(self.charAt(index)), isNonEmpty));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.codePointAt(1)), Option.some(98))\n *\n * @since 2.0.0\n */\nconst codePointAt = /*#__PURE__*/dual(2, (self, index) => fromNullable(self.codePointAt(index)));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abbbc\", S.indexOf(\"b\")), Option.some(1))\n *\n * @since 2.0.0\n */\nconst indexOf = searchString => self => filter(some(self.indexOf(searchString)), greaterThanOrEqualTo(0));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abbbc\", S.lastIndexOf(\"b\")), Option.some(3))\n * assert.deepStrictEqual(pipe(\"abbbc\", S.lastIndexOf(\"d\")), Option.none())\n *\n * @since 2.0.0\n */\nconst lastIndexOf = searchString => self => filter(some(self.lastIndexOf(searchString)), greaterThanOrEqualTo(0));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.localeCompare(\"b\")), -1)\n * assert.deepStrictEqual(pipe(\"b\", S.localeCompare(\"a\")), 1)\n * assert.deepStrictEqual(pipe(\"a\", S.localeCompare(\"a\")), 0)\n *\n * @since 2.0.0\n */\nconst localeCompare = (that, locales, options) => self => sign(self.localeCompare(that, locales, options));\n\n/**\n * It is the `pipe`-able version of the native `match` method.\n *\n * @since 2.0.0\n */\nconst match = regexp => self => fromNullable(self.match(regexp));\n\n/**\n * It is the `pipe`-able version of the native `matchAll` method.\n *\n * @since 2.0.0\n */\nconst matchAll = regexp => self => self.matchAll(regexp);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * const str = \"\\u1E9B\\u0323\";\n * assert.deepStrictEqual(pipe(str, S.normalize()), \"\\u1E9B\\u0323\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFC\")), \"\\u1E9B\\u0323\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFD\")), \"\\u017F\\u0323\\u0307\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFKC\")), \"\\u1E69\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFKD\")), \"\\u0073\\u0323\\u0307\")\n *\n * @since 2.0.0\n */\nconst normalize = form => self => self.normalize(form);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.padEnd(5)), \"a    \")\n * assert.deepStrictEqual(pipe(\"a\", S.padEnd(5, \"_\")), \"a____\")\n *\n * @since 2.0.0\n */\nconst padEnd = (maxLength, fillString) => self => self.padEnd(maxLength, fillString);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.padStart(5)), \"    a\")\n * assert.deepStrictEqual(pipe(\"a\", S.padStart(5, \"_\")), \"____a\")\n *\n * @since 2.0.0\n */\nconst padStart = (maxLength, fillString) => self => self.padStart(maxLength, fillString);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.repeat(5)), \"aaaaa\")\n *\n * @since 2.0.0\n */\nconst repeat = count => self => self.repeat(count);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"ababb\", S.replaceAll(\"b\", \"c\")), \"acacc\")\n * assert.deepStrictEqual(pipe(\"ababb\", S.replaceAll(/ba/g, \"cc\")), \"accbb\")\n *\n * @since 2.0.0\n */\nconst replaceAll = (searchValue, replaceValue) => self => self.replaceAll(searchValue, replaceValue);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"ababb\", S.search(\"b\")), Option.some(1))\n * assert.deepStrictEqual(pipe(\"ababb\", S.search(/abb/)), Option.some(2))\n * assert.deepStrictEqual(pipe(\"ababb\", S.search(\"d\")), Option.none())\n *\n * @since 2.0.0\n */\nconst search = /*#__PURE__*/dual(2, (self, regexp) => filter(some(self.search(regexp)), greaterThanOrEqualTo(0)));\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * const str = \"\\u0130\"\n * assert.deepStrictEqual(pipe(str, S.toLocaleLowerCase(\"tr\")), \"i\")\n *\n * @since 2.0.0\n */\nconst toLocaleLowerCase = locale => self => self.toLocaleLowerCase(locale);\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * const str = \"i\\u0307\"\n * assert.deepStrictEqual(pipe(str, S.toLocaleUpperCase(\"lt-LT\")), \"I\")\n *\n * @since 2.0.0\n */\nconst toLocaleUpperCase = locale => self => self.toLocaleUpperCase(locale);\n\n/**\n * Keep the specified number of characters from the start of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.takeLeft(\"Hello World\", 5), \"Hello\")\n *\n * @since 2.0.0\n */\nconst takeLeft = /*#__PURE__*/dual(2, (self, n) => self.slice(0, Math.max(n, 0)));\n\n/**\n * Keep the specified number of characters from the end of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.takeRight(\"Hello World\", 5), \"World\")\n *\n * @since 2.0.0\n */\nconst takeRight = /*#__PURE__*/dual(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));\nconst CR = 0x0d;\nconst LF = 0x0a;\n\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string, trimming off the trailing newline character.\n *\n * @since 2.0.0\n */\n// export const linesIterator = (self: string): LinesIterator => linesSeparated(self, true)\n\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string as well as the trailing newline character.\n *\n * @since 2.0.0\n */\nconst linesWithSeparators = s => linesSeparated(s, false);\n\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the character specified by `marginChar`\n * from the line.\n *\n * @since 2.0.0\n */\nconst stripMarginWith = /*#__PURE__*/dual(2, (self, marginChar) => {\n  let out = \"\";\n  for (const line of linesWithSeparators(self)) {\n    let index = 0;\n    while (index < line.length && line.charAt(index) <= \" \") {\n      index = index + 1;\n    }\n    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;\n    out = out + stripped;\n  }\n  return out;\n});\n\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the `\"|\"` character from the line.\n *\n * @since 2.0.0\n */\nconst stripMargin = self => stripMarginWith(self, \"|\");\nclass LinesIterator {\n  constructor(s, stripped = false) {\n    this.s = s;\n    this.stripped = stripped;\n    this.index = 0;\n    this.length = s.length;\n  }\n  next() {\n    if (this.done) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const start = this.index;\n    while (!this.done && !isLineBreak(this.s[this.index])) {\n      this.index = this.index + 1;\n    }\n    let end = this.index;\n    if (!this.done) {\n      const char = this.s[this.index];\n      this.index = this.index + 1;\n      if (!this.done && isLineBreak2(char, this.s[this.index])) {\n        this.index = this.index + 1;\n      }\n      if (!this.stripped) {\n        end = this.index;\n      }\n    }\n    return {\n      done: false,\n      value: this.s.substring(start, end)\n    };\n  }\n  [Symbol.iterator]() {\n    return new LinesIterator(this.s, this.stripped);\n  }\n  get done() {\n    return this.index >= this.length;\n  }\n}\n\n/**\n * Test if the provided character is a line break character (i.e. either `\"\\r\"`\n * or `\"\\n\"`).\n */\nconst isLineBreak = char => {\n  const code = char.charCodeAt(0);\n  return code === CR || code === LF;\n};\n\n/**\n * Test if the provided characters combine to form a carriage return/line-feed\n * (i.e. `\"\\r\\n\"`).\n */\nconst isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;\nconst linesSeparated = (self, stripped) => new LinesIterator(self, stripped);\n\nexport { Equivalence, Order, at, capitalize, charAt, charCodeAt, codePointAt, concat, empty, endsWith, includes, indexOf, isEmpty, isNonEmpty, isString, lastIndexOf, length, linesWithSeparators, localeCompare, match, matchAll, normalize, padEnd, padStart, repeat, replace, replaceAll, search, slice, split, startsWith, stripMargin, stripMarginWith, substring, takeLeft, takeRight, toLocaleLowerCase, toLocaleUpperCase, toLowerCase, toUpperCase, trim, trimEnd, trimStart, uncapitalize };\n","/**\n * @since 1.0.0\n */\n\n// ---------------------------------------------\n// hooks\n// ---------------------------------------------\n/** @internal */\nconst ArbitraryHookId = /*#__PURE__*/Symbol.for(\"@effect/schema/ArbitraryHookId\");\n\n/** @internal */\nconst PrettyHookId = /*#__PURE__*/Symbol.for(\"@effect/schema/PrettyHookId\");\n\n// ---------------------------------------------\n// Schema APIs\n// ---------------------------------------------\n\n/** @internal */\nconst getKeysForIndexSignature = (input, parameter) => {\n  switch (parameter._tag) {\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n      return Object.keys(input);\n    case \"SymbolKeyword\":\n      return Object.getOwnPropertySymbols(input);\n    case \"Refinement\":\n      return getKeysForIndexSignature(input, parameter.from);\n  }\n};\n\n// ---------------------------------------------\n// general helpers\n// ---------------------------------------------\n\n/** @internal */\nconst maxSafeInteger = /*#__PURE__*/BigInt(Number.MAX_SAFE_INTEGER);\n\n/** @internal */\nconst minSafeInteger = /*#__PURE__*/BigInt(Number.MIN_SAFE_INTEGER);\n\n/** @internal */\nconst ownKeys = o => Object.keys(o).concat(Object.getOwnPropertySymbols(o));\n\n/** @internal */\nconst memoizeThunk = f => {\n  let done = false;\n  let a;\n  return () => {\n    if (done) {\n      return a;\n    }\n    a = f();\n    done = true;\n    return a;\n  };\n};\n\nexport { ArbitraryHookId, PrettyHookId, getKeysForIndexSignature, maxSafeInteger, memoizeThunk, minSafeInteger, ownKeys };\n","import { pipe } from 'effect/Function';\nimport * as Number from 'effect/Number';\nimport * as Option from 'effect/Option';\nimport * as Order from 'effect/Order';\nimport * as Predicate from 'effect/Predicate';\nimport * as ReadonlyArray from 'effect/ReadonlyArray';\nimport { memoizeThunk } from '../../internal/common.esm.js';\n\n/**\n * @since 1.0.0\n */\n\n// -------------------------------------------------------------------------------------\n// annotations\n// -------------------------------------------------------------------------------------\n/**\n * @category annotations\n * @since 1.0.0\n */\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst BrandAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Brand\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst TypeAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Type\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst MessageAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Message\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst IdentifierAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Identifier\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst TitleAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Title\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst DescriptionAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Description\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst ExamplesAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Examples\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst JSONSchemaAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/JSONSchema\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst DocumentationAnnotationId = /*#__PURE__*/Symbol.for(\"@effect/schema/annotation/Documentation\");\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst getAnnotation = key => annotated => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? Option.some(annotated.annotations[key]) : Option.none();\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 1.0.0\n */\n/**\n * @category model\n * @since 1.0.0\n */\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createDeclaration = (typeParameters, type, decode, annotations = {}) => ({\n  _tag: \"Declaration\",\n  typeParameters,\n  type,\n  decode,\n  annotations\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isDeclaration = ast => ast._tag === \"Declaration\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createLiteral = literal => ({\n  _tag: \"Literal\",\n  literal,\n  annotations: {}\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isLiteral = ast => ast._tag === \"Literal\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createUniqueSymbol = (symbol, annotations = {}) => ({\n  _tag: \"UniqueSymbol\",\n  symbol,\n  annotations\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isUniqueSymbol = ast => ast._tag === \"UniqueSymbol\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst undefinedKeyword = {\n  _tag: \"UndefinedKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"undefined\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isUndefinedKeyword = ast => ast._tag === \"UndefinedKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst voidKeyword = {\n  _tag: \"VoidKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"void\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isVoidKeyword = ast => ast._tag === \"VoidKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst neverKeyword = {\n  _tag: \"NeverKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"never\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isNeverKeyword = ast => ast._tag === \"NeverKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst unknownKeyword = {\n  _tag: \"UnknownKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"unknown\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isUnknownKeyword = ast => ast._tag === \"UnknownKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst anyKeyword = {\n  _tag: \"AnyKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"any\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isAnyKeyword = ast => ast._tag === \"AnyKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst stringKeyword = {\n  _tag: \"StringKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"string\",\n    [DescriptionAnnotationId]: \"a string\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isStringKeyword = ast => ast._tag === \"StringKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst numberKeyword = {\n  _tag: \"NumberKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"number\",\n    [DescriptionAnnotationId]: \"a number\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isNumberKeyword = ast => ast._tag === \"NumberKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst booleanKeyword = {\n  _tag: \"BooleanKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"boolean\",\n    [DescriptionAnnotationId]: \"a boolean\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isBooleanKeyword = ast => ast._tag === \"BooleanKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst bigIntKeyword = {\n  _tag: \"BigIntKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"bigint\",\n    [DescriptionAnnotationId]: \"a bigint\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isBigIntKeyword = ast => ast._tag === \"BigIntKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst symbolKeyword = {\n  _tag: \"SymbolKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"symbol\",\n    [DescriptionAnnotationId]: \"a symbol\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isSymbolKeyword = ast => ast._tag === \"SymbolKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst objectKeyword = {\n  _tag: \"ObjectKeyword\",\n  annotations: {\n    [TitleAnnotationId]: \"object\",\n    [DescriptionAnnotationId]: \"an object\"\n  }\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isObjectKeyword = ast => ast._tag === \"ObjectKeyword\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createEnums = enums => ({\n  _tag: \"Enums\",\n  enums,\n  annotations: {}\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isEnums = ast => ast._tag === \"Enums\";\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createTemplateLiteral = (head, spans) => ReadonlyArray.isNonEmptyReadonlyArray(spans) ? {\n  _tag: \"TemplateLiteral\",\n  head,\n  spans,\n  annotations: {}\n} : createLiteral(head);\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isTemplateLiteral = ast => ast._tag === \"TemplateLiteral\";\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst createElement = (type, isOptional) => ({\n  type,\n  isOptional\n});\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createTuple = (elements, rest, isReadonly, annotations = {}) => ({\n  _tag: \"Tuple\",\n  elements,\n  rest,\n  isReadonly,\n  annotations\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isTuple = ast => ast._tag === \"Tuple\";\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst createPropertySignature = (name, type, isOptional, isReadonly, annotations = {}) => ({\n  name,\n  type,\n  isOptional,\n  isReadonly,\n  annotations\n});\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst isParameter = ast => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"SymbolKeyword\":\n    case \"TemplateLiteral\":\n      return true;\n    case \"Refinement\":\n      return isParameter(ast.from);\n    default:\n      return false;\n  }\n};\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst createIndexSignature = (parameter, type, isReadonly) => {\n  if (isParameter(parameter)) {\n    return {\n      parameter,\n      type,\n      isReadonly\n    };\n  }\n  throw new Error(\"An index signature parameter type must be 'string', 'symbol', a template literal type or a refinement of the previous types\");\n};\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createTypeLiteral = (propertySignatures, indexSignatures, annotations = {}) => {\n  // check for duplicate property signatures\n  const keys = {};\n  for (let i = 0; i < propertySignatures.length; i++) {\n    const name = propertySignatures[i].name;\n    if (Object.prototype.hasOwnProperty.call(keys, name)) {\n      throw new Error(`Duplicate property signature ${String(name)}`);\n    }\n    keys[name] = null;\n  }\n  // check for duplicate index signatures\n  const parameters = {\n    string: false,\n    symbol: false\n  };\n  for (let i = 0; i < indexSignatures.length; i++) {\n    const parameter = getParameterBase(indexSignatures[i].parameter);\n    if (isStringKeyword(parameter)) {\n      if (parameters.string) {\n        throw new Error(\"Duplicate index signature for type `string`\");\n      }\n      parameters.string = true;\n    } else if (isSymbolKeyword(parameter)) {\n      if (parameters.symbol) {\n        throw new Error(\"Duplicate index signature for type `symbol`\");\n      }\n      parameters.symbol = true;\n    }\n  }\n  return {\n    _tag: \"TypeLiteral\",\n    propertySignatures: sortPropertySignatures(propertySignatures),\n    indexSignatures,\n    annotations\n  };\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isTypeLiteral = ast => ast._tag === \"TypeLiteral\";\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\nconst isMembers = as => as.length > 1;\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createUnion = (candidates, annotations = {}) => {\n  const types = unify(candidates);\n  if (isMembers(types)) {\n    return {\n      _tag: \"Union\",\n      types: sortUnionMembers(types),\n      annotations\n    };\n  }\n  if (ReadonlyArray.isNonEmptyReadonlyArray(types)) {\n    return types[0];\n  }\n  return neverKeyword;\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isUnion = ast => ast._tag === \"Union\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createLazy = (f, annotations = {}) => ({\n  _tag: \"Lazy\",\n  f: memoizeThunk(f),\n  annotations\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isLazy = ast => ast._tag === \"Lazy\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createRefinement = (from, filter, annotations = {}) => {\n  if (isTransform(from)) {\n    // recurse right\n    return createTransform(from.from, createRefinement(from.to, filter, annotations), from.transformation, from.annotations);\n  }\n  return {\n    _tag: \"Refinement\",\n    from,\n    filter,\n    annotations\n  };\n};\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isRefinement = ast => ast._tag === \"Refinement\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\nconst createTransform = (from, to, transformation, annotations = {}) => ({\n  _tag: \"Transform\",\n  from,\n  to,\n  transformation,\n  annotations\n});\n\n/**\n * @category guards\n * @since 1.0.0\n */\nconst isTransform = ast => ast._tag === \"Transform\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createFinalTransformation = (decode, encode) => ({\n  _tag: \"FinalTransformation\",\n  decode,\n  encode\n});\n\n/**\n * @category guard\n * @since 1.0.0\n */\nconst isFinalTransformation = ast => ast._tag === \"FinalTransformation\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst composeTransformation = {\n  _tag: \"ComposeTransformation\"\n};\n\n/**\n * @category guard\n * @since 1.0.0\n */\nconst isComposeTransformation = ast => ast._tag === \"ComposeTransformation\";\n\n/**\n * Represents a `PropertySignature -> PropertySignature` transformation\n *\n * The semantic of `decode` is:\n * - `none()` represents the absence of the key/value pair\n * - `some(value)` represents the presence of the key/value pair\n *\n * The semantic of `encode` is:\n * - `none()` you don't want to output the key/value pair\n * - `some(value)` you want to output the key/value pair\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createFinalPropertySignatureTransformation = (decode, encode) => ({\n  _tag: \"FinalPropertySignatureTransformation\",\n  decode,\n  encode\n});\n\n/**\n * @category guard\n * @since 1.0.0\n */\nconst isFinalPropertySignatureTransformation = ast => ast._tag === \"FinalPropertySignatureTransformation\";\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createPropertySignatureTransform = (from, to, propertySignatureTransformation) => ({\n  from,\n  to,\n  propertySignatureTransformation\n});\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst createTypeLiteralTransformation = propertySignatureTransformations => {\n  // check for duplicate property signature transformations\n  const keys = {};\n  for (const pst of propertySignatureTransformations) {\n    const key = pst.from;\n    if (keys[key]) {\n      throw new Error(`Duplicate property signature transformation ${String(key)}`);\n    }\n    keys[key] = true;\n  }\n  return {\n    _tag: \"TypeLiteralTransformation\",\n    propertySignatureTransformations\n  };\n};\n\n/**\n * @category guard\n * @since 1.0.0\n */\nconst isTypeLiteralTransformation = ast => ast._tag === \"TypeLiteralTransformation\";\n\n// -------------------------------------------------------------------------------------\n// API\n// -------------------------------------------------------------------------------------\n\n/**\n * Adds a group of annotations, potentially overwriting existing annotations.\n *\n * @since 1.0.0\n */\nconst mergeAnnotations = (ast, annotations) => ({\n  ...ast,\n  annotations: {\n    ...ast.annotations,\n    ...annotations\n  }\n});\n\n/**\n * Adds an annotation, potentially overwriting the existing annotation with the specified id.\n *\n * @since 1.0.0\n */\nconst setAnnotation = (ast, sym, value) => ({\n  ...ast,\n  annotations: {\n    ...ast.annotations,\n    [sym]: value\n  }\n});\n\n/**\n * Adds a rest element to the end of a tuple, or throws an exception if the rest element is already present.\n *\n * @since 1.0.0\n */\nconst appendRestElement = (ast, restElement) => {\n  if (Option.isSome(ast.rest)) {\n    // example: `type A = [...string[], ...number[]]` is illegal\n    throw new Error(\"A rest element cannot follow another rest element. ts(1265)\");\n  }\n  return createTuple(ast.elements, Option.some([restElement]), ast.isReadonly);\n};\n\n/**\n * Appends an element to a tuple or throws an exception in the following cases:\n * - A required element cannot follow an optional element. ts(1257)\n * - An optional element cannot follow a rest element. ts(1266)\n *\n * @since 1.0.0\n */\nconst appendElement = (ast, newElement) => {\n  if (ast.elements.some(e => e.isOptional) && !newElement.isOptional) {\n    throw new Error(\"A required element cannot follow an optional element. ts(1257)\");\n  }\n  return pipe(ast.rest, Option.match({\n    onNone: () => createTuple([...ast.elements, newElement], Option.none(), ast.isReadonly),\n    onSome: rest => {\n      if (newElement.isOptional) {\n        throw new Error(\"An optional element cannot follow a rest element. ts(1266)\");\n      }\n      return createTuple(ast.elements, Option.some([...rest, newElement.type]), ast.isReadonly);\n    }\n  }));\n};\n\n/**\n * Equivalent at runtime to the TypeScript type-level `keyof` operator.\n *\n * @since 1.0.0\n */\nconst keyof = ast => createUnion(_keyof(ast));\n\n/**\n * @since 1.0.0\n */\nconst getPropertySignatures = ast => {\n  switch (ast._tag) {\n    case \"TypeLiteral\":\n      return ast.propertySignatures;\n    case \"Lazy\":\n      return getPropertySignatures(ast.f());\n  }\n  throw new Error(`getPropertySignatures: unsupported schema (${ast._tag})`);\n};\n\n/**\n * Create a record with the specified key type and value type.\n *\n * @since 1.0.0\n */\nconst createRecord = (key, value, isReadonly) => {\n  const propertySignatures = [];\n  const indexSignatures = [];\n  const go = key => {\n    switch (key._tag) {\n      case \"NeverKeyword\":\n        break;\n      case \"StringKeyword\":\n      case \"SymbolKeyword\":\n      case \"TemplateLiteral\":\n      case \"Refinement\":\n        indexSignatures.push(createIndexSignature(key, value, isReadonly));\n        break;\n      case \"Literal\":\n        if (Predicate.isString(key.literal) || Predicate.isNumber(key.literal)) {\n          propertySignatures.push(createPropertySignature(key.literal, value, false, isReadonly));\n        } else {\n          throw new Error(`createRecord: unsupported literal ${String(key.literal)}`);\n        }\n        break;\n      case \"UniqueSymbol\":\n        propertySignatures.push(createPropertySignature(key.symbol, value, false, isReadonly));\n        break;\n      case \"Union\":\n        key.types.forEach(go);\n        break;\n      default:\n        throw new Error(`createRecord: unsupported key schema (${key._tag})`);\n    }\n  };\n  go(key);\n  return createTypeLiteral(propertySignatures, indexSignatures);\n};\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Pick`.\n *\n * @since 1.0.0\n */\nconst pick = (ast, keys) => createTypeLiteral(getPropertySignatures(ast).filter(ps => keys.includes(ps.name)), []);\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Omit`.\n *\n * @since 1.0.0\n */\nconst omit = (ast, keys) => createTypeLiteral(getPropertySignatures(ast).filter(ps => !keys.includes(ps.name)), []);\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Partial`.\n *\n * @since 1.0.0\n */\nconst partial = ast => {\n  switch (ast._tag) {\n    case \"Tuple\":\n      return createTuple(ast.elements.map(e => createElement(e.type, true)), pipe(ast.rest, Option.map(rest => [createUnion([...rest, undefinedKeyword])])), ast.isReadonly);\n    case \"TypeLiteral\":\n      return createTypeLiteral(ast.propertySignatures.map(f => createPropertySignature(f.name, f.type, true, f.isReadonly, f.annotations)), ast.indexSignatures);\n    case \"Union\":\n      return createUnion(ast.types.map(member => partial(member)));\n    case \"Lazy\":\n      return createLazy(() => partial(ast.f()));\n    case \"Declaration\":\n      throw new Error(\"`partial` cannot handle declarations\");\n    case \"Refinement\":\n      throw new Error(\"`partial` cannot handle refinements\");\n    case \"Transform\":\n      throw new Error(\"`partial` cannot handle transformations\");\n    default:\n      return ast;\n  }\n};\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Required`.\n *\n * @since 1.0.0\n */\nconst required = ast => {\n  switch (ast._tag) {\n    case \"Tuple\":\n      return createTuple(ast.elements.map(e => createElement(e.type, false)), pipe(ast.rest, Option.map(rest => {\n        const u = createUnion([...rest]);\n        return ReadonlyArray.mapNonEmpty(rest, () => u);\n      })), ast.isReadonly);\n    case \"TypeLiteral\":\n      return createTypeLiteral(ast.propertySignatures.map(f => createPropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);\n    case \"Union\":\n      return createUnion(ast.types.map(member => required(member)));\n    case \"Lazy\":\n      return createLazy(() => required(ast.f()));\n    case \"Declaration\":\n      throw new Error(\"`required` cannot handle declarations\");\n    case \"Refinement\":\n      throw new Error(\"`required` cannot handle refinements\");\n    case \"Transform\":\n      throw new Error(\"`required` cannot handle transformations\");\n    default:\n      return ast;\n  }\n};\n\n/**\n * Creates a new AST with shallow mutability applied to its properties.\n *\n * @param ast - The original AST to make properties mutable (shallowly).\n *\n * @since 1.0.0\n */\nconst mutable = ast => {\n  switch (ast._tag) {\n    case \"Tuple\":\n      return createTuple(ast.elements, ast.rest, false, ast.annotations);\n    case \"TypeLiteral\":\n      return createTypeLiteral(ast.propertySignatures.map(ps => createPropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations)), ast.indexSignatures.map(is => createIndexSignature(is.parameter, is.type, false)), ast.annotations);\n    case \"Union\":\n      return createUnion(ast.types.map(mutable), ast.annotations);\n    case \"Lazy\":\n      return createLazy(() => mutable(ast.f()), ast.annotations);\n    case \"Refinement\":\n      return createRefinement(mutable(ast.from), ast.filter, ast.annotations);\n    case \"Transform\":\n      return createTransform(mutable(ast.from), mutable(ast.to), ast.transformation, ast.annotations);\n  }\n  return ast;\n};\n\n// -------------------------------------------------------------------------------------\n// compiler harness\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n */\nconst getCompiler = match => {\n  const compile = ast => match[ast._tag](ast, compile);\n  return compile;\n};\n\n/** @internal */\nconst getToPropertySignatures = ps => ps.map(p => createPropertySignature(p.name, to(p.type), p.isOptional, p.isReadonly, p.annotations));\n\n/** @internal */\nconst getToIndexSignatures = ps => ps.map(is => createIndexSignature(is.parameter, to(is.type), is.isReadonly));\n\n/**\n * @since 1.0.0\n */\nconst to = ast => {\n  switch (ast._tag) {\n    case \"Declaration\":\n      return createDeclaration(ast.typeParameters.map(to), to(ast.type), ast.decode, ast.annotations);\n    case \"Tuple\":\n      return createTuple(ast.elements.map(e => createElement(to(e.type), e.isOptional)), Option.map(ast.rest, ReadonlyArray.mapNonEmpty(to)), ast.isReadonly, ast.annotations);\n    case \"TypeLiteral\":\n      return createTypeLiteral(getToPropertySignatures(ast.propertySignatures), getToIndexSignatures(ast.indexSignatures), ast.annotations);\n    case \"Union\":\n      return createUnion(ast.types.map(to), ast.annotations);\n    case \"Lazy\":\n      return createLazy(() => to(ast.f()), ast.annotations);\n    case \"Refinement\":\n      return createRefinement(to(ast.from), ast.filter, ast.annotations);\n    case \"Transform\":\n      return to(ast.to);\n  }\n  return ast;\n};\n\n/**\n * @since 1.0.0\n */\nconst from = ast => {\n  switch (ast._tag) {\n    case \"Declaration\":\n      return createDeclaration(ast.typeParameters.map(from), from(ast.type), ast.decode, ast.annotations);\n    case \"Tuple\":\n      return createTuple(ast.elements.map(e => createElement(from(e.type), e.isOptional)), Option.map(ast.rest, ReadonlyArray.mapNonEmpty(from)), ast.isReadonly);\n    case \"TypeLiteral\":\n      return createTypeLiteral(ast.propertySignatures.map(p => createPropertySignature(p.name, from(p.type), p.isOptional, p.isReadonly)), ast.indexSignatures.map(is => createIndexSignature(is.parameter, from(is.type), is.isReadonly)));\n    case \"Union\":\n      return createUnion(ast.types.map(from));\n    case \"Lazy\":\n      return createLazy(() => from(ast.f()));\n    case \"Refinement\":\n    case \"Transform\":\n      return from(ast.from);\n  }\n  return ast;\n};\n\n/** @internal */\nconst getCardinality = ast => {\n  switch (ast._tag) {\n    case \"Declaration\":\n      return getCardinality(ast.type);\n    case \"NeverKeyword\":\n      return 0;\n    case \"Literal\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"UniqueSymbol\":\n      return 1;\n    case \"BooleanKeyword\":\n      return 2;\n    case \"StringKeyword\":\n    case \"NumberKeyword\":\n    case \"BigIntKeyword\":\n    case \"SymbolKeyword\":\n      return 3;\n    case \"ObjectKeyword\":\n      return 5;\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return 6;\n    default:\n      return 4;\n  }\n};\nconst sortPropertySignatures = /*#__PURE__*/ReadonlyArray.sort( /*#__PURE__*/pipe(Number.Order, /*#__PURE__*/Order.mapInput(ps => getCardinality(ps.type))));\nconst WeightOrder = /*#__PURE__*/Order.tuple(Number.Order, Number.Order, Number.Order);\nconst maxWeight = /*#__PURE__*/Order.max(WeightOrder);\nconst emptyWeight = [0, 0, 0];\nconst maxWeightAll = weights => weights.reduce(maxWeight, emptyWeight);\n\n/** @internal */\nconst getWeight = ast => {\n  switch (ast._tag) {\n    case \"Tuple\":\n      {\n        const y = ast.elements.length;\n        const z = Option.isSome(ast.rest) ? ast.rest.value.length : 0;\n        return [2, y, z];\n      }\n    case \"TypeLiteral\":\n      {\n        const y = ast.propertySignatures.length;\n        const z = ast.indexSignatures.length;\n        return y + z === 0 ? [-4, 0, 0] : [4, y, z];\n      }\n    case \"Declaration\":\n      {\n        const [_, y, z] = getWeight(ast.type);\n        return [6, y, z];\n      }\n    case \"Lazy\":\n      return [8, 0, 0];\n    case \"Union\":\n      return maxWeightAll(ast.types.map(getWeight));\n    case \"Refinement\":\n      {\n        const [x, y, z] = getWeight(ast.from);\n        return [x + 1, y, z];\n      }\n    case \"Transform\":\n      return getWeight(ast.from);\n    case \"ObjectKeyword\":\n      return [-2, 0, 0];\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return [-4, 0, 0];\n    default:\n      return emptyWeight;\n  }\n};\nconst sortUnionMembers = /*#__PURE__*/ReadonlyArray.sort( /*#__PURE__*/Order.reverse( /*#__PURE__*/Order.mapInput(WeightOrder, getWeight)));\nconst unify = candidates => {\n  let out = pipe(candidates, ReadonlyArray.flatMap(ast => {\n    switch (ast._tag) {\n      case \"NeverKeyword\":\n        return [];\n      case \"Union\":\n        return ast.types;\n      default:\n        return [ast];\n    }\n  }));\n  if (out.some(isAnyKeyword)) {\n    return [anyKeyword];\n  }\n  if (out.some(isUnknownKeyword)) {\n    return [unknownKeyword];\n  }\n  let i;\n  if ((i = out.findIndex(isStringKeyword)) !== -1) {\n    out = out.filter((m, j) => j === i || !isStringKeyword(m) && !(isLiteral(m) && typeof m.literal === \"string\"));\n  }\n  if ((i = out.findIndex(isNumberKeyword)) !== -1) {\n    out = out.filter((m, j) => j === i || !isNumberKeyword(m) && !(isLiteral(m) && typeof m.literal === \"number\"));\n  }\n  if ((i = out.findIndex(isBooleanKeyword)) !== -1) {\n    out = out.filter((m, j) => j === i || !isBooleanKeyword(m) && !(isLiteral(m) && typeof m.literal === \"boolean\"));\n  }\n  if ((i = out.findIndex(isBigIntKeyword)) !== -1) {\n    out = out.filter((m, j) => j === i || !isBigIntKeyword(m) && !(isLiteral(m) && typeof m.literal === \"bigint\"));\n  }\n  if ((i = out.findIndex(isSymbolKeyword)) !== -1) {\n    out = out.filter((m, j) => j === i || !isSymbolKeyword(m) && !isUniqueSymbol(m));\n  }\n  return out;\n};\n\n/** @internal */\nconst getParameterBase = ast => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"SymbolKeyword\":\n    case \"TemplateLiteral\":\n      return ast;\n    case \"Refinement\":\n      return getParameterBase(ast.from);\n  }\n};\nconst _keyof = ast => {\n  switch (ast._tag) {\n    case \"Declaration\":\n      return _keyof(ast.type);\n    case \"TypeLiteral\":\n      return ast.propertySignatures.map(p => Predicate.isSymbol(p.name) ? createUniqueSymbol(p.name) : createLiteral(p.name)).concat(ast.indexSignatures.map(is => getParameterBase(is.parameter)));\n    case \"Lazy\":\n      return _keyof(ast.f());\n    default:\n      throw new Error(`keyof: unsupported schema (${ast._tag})`);\n  }\n};\n\nexport { BrandAnnotationId, DescriptionAnnotationId, DocumentationAnnotationId, ExamplesAnnotationId, IdentifierAnnotationId, JSONSchemaAnnotationId, MessageAnnotationId, TitleAnnotationId, TypeAnnotationId, anyKeyword, appendElement, appendRestElement, bigIntKeyword, booleanKeyword, composeTransformation, createDeclaration, createElement, createEnums, createFinalPropertySignatureTransformation, createFinalTransformation, createIndexSignature, createLazy, createLiteral, createPropertySignature, createPropertySignatureTransform, createRecord, createRefinement, createTemplateLiteral, createTransform, createTuple, createTypeLiteral, createTypeLiteralTransformation, createUnion, createUniqueSymbol, from, getAnnotation, getCardinality, getCompiler, getParameterBase, getPropertySignatures, getToIndexSignatures, getToPropertySignatures, getWeight, isAnyKeyword, isBigIntKeyword, isBooleanKeyword, isComposeTransformation, isDeclaration, isEnums, isFinalPropertySignatureTransformation, isFinalTransformation, isLazy, isLiteral, isNeverKeyword, isNumberKeyword, isObjectKeyword, isParameter, isRefinement, isStringKeyword, isSymbolKeyword, isTemplateLiteral, isTransform, isTuple, isTypeLiteral, isTypeLiteralTransformation, isUndefinedKeyword, isUnion, isUniqueSymbol, isUnknownKeyword, isVoidKeyword, keyof, mergeAnnotations, mutable, neverKeyword, numberKeyword, objectKeyword, omit, partial, pick, required, setAnnotation, stringKeyword, symbolKeyword, to, undefinedKeyword, unknownKeyword, voidKeyword };\n","import * as Effect from 'effect/Effect';\nimport * as Either from 'effect/Either';\nimport * as Option from 'effect/Option';\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst parseError = errors => ({\n  _tag: \"ParseError\",\n  errors\n});\n\n/**\n * `ParseErrors` is a type that represents the different types of errors that can occur when decoding a value.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * The `Type` variant of the `ParseError` type represents an error that occurs when the `actual` value is not of the expected type.\n * The `expected` field specifies the expected type, and the `actual` field contains the value that caused the error.\n * This error can occur when trying to decode a value using a schema that is only able to decode values of a specific type,\n * and the actual value is not of that type. For example, if you are using a schema to decode a string value and the actual value\n * is a number, a `Type` decode error would be returned.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * The `Forbidden` variant of the `ParseError` type represents an error that occurs when an Effect is encounter but disallowed from execution.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst type = (expected, actual, message) => ({\n  _tag: \"Type\",\n  expected,\n  actual,\n  message: Option.fromNullable(message)\n});\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst forbidden = {\n  _tag: \"Forbidden\"\n};\n\n/**\n * The `Index` decode error indicates that there was an error at a specific index in an array or tuple.\n * The `errors` field contains the decode errors for that index. This error is typically used when decoding an array or tuple\n * with a schema that has constraints on the elements. For example, you might use an `Index` decode error to indicate\n * that a specific element in an array did not match the expected type or value.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst index = (index, errors) => ({\n  _tag: \"Index\",\n  index,\n  errors\n});\n\n/**\n * The `Key` variant of the `ParseError` type represents an error that occurs when a key in an object is invalid.\n * This error typically occurs when the `actual` value is not a valid key type (e.g. a string or number)\n * or when the key is not present in the object being decoded. In either case, the `key` field of the error will contain\n * the invalid key value. This error is typically used in combination with the `Unexpected` error,\n * which indicates that an unexpected key was found in the object being decoded.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst key = (key, errors) => ({\n  _tag: \"Key\",\n  key,\n  errors\n});\n\n/**\n * Error that occurs when a required key or index is missing.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst missing = {\n  _tag: \"Missing\"\n};\n\n/**\n * Error that occurs when an unexpected key or index is present.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst unexpected = actual => ({\n  _tag: \"Unexpected\",\n  actual\n});\n\n/**\n * Error that occurs when a member in a union has an error.\n *\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst unionMember = errors => ({\n  _tag: \"UnionMember\",\n  errors\n});\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst success = Either.right;\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst fail = Either.left;\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst failure = e => fail(parseError([e]));\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst failures = es => Either.left(parseError(es));\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nconst eitherOrUndefined = self => {\n  const s = self;\n  if (s[\"_tag\"] === \"Left\" || s[\"_tag\"] === \"Right\") {\n    return s;\n  }\n};\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nconst flatMap = (self, f) => {\n  const s = self;\n  if (s[\"_tag\"] === \"Left\") {\n    return s;\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return f(s.right);\n  }\n  return Effect.flatMap(self, f);\n};\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nconst map = (self, f) => {\n  const s = self;\n  if (s[\"_tag\"] === \"Left\") {\n    return s;\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return Either.right(f(s.right));\n  }\n  return Effect.map(self, f);\n};\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nconst mapLeft = (self, f) => {\n  const s = self;\n  if (s[\"_tag\"] === \"Left\") {\n    return Either.left(f(s.left));\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return s;\n  }\n  return Effect.mapError(self, f);\n};\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nconst bimap = (self, f, g) => {\n  const s = self;\n  if (s[\"_tag\"] === \"Left\") {\n    return Either.left(f(s.left));\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return Either.right(g(s.right));\n  }\n  return Effect.mapBoth(self, {\n    onFailure: f,\n    onSuccess: g\n  });\n};\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nconst orElse = (self, f) => {\n  const s = self;\n  if (s[\"_tag\"] === \"Left\") {\n    return f(s.left);\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return s;\n  }\n  return Effect.catchAll(self, f);\n};\n\nexport { bimap, eitherOrUndefined, fail, failure, failures, flatMap, forbidden, index, key, map, mapLeft, missing, orElse, parseError, success, type, unexpected, unionMember };\n","import * as Option from 'effect/Option';\nimport { getAnnotation, MessageAnnotationId, TitleAnnotationId, IdentifierAnnotationId, DescriptionAnnotationId } from '../../AST/dist/effect-schema-AST.esm.js';\n\n/**\n * @since 1.0.0\n */\nconst make = (value, forest = []) => ({\n  value,\n  forest\n});\n\n/**\n * @category formatting\n * @since 1.0.0\n */\nconst formatErrors = errors => drawTree(make(`error(s) found`, errors.map(go)));\nconst drawTree = tree => tree.value + draw(\"\\n\", tree.forest);\nconst draw = (indentation, forest) => {\n  let r = \"\";\n  const len = forest.length;\n  let tree;\n  for (let i = 0; i < len; i++) {\n    tree = forest[i];\n    const isLast = i === len - 1;\n    r += indentation + (isLast ? \"\" : \"\") + \" \" + tree.value;\n    r += draw(indentation + (len > 1 && !isLast ? \"  \" : \"   \"), tree.forest);\n  }\n  return r;\n};\n\n/** @internal */\nconst formatActual = actual => {\n  if (actual === undefined || actual === null || typeof actual === \"number\" || typeof actual === \"symbol\" || actual instanceof Date) {\n    return String(actual);\n  }\n  if (typeof actual === \"bigint\") {\n    return String(actual) + \"n\";\n  }\n  try {\n    return JSON.stringify(actual);\n  } catch (e) {\n    return String(actual);\n  }\n};\nconst formatTemplateLiteralSpan = span => {\n  switch (span.type._tag) {\n    case \"StringKeyword\":\n      return \"${string}\";\n    case \"NumberKeyword\":\n      return \"${number}\";\n  }\n};\nconst formatTemplateLiteral = ast => ast.head + ast.spans.map(span => formatTemplateLiteralSpan(span) + span.literal).join(\"\");\nconst getMessageAnnotation = /*#__PURE__*/getAnnotation(MessageAnnotationId);\nconst getTitleAnnotation = /*#__PURE__*/getAnnotation(TitleAnnotationId);\nconst getIdentifierAnnotation = /*#__PURE__*/getAnnotation(IdentifierAnnotationId);\nconst getDescriptionAnnotation = /*#__PURE__*/getAnnotation(DescriptionAnnotationId);\nconst getExpected = ast => getIdentifierAnnotation(ast).pipe(Option.orElse(() => getTitleAnnotation(ast)), Option.orElse(() => getDescriptionAnnotation(ast)));\n\n/** @internal */\nconst formatExpected = ast => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"SymbolKeyword\":\n    case \"ObjectKeyword\":\n    case \"AnyKeyword\":\n    case \"UnknownKeyword\":\n    case \"VoidKeyword\":\n    case \"NeverKeyword\":\n      return Option.getOrElse(getExpected(ast), () => ast._tag);\n    case \"Literal\":\n      return Option.getOrElse(getExpected(ast), () => formatActual(ast.literal));\n    case \"UniqueSymbol\":\n      return Option.getOrElse(getExpected(ast), () => formatActual(ast.symbol));\n    case \"Union\":\n      return ast.types.map(formatExpected).join(\" or \");\n    case \"TemplateLiteral\":\n      return Option.getOrElse(getExpected(ast), () => formatTemplateLiteral(ast));\n    case \"Tuple\":\n      return Option.getOrElse(getExpected(ast), () => \"<anonymous tuple or array schema>\");\n    case \"TypeLiteral\":\n      return Option.getOrElse(getExpected(ast), () => \"<anonymous type literal schema>\");\n    case \"Enums\":\n      return Option.getOrElse(getExpected(ast), () => ast.enums.map((_, value) => JSON.stringify(value)).join(\" | \"));\n    case \"Lazy\":\n      return Option.getOrElse(getExpected(ast), () => \"<anonymous lazy schema>\");\n    case \"Declaration\":\n      return Option.getOrElse(getExpected(ast), () => \"<anonymous declaration schema>\");\n    case \"Refinement\":\n      return Option.getOrElse(getExpected(ast), () => \"<anonymous refinement schema>\");\n    case \"Transform\":\n      return Option.getOrElse(getExpected(ast), () => `${formatExpected(ast.from)} <-> ${formatExpected(ast.to)}`);\n  }\n};\nconst isCollapsible = (es, errors) => es.length === 1 && es[0].forest.length !== 0 && errors[0]._tag !== \"UnionMember\";\n\n/** @internal */\nconst getMessage = e => getMessageAnnotation(e.expected).pipe(Option.map(annotation => annotation(e.actual)), Option.orElse(() => e.message), Option.getOrElse(() => `Expected ${formatExpected(e.expected)}, actual ${formatActual(e.actual)}`));\nconst go = e => {\n  switch (e._tag) {\n    case \"Type\":\n      return make(getMessage(e));\n    case \"Forbidden\":\n      return make(\"is forbidden\");\n    case \"Index\":\n      {\n        const es = e.errors.map(go);\n        if (isCollapsible(es, e.errors)) {\n          return make(`[${e.index}]${es[0].value}`, es[0].forest);\n        }\n        return make(`[${e.index}]`, es);\n      }\n    case \"Unexpected\":\n      return make(`is unexpected`);\n    case \"Key\":\n      {\n        const es = e.errors.map(go);\n        if (isCollapsible(es, e.errors)) {\n          return make(`[${formatActual(e.key)}]${es[0].value}`, es[0].forest);\n        }\n        return make(`[${formatActual(e.key)}]`, es);\n      }\n    case \"Missing\":\n      return make(\"is missing\");\n    case \"UnionMember\":\n      return make(\"union member\", e.errors.map(go));\n  }\n};\n\nexport { formatActual, formatErrors, formatExpected, getMessage };\n","import * as Effect from 'effect/Effect';\nimport * as Either from 'effect/Either';\nimport { pipe } from 'effect/Function';\nimport * as Option from 'effect/Option';\nimport * as Predicate from 'effect/Predicate';\nimport * as ReadonlyArray from 'effect/ReadonlyArray';\nimport { to, from, isLiteral, neverKeyword, createUnion, getParameterBase, isSymbolKeyword, isRefinement, createTuple, DescriptionAnnotationId, unknownKeyword, createTypeLiteral, createIndexSignature, stringKeyword, symbolKeyword, isStringKeyword, isNumberKeyword } from '../../AST/dist/effect-schema-AST.esm.js';\nimport { ownKeys, getKeysForIndexSignature, memoizeThunk } from '../../internal/common.esm.js';\nimport { map, success, key, type, missing, eitherOrUndefined, unionMember, failure, unexpected, failures, index, flatMap, fail, forbidden } from '../../ParseResult/dist/effect-schema-ParseResult.esm.js';\nimport { formatErrors } from '../../TreeFormatter/dist/effect-schema-TreeFormatter.esm.js';\n\n/**\n * @since 1.0.0\n */\nconst getEither = (ast, isDecoding) => go(ast, isDecoding);\nconst getSync = (ast, isDecoding) => {\n  const parser = getEither(ast, isDecoding);\n  return (input, options) => {\n    const result = parser(input, options);\n    if (Either.isLeft(result)) {\n      throw new Error(formatErrors(result.left.errors));\n    }\n    return result.right;\n  };\n};\nconst getOption = (ast, isDecoding) => {\n  const parser = getEither(ast, isDecoding);\n  return (input, options) => Option.getRight(parser(input, options));\n};\nconst getEffect = (ast, isDecoding) => {\n  const parser = go(ast, isDecoding);\n  return (input, options) => parser(input, {\n    ...options,\n    isEffectAllowed: true\n  });\n};\nconst getPromise = (ast, isDecoding) => {\n  const parser = getEffect(ast, isDecoding);\n  return (input, options) => Effect.runPromise(parser(input, options));\n};\n\n/**\n * @category parsing\n * @since 1.0.0\n */\nconst parseSync = schema => getSync(schema.ast, true);\n\n/**\n * @category parsing\n * @since 1.0.0\n */\nconst parseOption = schema => getOption(schema.ast, true);\n\n/**\n * @category parsing\n * @since 1.0.0\n */\nconst parseEither = schema => getEither(schema.ast, true);\n\n/**\n * @category parsing\n * @since 1.0.0\n */\nconst parsePromise = schema => getPromise(schema.ast, true);\n\n/**\n * @category parsing\n * @since 1.0.0\n */\nconst parse = schema => getEffect(schema.ast, true);\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nconst decodeSync = parseSync;\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nconst decodeOption = parseOption;\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nconst decodeEither = parseEither;\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nconst decodePromise = parsePromise;\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nconst decode = parse;\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst validateSync = schema => getSync(to(schema.ast), true);\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst validateOption = schema => getOption(to(schema.ast), true);\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst validateEither = schema => getEither(to(schema.ast), true);\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst validatePromise = schema => getPromise(to(schema.ast), true);\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst validate = schema => getEffect(to(schema.ast), true);\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst is = schema => {\n  const getEither = validateEither(schema);\n  return a => Either.isRight(getEither(a));\n};\n\n/**\n * @category validation\n * @since 1.0.0\n */\nconst asserts = schema => {\n  const get = validateSync(schema);\n  return (a, options) => {\n    get(a, options);\n  };\n};\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nconst encodeSync = schema => getSync(schema.ast, false);\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nconst encodeOption = schema => getOption(schema.ast, false);\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nconst encodeEither = schema => getEither(schema.ast, false);\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nconst encodePromise = schema => getPromise(schema.ast, false);\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nconst encode = schema => getEffect(schema.ast, false);\n/**\n * @since 1.0.0\"\n */\nconst defaultParseOption = {};\nconst go = (ast, isDecoding) => {\n  switch (ast._tag) {\n    case \"Refinement\":\n      {\n        if (isDecoding) {\n          const from = go(ast.from, true);\n          return (i, options) => handleForbidden(flatMap(from(i, options), a => Option.match(ast.filter(a, options ?? defaultParseOption, ast), {\n            onNone: () => success(a),\n            onSome: fail\n          })), options);\n        } else {\n          const from = go(to(ast), true);\n          const to$1 = go(dropRightRefinement(ast.from), false);\n          return (i, options) => handleForbidden(flatMap(from(i, options), a => to$1(a, options)), options);\n        }\n      }\n    case \"Transform\":\n      {\n        const transform = getFinalTransformation(ast.transformation, isDecoding);\n        const from = isDecoding ? go(ast.from, true) : go(ast.to, false);\n        const to = isDecoding ? go(ast.to, true) : go(ast.from, false);\n        return (i1, options) => handleForbidden(flatMap(from(i1, options), a => flatMap(transform(a, options ?? defaultParseOption, ast), i2 => to(i2, options))), options);\n      }\n    case \"Declaration\":\n      {\n        const parse = ast.decode(isDecoding, ...ast.typeParameters);\n        return (i, options) => handleForbidden(parse(i, options ?? defaultParseOption, ast), options);\n      }\n    case \"Literal\":\n      return fromRefinement(ast, u => u === ast.literal);\n    case \"UniqueSymbol\":\n      return fromRefinement(ast, u => u === ast.symbol);\n    case \"UndefinedKeyword\":\n      return fromRefinement(ast, Predicate.isUndefined);\n    case \"VoidKeyword\":\n      return fromRefinement(ast, Predicate.isUndefined);\n    case \"NeverKeyword\":\n      return fromRefinement(ast, Predicate.isNever);\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return success;\n    case \"StringKeyword\":\n      return fromRefinement(ast, Predicate.isString);\n    case \"NumberKeyword\":\n      return fromRefinement(ast, Predicate.isNumber);\n    case \"BooleanKeyword\":\n      return fromRefinement(ast, Predicate.isBoolean);\n    case \"BigIntKeyword\":\n      return fromRefinement(ast, Predicate.isBigInt);\n    case \"SymbolKeyword\":\n      return fromRefinement(ast, Predicate.isSymbol);\n    case \"ObjectKeyword\":\n      return fromRefinement(ast, Predicate.isObject);\n    case \"Enums\":\n      return fromRefinement(ast, u => ast.enums.some(([_, value]) => value === u));\n    case \"TemplateLiteral\":\n      {\n        const regex = getTemplateLiteralRegex(ast);\n        return fromRefinement(ast, u => Predicate.isString(u) && regex.test(u));\n      }\n    case \"Tuple\":\n      {\n        const elements = ast.elements.map(e => go(e.type, isDecoding));\n        const rest = pipe(ast.rest, Option.map(ReadonlyArray.mapNonEmpty(ast => go(ast, isDecoding))));\n        let requiredLen = ast.elements.filter(e => !e.isOptional).length;\n        if (Option.isSome(ast.rest)) {\n          requiredLen += ast.rest.value.length - 1;\n        }\n        return (input, options) => {\n          if (!Array.isArray(input)) {\n            return failure(type(unknownArray, input));\n          }\n          const allErrors = options?.errors === \"all\";\n          const es = [];\n          let stepKey = 0;\n          // ---------------------------------------------\n          // handle missing indexes\n          // ---------------------------------------------\n          const len = input.length;\n          for (let i = len; i <= requiredLen - 1; i++) {\n            const e = index(i, [missing]);\n            if (allErrors) {\n              es.push([stepKey++, e]);\n              continue;\n            } else {\n              return failure(e);\n            }\n          }\n\n          // ---------------------------------------------\n          // handle excess indexes\n          // ---------------------------------------------\n          if (Option.isNone(ast.rest)) {\n            for (let i = ast.elements.length; i <= len - 1; i++) {\n              const e = index(i, [unexpected(input[i])]);\n              if (allErrors) {\n                es.push([stepKey++, e]);\n                continue;\n              } else {\n                return failures(mutableAppend(sortByIndex(es), e));\n              }\n            }\n          }\n          const output = [];\n          let i = 0;\n          let queue = undefined;\n\n          // ---------------------------------------------\n          // handle elements\n          // ---------------------------------------------\n          for (; i < elements.length; i++) {\n            if (len < i + 1) {\n              // the input element is missing...\n              if (ast.elements[i].isOptional) {\n                continue;\n              }\n            } else {\n              const parser = elements[i];\n              const te = parser(input[i], options);\n              const eu = eitherOrUndefined(te);\n              if (eu) {\n                if (Either.isLeft(eu)) {\n                  // the input element is present but is not valid\n                  const e = index(i, eu.left.errors);\n                  if (allErrors) {\n                    es.push([stepKey++, e]);\n                    continue;\n                  } else {\n                    return failures(mutableAppend(sortByIndex(es), e));\n                  }\n                }\n                output.push([stepKey++, eu.right]);\n              } else {\n                const nk = stepKey++;\n                const index$1 = i;\n                if (!queue) {\n                  queue = [];\n                }\n                queue.push(({\n                  es,\n                  output\n                }) => Effect.flatMap(Effect.either(te), t => {\n                  if (Either.isLeft(t)) {\n                    // the input element is present but is not valid\n                    const e = index(index$1, t.left.errors);\n                    if (allErrors) {\n                      es.push([nk, e]);\n                      return Effect.unit;\n                    } else {\n                      return failures(mutableAppend(sortByIndex(es), e));\n                    }\n                  }\n                  output.push([nk, t.right]);\n                  return Effect.unit;\n                }));\n              }\n            }\n          }\n          // ---------------------------------------------\n          // handle rest element\n          // ---------------------------------------------\n          if (Option.isSome(rest)) {\n            const head = ReadonlyArray.headNonEmpty(rest.value);\n            const tail = ReadonlyArray.tailNonEmpty(rest.value);\n            for (; i < len - tail.length; i++) {\n              const te = head(input[i], options);\n              const eu = eitherOrUndefined(te);\n              if (eu) {\n                if (Either.isLeft(eu)) {\n                  const e = index(i, eu.left.errors);\n                  if (allErrors) {\n                    es.push([stepKey++, e]);\n                    continue;\n                  } else {\n                    return failures(mutableAppend(sortByIndex(es), e));\n                  }\n                } else {\n                  output.push([stepKey++, eu.right]);\n                }\n              } else {\n                const nk = stepKey++;\n                const index$1 = i;\n                if (!queue) {\n                  queue = [];\n                }\n                queue.push(({\n                  es,\n                  output\n                }) => Effect.flatMap(Effect.either(te), t => {\n                  if (Either.isLeft(t)) {\n                    const e = index(index$1, t.left.errors);\n                    if (allErrors) {\n                      es.push([nk, e]);\n                      return Effect.unit;\n                    } else {\n                      return failures(mutableAppend(sortByIndex(es), e));\n                    }\n                  } else {\n                    output.push([nk, t.right]);\n                    return Effect.unit;\n                  }\n                }));\n              }\n            }\n            // ---------------------------------------------\n            // handle post rest elements\n            // ---------------------------------------------\n            for (let j = 0; j < tail.length; j++) {\n              i += j;\n              if (len < i + 1) {\n                continue;\n              } else {\n                const te = tail[j](input[i], options);\n                const eu = eitherOrUndefined(te);\n                if (eu) {\n                  if (Either.isLeft(eu)) {\n                    // the input element is present but is not valid\n                    const e = index(i, eu.left.errors);\n                    if (allErrors) {\n                      es.push([stepKey++, e]);\n                      continue;\n                    } else {\n                      return failures(mutableAppend(sortByIndex(es), e));\n                    }\n                  }\n                  output.push([stepKey++, eu.right]);\n                } else {\n                  const nk = stepKey++;\n                  const index$1 = i;\n                  if (!queue) {\n                    queue = [];\n                  }\n                  queue.push(({\n                    es,\n                    output\n                  }) => Effect.flatMap(Effect.either(te), t => {\n                    if (Either.isLeft(t)) {\n                      // the input element is present but is not valid\n                      const e = index(index$1, t.left.errors);\n                      if (allErrors) {\n                        es.push([nk, e]);\n                        return Effect.unit;\n                      } else {\n                        return failures(mutableAppend(sortByIndex(es), e));\n                      }\n                    }\n                    output.push([nk, t.right]);\n                    return Effect.unit;\n                  }));\n                }\n              }\n            }\n          }\n\n          // ---------------------------------------------\n          // compute output\n          // ---------------------------------------------\n          const computeResult = ({\n            es,\n            output\n          }) => ReadonlyArray.isNonEmptyArray(es) ? failures(sortByIndex(es)) : success(sortByIndex(output));\n          if (queue && queue.length > 0) {\n            const cqueue = queue;\n            return Effect.suspend(() => {\n              const state = {\n                es: Array.from(es),\n                output: Array.from(output)\n              };\n              return Effect.flatMap(Effect.forEach(cqueue, f => f(state), {\n                concurrency: \"unbounded\",\n                discard: true\n              }), () => computeResult(state));\n            });\n          }\n          return computeResult({\n            output,\n            es\n          });\n        };\n      }\n    case \"TypeLiteral\":\n      {\n        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n          return fromRefinement(ast, Predicate.isNotNullable);\n        }\n        const propertySignatures = [];\n        const expectedKeys = {};\n        for (const ps of ast.propertySignatures) {\n          propertySignatures.push(go(ps.type, isDecoding));\n          expectedKeys[ps.name] = null;\n        }\n        const indexSignatures = [];\n        const expectedKeyTypes = {};\n        for (const is of ast.indexSignatures) {\n          indexSignatures.push([go(is.parameter, isDecoding), go(is.type, isDecoding)]);\n          const base = getParameterBase(is.parameter);\n          if (isSymbolKeyword(base)) {\n            expectedKeyTypes.symbol = true;\n          } else {\n            expectedKeyTypes.string = true;\n          }\n        }\n        return (input, options) => {\n          if (!Predicate.isRecord(input)) {\n            return failure(type(unknownRecord, input));\n          }\n          const allErrors = options?.errors === \"all\";\n          const es = [];\n          let stepKey = 0;\n\n          // ---------------------------------------------\n          // handle excess properties\n          // ---------------------------------------------\n          const onExcessPropertyError = options?.onExcessProperty === \"error\";\n          if (onExcessPropertyError) {\n            for (const key$1 of ownKeys(input)) {\n              if (!Object.prototype.hasOwnProperty.call(expectedKeys, key$1)) {\n                if (!(typeof key$1 in expectedKeyTypes)) {\n                  const e = key(key$1, [unexpected(input[key$1])]);\n                  if (allErrors) {\n                    es.push([stepKey++, e]);\n                    continue;\n                  } else {\n                    return failures(mutableAppend(sortByIndex(es), e));\n                  }\n                }\n              }\n            }\n          }\n\n          // ---------------------------------------------\n          // handle property signatures\n          // ---------------------------------------------\n          const output = {};\n          let queue = undefined;\n          for (let i = 0; i < propertySignatures.length; i++) {\n            const ps = ast.propertySignatures[i];\n            const parser = propertySignatures[i];\n            const name = ps.name;\n            if (Object.prototype.hasOwnProperty.call(input, name)) {\n              const te = parser(input[name], options);\n              const eu = eitherOrUndefined(te);\n              if (eu) {\n                if (Either.isLeft(eu)) {\n                  // the input key is present but is not valid\n                  const e = key(name, eu.left.errors);\n                  if (allErrors) {\n                    es.push([stepKey++, e]);\n                    continue;\n                  } else {\n                    return failures(mutableAppend(sortByIndex(es), e));\n                  }\n                }\n                output[name] = eu.right;\n              } else {\n                const nk = stepKey++;\n                const index = name;\n                if (!queue) {\n                  queue = [];\n                }\n                queue.push(({\n                  es,\n                  output\n                }) => Effect.flatMap(Effect.either(te), t => {\n                  if (Either.isLeft(t)) {\n                    // the input key is present but is not valid\n                    const e = key(index, t.left.errors);\n                    if (allErrors) {\n                      es.push([nk, e]);\n                      return Effect.unit;\n                    } else {\n                      return failures(mutableAppend(sortByIndex(es), e));\n                    }\n                  }\n                  output[index] = t.right;\n                  return Effect.unit;\n                }));\n              }\n            } else {\n              // ---------------------------------------------\n              // handle missing keys\n              // ---------------------------------------------\n              if (!ps.isOptional) {\n                const e = key(name, [missing]);\n                if (allErrors) {\n                  es.push([stepKey++, e]);\n                  continue;\n                } else {\n                  return failure(e);\n                }\n              }\n            }\n          }\n\n          // ---------------------------------------------\n          // handle index signatures\n          // ---------------------------------------------\n          for (let i = 0; i < indexSignatures.length; i++) {\n            const parameter = indexSignatures[i][0];\n            const type = indexSignatures[i][1];\n            const keys = getKeysForIndexSignature(input, ast.indexSignatures[i].parameter);\n            for (const key$1 of keys) {\n              if (!Object.prototype.hasOwnProperty.call(expectedKeys, key$1)) {\n                // ---------------------------------------------\n                // handle keys\n                // ---------------------------------------------\n                const keu = eitherOrUndefined(parameter(key$1, options));\n                if (keu) {\n                  if (Either.isLeft(keu)) {\n                    const e = key(key$1, keu.left.errors);\n                    if (allErrors) {\n                      es.push([stepKey++, e]);\n                      continue;\n                    } else {\n                      return failures(mutableAppend(sortByIndex(es), e));\n                    }\n                  }\n                }\n                // there's no else here because index signature parameters are restricted to primitives\n\n                // ---------------------------------------------\n                // handle values\n                // ---------------------------------------------\n                const vpr = type(input[key$1], options);\n                const veu = eitherOrUndefined(vpr);\n                if (veu) {\n                  if (Either.isLeft(veu)) {\n                    const e = key(key$1, veu.left.errors);\n                    if (allErrors) {\n                      es.push([stepKey++, e]);\n                      continue;\n                    } else {\n                      return failures(mutableAppend(sortByIndex(es), e));\n                    }\n                  } else {\n                    if (!Object.prototype.hasOwnProperty.call(expectedKeys, key$1)) {\n                      output[key$1] = veu.right;\n                    }\n                  }\n                } else {\n                  const nk = stepKey++;\n                  const index = key$1;\n                  if (!queue) {\n                    queue = [];\n                  }\n                  queue.push(({\n                    es,\n                    output\n                  }) => Effect.flatMap(Effect.either(vpr), tv => {\n                    if (Either.isLeft(tv)) {\n                      const e = key(index, tv.left.errors);\n                      if (allErrors) {\n                        es.push([nk, e]);\n                        return Effect.unit;\n                      } else {\n                        return failures(mutableAppend(sortByIndex(es), e));\n                      }\n                    } else {\n                      if (!Object.prototype.hasOwnProperty.call(expectedKeys, key$1)) {\n                        output[key$1] = tv.right;\n                      }\n                      return Effect.unit;\n                    }\n                  }));\n                }\n              }\n            }\n          }\n          // ---------------------------------------------\n          // compute output\n          // ---------------------------------------------\n          const computeResult = ({\n            es,\n            output\n          }) => ReadonlyArray.isNonEmptyArray(es) ? failures(sortByIndex(es)) : success(output);\n          if (queue && queue.length > 0) {\n            const cqueue = queue;\n            return Effect.suspend(() => {\n              const state = {\n                es: Array.from(es),\n                output: Object.assign({}, output)\n              };\n              return Effect.flatMap(Effect.forEach(cqueue, f => f(state), {\n                concurrency: \"unbounded\",\n                discard: true\n              }), () => computeResult(state));\n            });\n          }\n          return computeResult({\n            es,\n            output\n          });\n        };\n      }\n    case \"Union\":\n      {\n        const searchTree = _getSearchTree(ast.types);\n        const ownKeys$1 = ownKeys(searchTree.keys);\n        const len = ownKeys$1.length;\n        const map = new Map();\n        for (let i = 0; i < ast.types.length; i++) {\n          map.set(ast.types[i], go(ast.types[i], isDecoding));\n        }\n        return (input, options) => {\n          const es = [];\n          let stepKey = 0;\n          let candidates = [];\n          if (len > 0) {\n            // if there is at least one key then input must be an object\n            if (Predicate.isRecord(input)) {\n              for (let i = 0; i < len; i++) {\n                const name = ownKeys$1[i];\n                const buckets = searchTree.keys[name].buckets;\n                // for each property that should contain a literal, check if the input contains that property\n                if (Object.prototype.hasOwnProperty.call(input, name)) {\n                  const literal = String(input[name]);\n                  // check that the value obtained from the input for the property corresponds to an existing bucket\n                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                    // retrive the minimal set of candidates for decoding\n                    candidates = candidates.concat(buckets[literal]);\n                  } else {\n                    es.push([stepKey++, key(name, [type(searchTree.keys[name].ast, input[name])])]);\n                  }\n                } else {\n                  es.push([stepKey++, key(name, [missing])]);\n                }\n              }\n            } else {\n              es.push([stepKey++, type(unknownRecord, input)]);\n            }\n          }\n          if (searchTree.otherwise.length > 0) {\n            candidates = candidates.concat(searchTree.otherwise);\n          }\n          let queue = undefined;\n          for (let i = 0; i < candidates.length; i++) {\n            const pr = map.get(candidates[i])(input, options);\n            // the members of a union are ordered based on which one should be decoded first,\n            // therefore if one member has added a task, all subsequent members must\n            // also add a task to the queue even if they are synchronous\n            const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : undefined;\n            if (eu) {\n              if (Either.isRight(eu)) {\n                return success(eu.right);\n              } else {\n                es.push([stepKey++, unionMember(eu.left.errors)]);\n              }\n            } else {\n              const nk = stepKey++;\n              if (!queue) {\n                queue = [];\n              }\n              queue.push(state => Effect.suspend(() => {\n                if (\"finalResult\" in state) {\n                  return Effect.unit;\n                } else {\n                  return Effect.flatMap(Effect.either(pr), t => {\n                    if (Either.isRight(t)) {\n                      state.finalResult = success(t.right);\n                    } else {\n                      state.es.push([nk, unionMember(t.left.errors)]);\n                    }\n                    return Effect.unit;\n                  });\n                }\n              }));\n            }\n          }\n\n          // ---------------------------------------------\n          // compute output\n          // ---------------------------------------------\n          const computeResult = es => ReadonlyArray.isNonEmptyArray(es) ? failures(sortByIndex(es)) :\n          // this should never happen\n          failure(type(neverKeyword, input));\n          if (queue && queue.length > 0) {\n            const cqueue = queue;\n            return Effect.suspend(() => {\n              const state = {\n                es: Array.from(es)\n              };\n              return Effect.flatMap(Effect.forEach(cqueue, f => f(state), {\n                concurrency: 1,\n                discard: true\n              }), () => {\n                if (\"finalResult\" in state) {\n                  return state.finalResult;\n                }\n                return computeResult(state.es);\n              });\n            });\n          }\n          return computeResult(es);\n        };\n      }\n    case \"Lazy\":\n      {\n        const get = memoizeThunk(() => go(ast.f(), isDecoding));\n        return (a, options) => get()(a, options);\n      }\n  }\n};\nconst fromRefinement = (ast, refinement) => u => refinement(u) ? success(u) : failure(type(ast, u));\n\n/** @internal */\nconst _getLiterals = ast => {\n  switch (ast._tag) {\n    case \"Declaration\":\n      return _getLiterals(ast.type);\n    case \"TypeLiteral\":\n      {\n        const out = [];\n        for (let i = 0; i < ast.propertySignatures.length; i++) {\n          const propertySignature = ast.propertySignatures[i];\n          const type = from(propertySignature.type);\n          if (isLiteral(type) && !propertySignature.isOptional) {\n            out.push([propertySignature.name, type]);\n          }\n        }\n        return out;\n      }\n    case \"Refinement\":\n    case \"Transform\":\n      return _getLiterals(ast.from);\n  }\n  return [];\n};\n\n/**\n * The purpose of the algorithm is to narrow down the pool of possible candidates for decoding as much as possible.\n *\n * This function separates the schemas into two groups, `keys` and `otherwise`:\n *\n * - `keys`: the schema has at least one property with a literal value\n * - `otherwise`: the schema has no properties with a literal value\n *\n * If a schema has at least one property with a literal value, so it ends up in `keys`, first a namespace is created for\n * the name of the property containing the literal, and then within this namespace a \"bucket\" is created for the literal\n * value in which to store all the schemas that have the same property and literal value.\n *\n * @internal\n */\nconst _getSearchTree = members => {\n  const keys = {};\n  const otherwise = [];\n  for (let i = 0; i < members.length; i++) {\n    const member = members[i];\n    const tags = _getLiterals(member);\n    if (tags.length > 0) {\n      for (let j = 0; j < tags.length; j++) {\n        const [key, literal] = tags[j];\n        const hash = String(literal.literal);\n        keys[key] = keys[key] || {\n          buckets: {},\n          ast: neverKeyword\n        };\n        const buckets = keys[key].buckets;\n        if (Object.prototype.hasOwnProperty.call(buckets, hash)) {\n          if (j < tags.length - 1) {\n            continue;\n          }\n          buckets[hash].push(member);\n          keys[key].ast = createUnion([keys[key].ast, literal]);\n        } else {\n          buckets[hash] = [member];\n          keys[key].ast = createUnion([keys[key].ast, literal]);\n          break;\n        }\n      }\n    } else {\n      otherwise.push(member);\n    }\n  }\n  return {\n    keys,\n    otherwise\n  };\n};\nconst dropRightRefinement = ast => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;\nconst handleForbidden = (conditional, options) => {\n  const eu = eitherOrUndefined(conditional);\n  return eu ? eu : options?.isEffectAllowed === true ? conditional : failure(forbidden);\n};\nconst unknownArray = /*#__PURE__*/createTuple([], /*#__PURE__*/Option.some([unknownKeyword]), true, {\n  [DescriptionAnnotationId]: \"a generic array\"\n});\nconst unknownRecord = /*#__PURE__*/createTypeLiteral([], [/*#__PURE__*/createIndexSignature(stringKeyword, unknownKeyword, true), /*#__PURE__*/createIndexSignature(symbolKeyword, unknownKeyword, true)], {\n  [DescriptionAnnotationId]: \"a generic object\"\n});\nconst mutableAppend = (self, a) => {\n  self.push(a);\n  return self;\n};\nconst getTemplateLiteralRegex = ast => {\n  let pattern = `^${ast.head}`;\n  for (const span of ast.spans) {\n    if (isStringKeyword(span.type)) {\n      pattern += \".*\";\n    } else if (isNumberKeyword(span.type)) {\n      pattern += \"-?\\\\d+(\\\\.\\\\d+)?\";\n    }\n    pattern += span.literal;\n  }\n  pattern += \"$\";\n  return new RegExp(pattern);\n};\nfunction sortByIndex(es) {\n  return es.sort(([a], [b]) => a > b ? 1 : a < b ? -1 : 0).map(([_, a]) => a);\n}\n\n// -------------------------------------------------------------------------------------\n// transformations interpreter\n// -------------------------------------------------------------------------------------\n\nconst getFinalPropertySignatureTransformation = (transformation, isDecoding) => {\n  switch (transformation._tag) {\n    case \"FinalPropertySignatureTransformation\":\n      return isDecoding ? transformation.decode : transformation.encode;\n  }\n};\n\n/** @internal */\nconst getFinalTransformation = (transformation, isDecoding) => {\n  switch (transformation._tag) {\n    case \"FinalTransformation\":\n      return isDecoding ? transformation.decode : transformation.encode;\n    case \"ComposeTransformation\":\n      return success;\n    case \"TypeLiteralTransformation\":\n      return input => {\n        let out = Either.right(input);\n\n        // ---------------------------------------------\n        // handle property signature transformations\n        // ---------------------------------------------\n        for (const pst of transformation.propertySignatureTransformations) {\n          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];\n          const transform = getFinalPropertySignatureTransformation(pst.propertySignatureTransformation, isDecoding);\n          const f = input => {\n            const o = transform(Object.prototype.hasOwnProperty.call(input, from) ? Option.some(input[from]) : Option.none());\n            if (Option.isSome(o)) {\n              input[to] = o.value;\n            } else {\n              delete input[from];\n            }\n            return input;\n          };\n          out = map(out, f);\n        }\n        return out;\n      };\n  }\n};\n\nexport { _getLiterals, _getSearchTree, asserts, decode, decodeEither, decodeOption, decodePromise, decodeSync, defaultParseOption, encode, encodeEither, encodeOption, encodePromise, encodeSync, getFinalTransformation, is, parse, parseEither, parseOption, parsePromise, parseSync, validate, validateEither, validateOption, validatePromise, validateSync };\n","import * as BigInt_ from 'effect/BigInt';\nimport * as Brand from 'effect/Brand';\nimport * as Chunk from 'effect/Chunk';\nimport * as Data from 'effect/Data';\nimport * as Either from 'effect/Either';\nimport * as Encoding from 'effect/Encoding';\nimport * as Equal from 'effect/Equal';\nimport { identity, dual } from 'effect/Function';\nimport * as Number$1 from 'effect/Number';\nimport * as Option from 'effect/Option';\nimport { pipeArguments } from 'effect/Pipeable';\nimport * as Predicate from 'effect/Predicate';\nimport * as ReadonlyArray from 'effect/ReadonlyArray';\nimport * as S from 'effect/String';\nimport { from as from$1, to as to$1, createUniqueSymbol, createEnums, createUnion, isLiteral, createLiteral, createTemplateLiteral, createDeclaration, createRefinement, TypeAnnotationId, DescriptionAnnotationId, undefinedKeyword, voidKeyword, neverKeyword, unknownKeyword, anyKeyword, stringKeyword, numberKeyword, booleanKeyword, bigIntKeyword, symbolKeyword, objectKeyword, keyof as keyof$1, createTuple, createElement, isTuple, appendRestElement, appendElement, createPropertySignature, createPropertySignatureTransform, createFinalPropertySignatureTransformation, createTransform, createTypeLiteralTransformation, createTypeLiteral, isTransform, isTypeLiteralTransformation, pick as pick$1, omit as omit$1, partial as partial$1, required as required$1, mutable as mutable$1, createRecord, isTypeLiteral, getToIndexSignatures, getToPropertySignatures, isUnion, composeTransformation, createLazy, createFinalTransformation, mergeAnnotations, setAnnotation, MessageAnnotationId, IdentifierAnnotationId, TitleAnnotationId, ExamplesAnnotationId, DocumentationAnnotationId, JSONSchemaAnnotationId, BrandAnnotationId } from '../../AST/dist/effect-schema-AST.esm.js';\nimport { ownKeys, maxSafeInteger, minSafeInteger, PrettyHookId, ArbitraryHookId } from '../../internal/common.esm.js';\nimport { validateSync, validateOption, validateEither, is, parse, encode } from '../../Parser/dist/effect-schema-Parser.esm.js';\nexport { asserts, decode, decodeEither, decodeOption, decodePromise, decodeSync, encode, encodeEither, encodeOption, encodePromise, encodeSync, is, parse, parseEither, parseOption, parsePromise, parseSync, validate, validateEither, validateOption, validatePromise, validateSync } from '../../Parser/dist/effect-schema-Parser.esm.js';\nimport { parseError, type, success, failure, map } from '../../ParseResult/dist/effect-schema-ParseResult.esm.js';\nimport { formatErrors } from '../../TreeFormatter/dist/effect-schema-TreeFormatter.esm.js';\n\n/**\n * @since 1.0.0\n */\n\n// ---------------------------------------------\n// model\n// ---------------------------------------------\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/Schema\");\n\n/**\n * @since 1.0.0\n * @category symbol\n */\n\n/**\n * @category model\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst from = schema => make(from$1(schema.ast));\n\n/**\n * @since 1.0.0\n */\nconst to = schema => make(to$1(schema.ast));\n/* c8 ignore end */\n\n// ---------------------------------------------\n// guards\n// ---------------------------------------------\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 1.0.0\n */\nconst isSchema = u => Predicate.isObject(u) && TypeId in u && \"ast\" in u && \"pipe\" in u;\n\n// ---------------------------------------------\n// constructors\n// ---------------------------------------------\n\nconst variance = {\n  From: _ => _,\n  To: _ => _\n};\nclass SchemaImpl {\n  [TypeId] = variance;\n  constructor(ast) {\n    this.ast = ast;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst make = ast => new SchemaImpl(ast);\nconst makeLiteral = value => make(createLiteral(value));\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst literal = (...literals) => union(...literals.map(literal => makeLiteral(literal)));\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst uniqueSymbol = (symbol, annotations) => make(createUniqueSymbol(symbol, annotations));\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst enums = enums => make(createEnums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== \"number\").map(key => [key, enums[key]])));\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst templateLiteral = (...[head, ...tail]) => {\n  let types = getTemplateLiterals(head.ast);\n  for (const span of tail) {\n    types = ReadonlyArray.flatMap(types, a => getTemplateLiterals(span.ast).map(b => combineTemplateLiterals(a, b)));\n  }\n  return make(createUnion(types));\n};\nconst combineTemplateLiterals = (a, b) => {\n  if (isLiteral(a)) {\n    return isLiteral(b) ? createLiteral(String(a.literal) + String(b.literal)) : createTemplateLiteral(String(a.literal) + b.head, b.spans);\n  }\n  if (isLiteral(b)) {\n    return createTemplateLiteral(a.head, ReadonlyArray.modifyNonEmptyLast(a.spans, span => ({\n      ...span,\n      literal: span.literal + String(b.literal)\n    })));\n  }\n  return createTemplateLiteral(a.head, ReadonlyArray.appendAll(ReadonlyArray.modifyNonEmptyLast(a.spans, span => ({\n    ...span,\n    literal: span.literal + String(b.head)\n  })), b.spans));\n};\nconst getTemplateLiterals = ast => {\n  switch (ast._tag) {\n    case \"Literal\":\n      return [ast];\n    case \"NumberKeyword\":\n    case \"StringKeyword\":\n      return [createTemplateLiteral(\"\", [{\n        type: ast,\n        literal: \"\"\n      }])];\n    case \"Union\":\n      return ReadonlyArray.flatMap(ast.types, getTemplateLiterals);\n    default:\n      throw new Error(`templateLiteral: unsupported template literal span ${ast._tag}`);\n  }\n};\n\n/**\n  @category constructors\n  @since 1.0.0\n*/\nconst declare = (typeParameters, type, decode, annotations) => make(createDeclaration(typeParameters.map(tp => tp.ast), type.ast, (isDecoding, ...typeParameters) => decode(isDecoding, ...typeParameters.map(make)), annotations));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst BrandTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Brand\");\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst fromBrand = (constructor, options) => self => {\n  return make(createRefinement(self.ast, (a, _, ast) => {\n    const e = constructor.either(a);\n    return Either.isLeft(e) ? Option.some(parseError([type(ast, a, e.left.map(v => v.message).join(\", \"))])) : Option.none();\n  }, toAnnotations({\n    typeId: {\n      id: BrandTypeId,\n      params: {\n        constructor\n      }\n    },\n    ...options\n  })));\n};\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst InstanceOfTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/InstanceOf\");\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst instanceOf = (constructor, options) => {\n  return declare([], struct({}), () => (input, _, ast) => input instanceof constructor ? success(input) : failure(type(ast, input)), {\n    [TypeAnnotationId]: InstanceOfTypeId,\n    [InstanceOfTypeId]: {\n      constructor\n    },\n    [DescriptionAnnotationId]: `an instance of ${constructor.name}`,\n    ...toAnnotations(options)\n  });\n};\n\n// ---------------------------------------------\n// primitives\n// ---------------------------------------------\n\nconst _undefined = /*#__PURE__*/make(undefinedKeyword);\nconst _void = /*#__PURE__*/make(voidKeyword);\nconst _null = /*#__PURE__*/make( /*#__PURE__*/createLiteral(null));\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst never = /*#__PURE__*/make(neverKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst unknown = /*#__PURE__*/make(unknownKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst any = /*#__PURE__*/make(anyKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst string = /*#__PURE__*/make(stringKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst number = /*#__PURE__*/make(numberKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst boolean = /*#__PURE__*/make(booleanKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst bigintFromSelf = /*#__PURE__*/make(bigIntKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst symbolFromSelf = /*#__PURE__*/make(symbolKeyword);\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nconst object = /*#__PURE__*/make(objectKeyword);\n\n// ---------------------------------------------\n// combinators\n// ---------------------------------------------\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst union = (...members) => make(createUnion(members.map(m => m.ast)));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst nullable = self => union(_null, self);\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst keyof = schema => make(keyof$1(schema.ast));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst tuple = (...elements) => make(createTuple(elements.map(schema => createElement(schema.ast, false)), Option.none(), true));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst rest = rest => self => {\n  if (isTuple(self.ast)) {\n    return make(appendRestElement(self.ast, rest.ast));\n  }\n  throw new Error(\"`rest` is not supported on this schema\");\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst element = element => self => {\n  if (isTuple(self.ast)) {\n    return make(appendElement(self.ast, createElement(element.ast, false)));\n  }\n  throw new Error(\"`element` is not supported on this schema\");\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst optionalElement = element => self => {\n  if (isTuple(self.ast)) {\n    return make(appendElement(self.ast, createElement(element.ast, true)));\n  }\n  throw new Error(\"`optionalElement` is not supported on this schema\");\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst array = item => make(createTuple([], Option.some([item.ast]), true));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst nonEmptyArray = item => tuple(item).pipe(rest(item));\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/** @internal */\nclass PropertySignatureImpl {\n  [TypeId] = variance;\n  constructor(config) {\n    this.config = config;\n  }\n  withDefault(value) {\n    return new PropertySignatureImpl({\n      _tag: \"Default\",\n      ast: this.config.ast,\n      value,\n      annotations: this.config.annotations\n    });\n  }\n  toOption() {\n    return new PropertySignatureImpl({\n      _tag: \"Option\",\n      ast: this.config.ast,\n      annotations: this.config.annotations\n    });\n  }\n}\n\n/**\n * @since 1.0.0\n */\nconst propertySignature = (schema, options) => new PropertySignatureImpl({\n  _tag: \"PropertySignature\",\n  ast: schema.ast,\n  annotations: toAnnotations(options)\n});\n\n/**\n * @since 1.0.0\n */\nconst optional = (schema, options) => new PropertySignatureImpl({\n  _tag: \"Optional\",\n  ast: schema.ast,\n  annotations: toAnnotations(options)\n});\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst struct = fields => {\n  const ownKeys$1 = ownKeys(fields);\n  const pss = [];\n  const froms = [];\n  const tos = [];\n  const propertySignatureTransformations = [];\n  for (let i = 0; i < ownKeys$1.length; i++) {\n    const key = ownKeys$1[i];\n    const field = fields[key];\n    if (\"config\" in field) {\n      const config = field.config;\n      const from = config.ast;\n      const to = to$1(from);\n      const annotations = config.annotations;\n      switch (config._tag) {\n        case \"PropertySignature\":\n          pss.push(createPropertySignature(key, from, false, true, annotations));\n          froms.push(createPropertySignature(key, from, false, true));\n          tos.push(createPropertySignature(key, to, false, true, annotations));\n          break;\n        case \"Optional\":\n          pss.push(createPropertySignature(key, from, true, true, annotations));\n          froms.push(createPropertySignature(key, from, true, true));\n          tos.push(createPropertySignature(key, to, true, true, annotations));\n          break;\n        case \"Default\":\n          froms.push(createPropertySignature(key, from, true, true));\n          tos.push(createPropertySignature(key, to, false, true, annotations));\n          propertySignatureTransformations.push(createPropertySignatureTransform(key, key, createFinalPropertySignatureTransformation(Option.orElse(() => Option.some(config.value())), identity)));\n          break;\n        case \"Option\":\n          froms.push(createPropertySignature(key, from, true, true));\n          tos.push(createPropertySignature(key, optionFromSelf(make(to)).ast, false, true, annotations));\n          propertySignatureTransformations.push(createPropertySignatureTransform(key, key, createFinalPropertySignatureTransformation(Option.some, Option.flatten)));\n          break;\n      }\n    } else {\n      pss.push(createPropertySignature(key, field.ast, false, true));\n      froms.push(createPropertySignature(key, field.ast, false, true));\n      tos.push(createPropertySignature(key, to$1(field.ast), false, true));\n    }\n  }\n  if (ReadonlyArray.isNonEmptyReadonlyArray(propertySignatureTransformations)) {\n    return make(createTransform(createTypeLiteral(froms, []), createTypeLiteral(tos, []), createTypeLiteralTransformation(propertySignatureTransformations)));\n  }\n  return make(createTypeLiteral(pss, []));\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst pick = (...keys) => self => {\n  const ast = self.ast;\n  if (isTransform(ast)) {\n    if (isTypeLiteralTransformation(ast.transformation)) {\n      const propertySignatureTransformations = ast.transformation.propertySignatureTransformations.filter(t => keys.includes(t.to));\n      if (ReadonlyArray.isNonEmptyReadonlyArray(propertySignatureTransformations)) {\n        return make(createTransform(pick$1(ast.from, keys), pick$1(ast.to, keys), createTypeLiteralTransformation(propertySignatureTransformations)));\n      } else {\n        return make(pick$1(ast.from, keys));\n      }\n    }\n    throw new Error(`pick: cannot handle this kind of transformation`);\n  }\n  return make(pick$1(ast, keys));\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst omit = (...keys) => self => {\n  const ast = self.ast;\n  if (isTransform(ast)) {\n    if (isTypeLiteralTransformation(ast.transformation)) {\n      const propertySignatureTransformations = ast.transformation.propertySignatureTransformations.filter(t => !keys.includes(t.to));\n      if (ReadonlyArray.isNonEmptyReadonlyArray(propertySignatureTransformations)) {\n        return make(createTransform(omit$1(ast.from, keys), omit$1(ast.to, keys), createTypeLiteralTransformation(propertySignatureTransformations)));\n      } else {\n        return make(omit$1(ast.from, keys));\n      }\n    }\n    throw new Error(`omit: cannot handle this kind of transformation`);\n  }\n  return make(omit$1(ast, keys));\n};\n\n/**\n * @category model\n * @since 1.0.0\n */\n\nconst appendBrandAnnotation = (ast, brand, options) => {\n  if (isTransform(ast)) {\n    return createTransform(ast.from, appendBrandAnnotation(ast.to, brand, options), ast.transformation, ast.annotations);\n  }\n  const annotations = toAnnotations(options);\n  annotations[BrandAnnotationId] = [...getBrands(ast), brand];\n  return mergeAnnotations(ast, annotations);\n};\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @param self - The input schema to be combined with the brand.\n * @param brand - The brand to apply.\n *\n * @example\n * import * as Schema from \"@effect/schema/Schema\"\n *\n * const Int = Schema.number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.To<typeof Int> // number & Brand<\"Int\">\n *\n * @category combinators\n * @since 1.0.0\n */\nconst brand = (brand, options) => self => {\n  const ast = appendBrandAnnotation(self.ast, brand, options);\n  const schema = make(ast);\n  const validateSync$1 = validateSync(schema);\n  const validateOption$1 = validateOption(schema);\n  const validateEither$1 = validateEither(schema);\n  const is$1 = is(schema);\n  const out = Object.assign(input => validateSync$1(input), {\n    [Brand.RefinedConstructorsTypeId]: Brand.RefinedConstructorsTypeId,\n    [TypeId]: variance,\n    ast,\n    option: input => validateOption$1(input),\n    either: input => Either.mapLeft(validateEither$1(input), e => [{\n      meta: input,\n      message: formatErrors(e.errors)\n    }]),\n    is: input => is$1(input),\n    pipe() {\n      return pipeArguments(this, arguments);\n    }\n  });\n  return out;\n};\nconst getBrands = ast => ast.annotations[BrandAnnotationId] || [];\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst partial = self => make(partial$1(self.ast));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst required = self => make(required$1(self.ast));\n\n/**\n * Make all properties in T mutable\n *\n * @since 1.0.0\n */\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @param schema - The original schema to make properties mutable (shallowly).\n *\n * @category combinators\n * @since 1.0.0\n */\nconst mutable = schema => {\n  const ast = mutable$1(schema.ast);\n  return ast === schema.ast ? schema : make(ast);\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst record = (key, value) => make(createRecord(key.ast, value.ast, true));\n\n/** @internal */\nconst intersectUnionMembers = (xs, ys) => {\n  return createUnion(xs.flatMap(x => {\n    return ys.map(y => {\n      if (isTypeLiteral(x)) {\n        if (isTypeLiteral(y)) {\n          // isTypeLiteral(x) && isTypeLiteral(y)\n          return createTypeLiteral(x.propertySignatures.concat(y.propertySignatures), x.indexSignatures.concat(y.indexSignatures));\n        } else if (isTransform(y) && isTypeLiteralTransformation(y.transformation) && isTypeLiteral(y.from) && isTypeLiteral(y.to)) {\n          // isTypeLiteral(x) && isTransform(y)\n          const from = createTypeLiteral(x.propertySignatures.concat(y.from.propertySignatures), x.indexSignatures.concat(y.from.indexSignatures));\n          const to = createTypeLiteral(getToPropertySignatures(x.propertySignatures).concat(y.to.propertySignatures), getToIndexSignatures(x.indexSignatures).concat(y.to.indexSignatures));\n          return createTransform(from, to, createTypeLiteralTransformation(y.transformation.propertySignatureTransformations));\n        }\n      } else if (isTransform(x) && isTypeLiteralTransformation(x.transformation) && isTypeLiteral(x.from) && isTypeLiteral(x.to)) {\n        if (isTypeLiteral(y)) {\n          // isTransform(x) && isTypeLiteral(y)\n          const from = createTypeLiteral(x.from.propertySignatures.concat(y.propertySignatures), x.from.indexSignatures.concat(y.indexSignatures));\n          const to = createTypeLiteral(x.to.propertySignatures.concat(getToPropertySignatures(y.propertySignatures)), x.to.indexSignatures.concat(getToIndexSignatures(y.indexSignatures)));\n          return createTransform(from, to, createTypeLiteralTransformation(x.transformation.propertySignatureTransformations));\n        } else if (isTransform(y) && isTypeLiteralTransformation(y.transformation) && isTypeLiteral(y.from) && isTypeLiteral(y.to)) {\n          // isTransform(x) && isTransform(y)\n          const from = createTypeLiteral(x.from.propertySignatures.concat(y.from.propertySignatures), x.from.indexSignatures.concat(y.from.indexSignatures));\n          const to = createTypeLiteral(x.to.propertySignatures.concat(y.to.propertySignatures), x.to.indexSignatures.concat(y.to.indexSignatures));\n          return createTransform(from, to, createTypeLiteralTransformation(x.transformation.propertySignatureTransformations.concat(y.transformation.propertySignatureTransformations)));\n        }\n      }\n      throw new Error(\"`extend` can only handle type literals or unions of type literals\");\n    });\n  }));\n};\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst extend = /*#__PURE__*/dual(2, (self, that) => make(intersectUnionMembers(isUnion(self.ast) ? self.ast.types : [self.ast], isUnion(that.ast) ? that.ast.types : [that.ast])));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst compose = /*#__PURE__*/dual(2, (ab, cd) => make(createTransform(ab.ast, cd.ast, composeTransformation)));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nconst lazy = (f, annotations) => make(createLazy(() => f().ast, annotations));\n\n/**\n * @category combinators\n * @since 1.0.0\n */\n\nfunction filter(predicate, options) {\n  return self => make(createRefinement(self.ast, (a, _, ast) => predicate(a) ? Option.none() : Option.some(parseError([type(ast, a)])), toAnnotations(options)));\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category combinators\n * @since 1.0.0\n */\nconst transformOrFail = /*#__PURE__*/dual(4, (from, to, decode, encode, annotations) => make(createTransform(from.ast, to.ast, createFinalTransformation(decode, encode), annotations)));\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category combinators\n * @since 1.0.0\n */\nconst transform = /*#__PURE__*/dual(4, (from, to, decode, encode) => transformOrFail(from, to, (a, options, ast) => Either.right(decode(a, options, ast)), (b, options, ast) => Either.right(encode(b, options, ast))));\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @param self - The input schema.\n * @param key - The name of the property to add to the schema.\n * @param value - The value of the property to add to the schema.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.struct({ radius: S.number })\n * const Square = S.struct({ sideLength: S.number })\n * const Shape = S.union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n *\n * @category combinators\n * @since 1.0.0\n */\nconst attachPropertySignature = /*#__PURE__*/dual(3, (schema, key, value) => make(createTransform(schema.ast, to(schema).pipe(extend(struct({\n  [key]: literal(value)\n}))).ast, createTypeLiteralTransformation([createPropertySignatureTransform(key, key, createFinalPropertySignatureTransformation(() => Option.some(value), () => Option.none()))]))));\n\n// ---------------------------------------------\n// annotations\n// ---------------------------------------------\n\nconst toAnnotations = options => {\n  if (!options) {\n    return {};\n  }\n  const out = {};\n\n  // symbols are reserved for custom annotations\n  const custom = Object.getOwnPropertySymbols(options);\n  for (const sym of custom) {\n    out[sym] = options[sym];\n  }\n\n  // string keys are reserved as /schema namespace\n  if (options.typeId !== undefined) {\n    const typeId = options.typeId;\n    if (typeof typeId === \"object\") {\n      out[TypeAnnotationId] = typeId.id;\n      out[typeId.id] = typeId.params;\n    } else {\n      out[TypeAnnotationId] = typeId;\n    }\n  }\n  const move = (from, to) => {\n    if (options[from] !== undefined) {\n      out[to] = options[from];\n    }\n  };\n  move(\"message\", MessageAnnotationId);\n  move(\"identifier\", IdentifierAnnotationId);\n  move(\"title\", TitleAnnotationId);\n  move(\"description\", DescriptionAnnotationId);\n  move(\"examples\", ExamplesAnnotationId);\n  move(\"documentation\", DocumentationAnnotationId);\n  move(\"jsonSchema\", JSONSchemaAnnotationId);\n  move(\"arbitrary\", ArbitraryHookId);\n  move(\"pretty\", PrettyHookId);\n  return out;\n};\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst annotations = annotations => self => make(mergeAnnotations(self.ast, annotations));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst message = message => self => make(setAnnotation(self.ast, MessageAnnotationId, message));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst identifier = identifier => self => make(setAnnotation(self.ast, IdentifierAnnotationId, identifier));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst title = title => self => make(setAnnotation(self.ast, TitleAnnotationId, title));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst description = description => self => make(setAnnotation(self.ast, DescriptionAnnotationId, description));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst examples = examples => self => make(setAnnotation(self.ast, ExamplesAnnotationId, examples));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst documentation = documentation => self => make(setAnnotation(self.ast, DocumentationAnnotationId, documentation));\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nconst jsonSchema = jsonSchema => self => make(setAnnotation(self.ast, JSONSchemaAnnotationId, jsonSchema));\n\n// ---------------------------------------------\n// string filters\n// ---------------------------------------------\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst TrimmedTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Trimmed\");\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 1.0.0\n */\nconst trimmed = options => self => self.pipe(filter(a => a === a.trim(), {\n  typeId: TrimmedTypeId,\n  description: \"a string with no leading or trailing whitespace\",\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst MaxLengthTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/MaxLength\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst maxLength = (maxLength, options) => self => self.pipe(filter(a => a.length <= maxLength, {\n  typeId: MaxLengthTypeId,\n  description: `a string at most ${maxLength} character(s) long`,\n  jsonSchema: {\n    maxLength\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst MinLengthTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/MinLength\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst minLength = (minLength, options) => self => self.pipe(filter(a => a.length >= minLength, {\n  typeId: MinLengthTypeId,\n  description: `a string at least ${minLength} character(s) long`,\n  jsonSchema: {\n    minLength\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst PatternTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Pattern\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst pattern = (regex, options) => self => {\n  const pattern = regex.source;\n  return self.pipe(filter(a => {\n    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n    regex.lastIndex = 0;\n    return regex.test(a);\n  }, {\n    typeId: {\n      id: PatternTypeId,\n      params: {\n        regex\n      }\n    },\n    description: `a string matching the pattern ${pattern}`,\n    jsonSchema: {\n      pattern\n    },\n    arbitrary: () => fc => fc.stringMatching(regex),\n    ...options\n  }));\n};\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst StartsWithTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/StartsWith\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst startsWith = (startsWith, options) => self => self.pipe(filter(a => a.startsWith(startsWith), {\n  typeId: {\n    id: StartsWithTypeId,\n    params: {\n      startsWith\n    }\n  },\n  description: `a string starting with ${JSON.stringify(startsWith)}`,\n  jsonSchema: {\n    pattern: `^${startsWith}`\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst EndsWithTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/EndsWith\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst endsWith = (endsWith, options) => self => self.pipe(filter(a => a.endsWith(endsWith), {\n  typeId: {\n    id: EndsWithTypeId,\n    params: {\n      endsWith\n    }\n  },\n  description: `a string ending with ${JSON.stringify(endsWith)}`,\n  jsonSchema: {\n    pattern: `^.*${endsWith}$`\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst IncludesTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Includes\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst includes = (searchString, options) => self => self.pipe(filter(a => a.includes(searchString), {\n  typeId: {\n    id: IncludesTypeId,\n    params: {\n      includes: searchString\n    }\n  },\n  description: `a string including ${JSON.stringify(searchString)}`,\n  jsonSchema: {\n    pattern: `.*${searchString}.*`\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst LowercasedTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Lowercased\");\n\n/**\n * Verifies that a string is lowercased\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to lowercase strings, then check out the `lowercase` combinator.\n *\n * @category string filters\n * @since 1.0.0\n */\nconst lowercased = options => self => self.pipe(filter(a => a === a.toLowerCase(), {\n  typeId: LowercasedTypeId,\n  description: \"a lowercase string\",\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst LengthTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Length\");\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst length = (length, options) => self => self.pipe(filter(a => a.length === length, {\n  typeId: LengthTypeId,\n  description: length === 1 ? `a character` : `a string ${length} character(s) long`,\n  jsonSchema: {\n    minLength: length,\n    maxLength: length\n  },\n  ...options\n}));\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nconst nonEmpty = options => minLength(1, {\n  description: \"a non empty string\",\n  ...options\n});\n\n// ---------------------------------------------\n// string transformations\n// ---------------------------------------------\n\n/**\n * This combinator converts a string to lowercase\n *\n * @category string transformations\n * @since 1.0.0\n */\nconst lowercase = self => transform(self, to(self).pipe(lowercased()), s => s.toLowerCase(), identity);\n\n/**\n * This combinator converts a string to lowercase\n *\n * @category string transformations\n * @since 1.0.0\n */\nconst Lowercase = /*#__PURE__*/lowercase(string);\n\n/**\n * This combinator allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 1.0.0\n */\nconst trim = self => transform(self, to(self).pipe(trimmed()), s => s.trim(), identity);\n\n/**\n * This combinator allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 1.0.0\n */\nconst split = /*#__PURE__*/dual(2, (self, separator) => transform(self, array(string), S.split(separator), ReadonlyArray.join(separator)));\n\n/**\n * The `parseJson` combinator offers a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also employs `JSON.stringify` for encoding.\n *\n * @category string transformations\n * @since 1.0.0\n */\nconst parseJson = (self, options) => {\n  return transformOrFail(self, unknown, (s, _, ast) => {\n    try {\n      return success(JSON.parse(s, options?.reviver));\n    } catch (e) {\n      return failure(type(ast, s, e.message));\n    }\n  }, (u, _, ast) => {\n    try {\n      return success(JSON.stringify(u, options?.replacer, options?.space));\n    } catch (e) {\n      return failure(type(ast, u, e.message));\n    }\n  });\n};\n\n// ---------------------------------------------\n// string constructors\n// ---------------------------------------------\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nconst NonEmpty = /*#__PURE__*/string.pipe( /*#__PURE__*/nonEmpty());\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nconst Trimmed = /*#__PURE__*/string.pipe( /*#__PURE__*/trimmed());\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst UUIDTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/UUID\");\nconst uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nconst UUID = /*#__PURE__*/string.pipe( /*#__PURE__*/pattern(uuidRegex, {\n  typeId: UUIDTypeId,\n  title: \"UUID\",\n  description: \"a UUID\",\n  arbitrary: () => fc => fc.uuid()\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst ULIDTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/ULID\");\nconst ulidRegex = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nconst ULID = /*#__PURE__*/string.pipe( /*#__PURE__*/pattern(ulidRegex, {\n  typeId: ULIDTypeId,\n  title: \"ULID\",\n  description: \"a ULID\",\n  arbitrary: () => fc => fc.ulid()\n}));\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string constructors\n * @since 1.0.0\n */\nconst Trim = /*#__PURE__*/trim(string);\n\n/**\n * The `ParseJson` schema offers a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also employs `JSON.stringify` for encoding.\n *\n * @category string constructors\n * @since 1.0.0\n */\nconst ParseJson = /*#__PURE__*/parseJson(string);\n\n// ---------------------------------------------\n// number filters\n// ---------------------------------------------\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst FiniteTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Finite\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst finite = options => self => self.pipe(filter(a => Number.isFinite(a), {\n  typeId: FiniteTypeId,\n  description: \"a finite number\",\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst GreaterThanTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/GreaterThan\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst greaterThan = (min, options) => self => self.pipe(filter(a => a > min, {\n  typeId: GreaterThanTypeId,\n  description: min === 0 ? \"a positive number\" : `a number greater than ${min}`,\n  jsonSchema: {\n    exclusiveMinimum: min\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst GreaterThanOrEqualToTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/GreaterThanOrEqualTo\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst greaterThanOrEqualTo = (min, options) => self => self.pipe(filter(a => a >= min, {\n  typeId: GreaterThanOrEqualToTypeId,\n  description: min === 0 ? \"a non-negative number\" : `a number greater than or equal to ${min}`,\n  jsonSchema: {\n    minimum: min\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst MultipleOfTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/MultipleOf\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst multipleOf = (divisor, options) => self => self.pipe(filter(a => Number$1.remainder(a, divisor) === 0, {\n  typeId: MultipleOfTypeId,\n  description: `a number divisible by ${divisor}`,\n  jsonSchema: {\n    multipleOf: Math.abs(divisor)\n  },\n  // spec requires positive divisor\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst IntTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Int\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst int = options => self => self.pipe(filter(a => Number.isSafeInteger(a), {\n  typeId: IntTypeId,\n  description: \"integer\",\n  jsonSchema: {\n    type: \"integer\"\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst LessThanTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/LessThan\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst lessThan = (max, options) => self => self.pipe(filter(a => a < max, {\n  typeId: LessThanTypeId,\n  description: max === 0 ? \"a negative number\" : `a number less than ${max}`,\n  jsonSchema: {\n    exclusiveMaximum: max\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst LessThanOrEqualToTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/LessThanOrEqualTo\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst lessThanOrEqualTo = (max, options) => self => self.pipe(filter(a => a <= max, {\n  typeId: LessThanOrEqualToTypeId,\n  description: max === 0 ? \"a non-positive number\" : `a number less than or equal to ${max}`,\n  jsonSchema: {\n    maximum: max\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst BetweenTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/Between\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst between = (min, max, options) => self => self.pipe(filter(a => a >= min && a <= max, {\n  typeId: BetweenTypeId,\n  description: `a number between ${min} and ${max}`,\n  jsonSchema: {\n    maximum: max,\n    minimum: min\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst NonNaNTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/NonNaN\");\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst nonNaN = options => self => self.pipe(filter(a => !Number.isNaN(a), {\n  typeId: NonNaNTypeId,\n  description: \"a number NaN excluded\",\n  ...options\n}));\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst positive = options => greaterThan(0, options);\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst negative = options => lessThan(0, options);\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst nonPositive = options => lessThanOrEqualTo(0, options);\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nconst nonNegative = options => greaterThanOrEqualTo(0, options);\n\n// ---------------------------------------------\n// number transformations\n// ---------------------------------------------\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 1.0.0\n */\nconst clamp = (min, max) => self => transform(self, self.pipe(to, between(min, max)), self => Number$1.clamp(self, min, max), identity);\n\n/**\n * This combinator transforms a `string` into a `number` by parsing the string using the `Number` function.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @param self - The schema representing the input string\n *\n * @category number transformations\n * @since 1.0.0\n */\nconst numberFromString = self => {\n  return transformOrFail(self, number, (s, _, ast) => {\n    if (s === \"NaN\") {\n      return success(NaN);\n    }\n    if (s === \"Infinity\") {\n      return success(Infinity);\n    }\n    if (s === \"-Infinity\") {\n      return success(-Infinity);\n    }\n    if (s.trim() === \"\") {\n      return failure(type(ast, s));\n    }\n    const n = Number(s);\n    return isNaN(n) ? failure(type(ast, s)) : success(n);\n  }, n => success(String(n)));\n};\n\n// ---------------------------------------------\n// number constructors\n// ---------------------------------------------\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst Finite = /*#__PURE__*/number.pipe( /*#__PURE__*/finite());\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst Int = /*#__PURE__*/number.pipe( /*#__PURE__*/int());\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst NonNaN = /*#__PURE__*/number.pipe( /*#__PURE__*/nonNaN());\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst Positive = /*#__PURE__*/number.pipe( /*#__PURE__*/positive());\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst Negative = /*#__PURE__*/number.pipe( /*#__PURE__*/negative());\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst NonPositive = /*#__PURE__*/number.pipe( /*#__PURE__*/nonPositive());\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nconst NonNegative = /*#__PURE__*/number.pipe( /*#__PURE__*/nonNegative());\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number constructors\n * @since 1.0.0\n */\nconst NumberFromString = /*#__PURE__*/numberFromString(string);\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst JsonNumberTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/JsonNumber\");\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const is = S.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n *\n * @category number constructors\n * @since 1.0.0\n */\nconst JsonNumber = /*#__PURE__*/number.pipe( /*#__PURE__*/filter(n => !isNaN(n) && isFinite(n), {\n  typeId: JsonNumberTypeId,\n  title: \"JsonNumber\",\n  description: \"a JSON number\"\n}));\n\n// ---------------------------------------------\n// boolean transformations\n// ---------------------------------------------\n\n/**\n * Negates a boolean value\n *\n * @category boolean transformations\n * @since 1.0.0\n */\nconst not = self => transform(self, to(self), self => !self, self => !self);\n\n// ---------------------------------------------\n// boolean constructors\n// ---------------------------------------------\n\n/**\n * @category boolean constructors\n * @since 1.0.0\n */\nconst Not = /*#__PURE__*/not(boolean);\n\n// ---------------------------------------------\n// symbol transformations\n// ---------------------------------------------\n\n/**\n * This combinator transforms a `string` into a `symbol`.\n *\n * @param self - The schema representing the input string\n *\n * @category symbol transformations\n * @since 1.0.0\n */\nconst symbolFromString = self => {\n  return transform(self, symbolFromSelf, s => Symbol.for(s), sym => sym.description);\n};\n\n// ---------------------------------------------\n// symbol constructors\n// ---------------------------------------------\n\n/**\n * This schema transforms a `string` into a `symbol`.\n *\n * @category symbol constructors\n * @since 1.0.0\n */\nconst symbol = /*#__PURE__*/symbolFromString(string);\n\n// ---------------------------------------------\n// bigint filters\n// ---------------------------------------------\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst GreaterThanBigintTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/GreaterThanBigint\");\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst greaterThanBigint = (min, options) => self => self.pipe(filter(a => a > min, {\n  typeId: GreaterThanBigintTypeId,\n  description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n  jsonSchema: {\n    exclusiveMinimum: min\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst GreaterThanOrEqualToBigintTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/GreaterThanOrEqualToBigint\");\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst greaterThanOrEqualToBigint = (min, options) => self => self.pipe(filter(a => a >= min, {\n  typeId: GreaterThanOrEqualToBigintTypeId,\n  description: min === 0n ? \"a non-negative bigint\" : `a bigint greater than or equal to ${min}n`,\n  jsonSchema: {\n    minimum: min\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst LessThanBigintTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/LessThanBigint\");\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst lessThanBigint = (max, options) => self => self.pipe(filter(a => a < max, {\n  typeId: LessThanBigintTypeId,\n  description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n  jsonSchema: {\n    exclusiveMaximum: max\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst LessThanOrEqualToBigintTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/LessThanOrEqualToBigint\");\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst lessThanOrEqualToBigint = (max, options) => self => self.pipe(filter(a => a <= max, {\n  typeId: LessThanOrEqualToBigintTypeId,\n  description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n  jsonSchema: {\n    maximum: max\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst BetweenBigintTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/BetweenBigint\");\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst betweenBigint = (min, max, options) => self => self.pipe(filter(a => a >= min && a <= max, {\n  typeId: BetweenBigintTypeId,\n  description: `a bigint between ${min}n and ${max}n`,\n  jsonSchema: {\n    maximum: max,\n    minimum: min\n  },\n  ...options\n}));\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst positiveBigint = options => greaterThanBigint(0n, options);\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst negativeBigint = options => lessThanBigint(0n, options);\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst nonNegativeBigint = options => greaterThanOrEqualToBigint(0n, options);\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nconst nonPositiveBigint = options => lessThanOrEqualToBigint(0n, options);\n\n// ---------------------------------------------\n// bigint transformations\n// ---------------------------------------------\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 1.0.0\n */\nconst clampBigint = (min, max) => self => transform(self, self.pipe(to, betweenBigint(min, max)), self => BigInt_.clamp(self, min, max), identity);\n\n/**\n * This combinator transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * @param self - The schema representing the input string\n *\n * @category bigint transformations\n * @since 1.0.0\n */\nconst bigintFromString = self => {\n  return transformOrFail(self, bigintFromSelf, (s, _, ast) => {\n    if (s.trim() === \"\") {\n      return failure(type(ast, s));\n    }\n    try {\n      return success(BigInt(s));\n    } catch (_) {\n      return failure(type(ast, s));\n    }\n  }, n => success(String(n)));\n};\n\n/**\n * This combinator transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @param self - The schema representing the input number\n *\n * @category bigint transformations\n * @since 1.0.0\n */\nconst bigintFromNumber = self => {\n  return transformOrFail(self, bigintFromSelf, (n, _, ast) => {\n    try {\n      return success(BigInt(n));\n    } catch (_) {\n      return failure(type(ast, n));\n    }\n  }, (b, _, ast) => {\n    if (b > maxSafeInteger || b < minSafeInteger) {\n      return failure(type(ast, b));\n    }\n    return success(Number(b));\n  });\n};\n\n// ---------------------------------------------\n// bigint constructors\n// ---------------------------------------------\n\n/**\n * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * @category bigint constructors\n * @since 1.0.0\n */\nconst bigint = /*#__PURE__*/bigintFromString(string);\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst PositiveBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/positiveBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst PositiveBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/positiveBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst NegativeBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/negativeBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst NegativeBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/negativeBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst NonPositiveBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/nonPositiveBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst NonPositiveBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonPositiveBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst NonNegativeBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/nonNegativeBigint());\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nconst NonNegativeBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonNegativeBigint());\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint constructors\n * @since 1.0.0\n */\nconst BigintFromNumber = /*#__PURE__*/bigintFromNumber(number);\n\n// ---------------------------------------------\n// Uint8Array constructors\n// ---------------------------------------------\n\n/**\n * @category Uint8Array constructors\n * @since 1.0.0\n */\nconst Uint8ArrayFromSelf = /*#__PURE__*/declare([], /*#__PURE__*/struct({}), () => (u, _, ast) => !Predicate.isUint8Array(u) ? failure(type(ast, u)) : success(u), {\n  [IdentifierAnnotationId]: \"Uint8Array\",\n  [PrettyHookId]: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n  [ArbitraryHookId]: () => fc => fc.uint8Array()\n});\n\n// ---------------------------------------------\n// Uint8Array transformations\n// ---------------------------------------------\n\n/**\n * A combinator that transforms a `number` array into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 1.0.0\n */\nconst uint8ArrayFromNumbers = self => transform(self, Uint8ArrayFromSelf, a => Uint8Array.from(a), n => Array.from(n));\nconst _Uint8Array = /*#__PURE__*/uint8ArrayFromNumbers( /*#__PURE__*/array( /*#__PURE__*/number.pipe( /*#__PURE__*/between(0, 255, {\n  title: \"8-bit unsigned integer\",\n  description: \"a 8-bit unsigned integer\"\n}))));\n\n// ---------------------------------------------\n// Encoding transformations\n// ---------------------------------------------\n\nconst makeEncodingTransform = (id, decode, encode, arbitrary) => self => transformOrFail(self, Uint8ArrayFromSelf, (s, _, ast) => Either.mapLeft(decode(s), decodeException => parseError([type(ast, s, decodeException.message)])), u => success(encode(u)), {\n  [IdentifierAnnotationId]: id,\n  [PrettyHookId]: () => u => `${id}(${encode(u)})`,\n  [ArbitraryHookId]: () => arbitrary\n});\n\n/**\n * Transforms a base64 `string` into a `Uint8Array`.\n *\n * @category encoding transformations\n * @since 1.0.0\n */\nconst base64 = /*#__PURE__*/makeEncodingTransform(\"Base64\", Encoding.decodeBase64, Encoding.encodeBase64, fc => fc.base64String().map(s => Either.getOrThrow(Encoding.decodeBase64(s))));\n\n/**\n * Transforms a base64url `string` into a `Uint8Array`.\n *\n * @category encoding transformations\n * @since 1.0.0\n */\nconst base64url = /*#__PURE__*/makeEncodingTransform(\"Base64Url\", Encoding.decodeBase64Url, Encoding.encodeBase64Url, fc => fc.base64String().map(s => Either.getOrThrow(Encoding.decodeBase64Url(s))));\n\n/**\n * Transforms a hex `string` into a `Uint8Array`.\n *\n * @category encoding transformations\n * @since 1.0.0\n */\nconst hex = /*#__PURE__*/makeEncodingTransform(\"Hex\", Encoding.decodeHex, Encoding.encodeHex, fc => fc.hexaString().map(s => Either.getOrThrow(Encoding.decodeHex(s))));\n\n// ---------------------------------------------\n// Encoding constructors\n// ---------------------------------------------\n\n/**\n * @category encoding constructors\n * @since 1.0.0\n */\nconst Base64 = /*#__PURE__*/base64(string);\n\n/**\n * @category encoding constructors\n * @since 1.0.0\n */\nconst Base64Url = /*#__PURE__*/base64url(string);\n\n/**\n * @category encoding constructors\n * @since 1.0.0\n */\nconst Hex = /*#__PURE__*/hex(string);\n\n// ---------------------------------------------\n// ReadonlyArray filters\n// ---------------------------------------------\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst MinItemsTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/MinItems\");\n\n/**\n * @category ReadonlyArray filters\n * @since 1.0.0\n */\nconst minItems = (n, options) => self => self.pipe(filter(a => a.length >= n, {\n  typeId: MinItemsTypeId,\n  description: `an array of at least ${n} items`,\n  jsonSchema: {\n    minItems: n\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst MaxItemsTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/MaxItems\");\n\n/**\n * @category ReadonlyArray filters\n * @since 1.0.0\n */\nconst maxItems = (n, options) => self => self.pipe(filter(a => a.length <= n, {\n  typeId: MaxItemsTypeId,\n  description: `an array of at most ${n} items`,\n  jsonSchema: {\n    maxItems: n\n  },\n  ...options\n}));\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst ItemsCountTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/ItemsCount\");\n\n/**\n * @category ReadonlyArray filters\n * @since 1.0.0\n */\nconst itemsCount = (n, options) => self => self.pipe(filter(a => a.length === n, {\n  typeId: ItemsCountTypeId,\n  description: `an array of exactly ${n} items`,\n  jsonSchema: {\n    minItems: n,\n    maxItems: n\n  },\n  ...options\n}));\n\n// ---------------------------------------------\n// Date filters\n// ---------------------------------------------\n\n/**\n * @category type id\n * @since 1.0.0\n */\nconst ValidDateTypeId = /*#__PURE__*/Symbol.for(\"@effect/schema/TypeId/ValidDate\");\n\n/**\n * A filter excluding invalid dates (e.g. `new Date(\"fail\")`).\n *\n * @category Date filters\n * @since 1.0.0\n */\nconst validDate = options => self => self.pipe(filter(a => !isNaN(a.getTime()), {\n  typeId: ValidDateTypeId,\n  description: \"a valid Date\",\n  ...options\n}));\n\n// ---------------------------------------------\n// Date constructors\n// ---------------------------------------------\n\nconst dateArbitrary = () => fc => fc.date();\nconst datePretty = () => date => `new Date(${JSON.stringify(date)})`;\n\n/**\n * @category Date constructors\n * @since 1.0.0\n */\nconst DateFromSelf = /*#__PURE__*/declare([], /*#__PURE__*/struct({}), () => (u, _, ast) => !Predicate.isDate(u) ? failure(type(ast, u)) : success(u), {\n  [IdentifierAnnotationId]: \"Date\",\n  [PrettyHookId]: datePretty,\n  [ArbitraryHookId]: dateArbitrary\n});\n\n/**\n * A schema representing valid dates, e.g. `new Date(\"fail\")` is excluded, even though it is an instance of `Date`.\n *\n * @category Date constructors\n * @since 1.0.0\n */\nconst ValidDateFromSelf = /*#__PURE__*/DateFromSelf.pipe( /*#__PURE__*/validDate());\n\n// ---------------------------------------------\n// Date transformations\n// ---------------------------------------------\n\n/**\n * A combinator that transforms a `string` into a valid `Date`.\n *\n * @category Date transformations\n * @since 1.0.0\n */\nconst dateFromString = self => transform(self, ValidDateFromSelf, s => new Date(s), n => n.toISOString());\nconst _Date = /*#__PURE__*/dateFromString(string);\n\n/**\n * A schema representing valid dates, e.g. `new Date(\"fail\")` is excluded, even though it is an instance of `Date`.\n *\n * @category Date constructors\n * @since 1.0.0\n */\nconst ValidDate = /*#__PURE__*/_Date.pipe( /*#__PURE__*/validDate());\n\n// ---------------------------------------------\n// Option transformations\n// ---------------------------------------------\n\nconst optionArbitrary = value => fc => fc.oneof(fc.constant(Option.none()), value(fc).map(Option.some));\nconst optionPretty = value => Option.match({\n  onNone: () => \"none()\",\n  onSome: a => `some(${value(a)})`\n});\nconst optionInline = value => union(struct({\n  _tag: literal(\"None\")\n}), struct({\n  _tag: literal(\"Some\"),\n  value\n}));\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nconst optionFromSelf = value => {\n  return declare([value], optionInline(value), (isDecoding, value) => {\n    const parse$1 = isDecoding ? parse(value) : encode(value);\n    return (u, options, ast) => !Option.isOption(u) ? failure(type(ast, u)) : Option.isNone(u) ? success(Option.none()) : map(parse$1(u.value, options), Option.some);\n  }, {\n    [IdentifierAnnotationId]: \"Option\",\n    [PrettyHookId]: optionPretty,\n    [ArbitraryHookId]: optionArbitrary\n  });\n};\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nconst option = value => transform(optionInline(value), to(optionFromSelf(value)), a => a._tag === \"None\" ? Option.none() : Option.some(a.value), Option.match({\n  onNone: () => ({\n    _tag: \"None\"\n  }),\n  onSome: value => ({\n    _tag: \"Some\",\n    value\n  })\n}));\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nconst optionFromNullable = value => transform(nullable(value), to(optionFromSelf(value)), Option.fromNullable, Option.getOrNull);\n\n// ---------------------------------------------\n// Either transformations\n// ---------------------------------------------\n\nconst eitherArbitrary = (left, right) => fc => fc.oneof(left(fc).map(Either.left), right(fc).map(Either.right));\nconst eitherPretty = (left, right) => Either.match({\n  onLeft: e => `left(${left(e)})`,\n  onRight: a => `right(${right(a)})`\n});\nconst eitherInline = (left, right) => union(struct({\n  _tag: literal(\"Left\"),\n  left\n}), struct({\n  _tag: literal(\"Right\"),\n  right\n}));\n\n/**\n * @category Either transformations\n * @since 1.0.0\n */\nconst eitherFromSelf = (left, right) => {\n  return declare([left, right], eitherInline(left, right), (isDecoding, left, right) => {\n    const parseLeft = isDecoding ? parse(left) : encode(left);\n    const parseRight = isDecoding ? parse(right) : encode(right);\n    return (u, options, ast) => !Either.isEither(u) ? failure(type(ast, u)) : Either.isLeft(u) ? map(parseLeft(u.left, options), Either.left) : map(parseRight(u.right, options), Either.right);\n  }, {\n    [IdentifierAnnotationId]: \"Either\",\n    [PrettyHookId]: eitherPretty,\n    [ArbitraryHookId]: eitherArbitrary\n  });\n};\n\n/**\n * @category Either transformations\n * @since 1.0.0\n */\nconst either = (left, right) => transform(eitherInline(left, right), to(eitherFromSelf(left, right)), a => a._tag === \"Left\" ? Either.left(a.left) : Either.right(a.right), Either.match({\n  onLeft: left => ({\n    _tag: \"Left\",\n    left\n  }),\n  onRight: right => ({\n    _tag: \"Right\",\n    right\n  })\n}));\n\n// ---------------------------------------------\n// ReadonlyMap transformations\n// ---------------------------------------------\n\nconst isMap = u => u instanceof Map;\nconst readonlyMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => new Map(as));\nconst readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(\", \")}])`;\n\n/**\n * @category ReadonlyMap transformations\n * @since 1.0.0\n */\nconst readonlyMapFromSelf = (key, value) => {\n  return declare([key, value], struct({\n    size: number\n  }), (isDecoding, key, value) => {\n    const parse$1 = isDecoding ? parse(array(tuple(key, value))) : encode(array(tuple(key, value)));\n    return (u, options, ast) => !isMap(u) ? failure(type(ast, u)) : map(parse$1(Array.from(u.entries()), options), as => new Map(as));\n  }, {\n    [IdentifierAnnotationId]: \"ReadonlyMap\",\n    [PrettyHookId]: readonlyMapPretty,\n    [ArbitraryHookId]: readonlyMapArbitrary\n  });\n};\n\n/**\n * @category ReadonlyMap transformations\n * @since 1.0.0\n */\nconst readonlyMap = (key, value) => transform(array(tuple(key, value)), to(readonlyMapFromSelf(key, value)), as => new Map(as), map => Array.from(map.entries()));\n\n// ---------------------------------------------\n// ReadonlySet transformations\n// ---------------------------------------------\n\nconst isSet = u => u instanceof Set;\nconst readonlySetArbitrary = item => fc => fc.array(item(fc)).map(as => new Set(as));\nconst readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(\", \")}])`;\n\n/**\n * @category ReadonlySet transformations\n * @since 1.0.0\n */\nconst readonlySetFromSelf = item => {\n  return declare([item], struct({\n    size: number\n  }), (isDecoding, item) => {\n    const parse$1 = isDecoding ? parse(array(item)) : encode(array(item));\n    return (u, options, ast) => !isSet(u) ? failure(type(ast, u)) : map(parse$1(Array.from(u.values()), options), as => new Set(as));\n  }, {\n    [IdentifierAnnotationId]: \"ReadonlySet\",\n    [PrettyHookId]: readonlySetPretty,\n    [ArbitraryHookId]: readonlySetArbitrary\n  });\n};\n\n/**\n * @category ReadonlySet transformations\n * @since 1.0.0\n */\nconst readonlySet = item => transform(array(item), to(readonlySetFromSelf(item)), as => new Set(as), set => Array.from(set));\n\n// ---------------------------------------------\n// Chunk transformations\n// ---------------------------------------------\n\nconst chunkArbitrary = item => fc => fc.array(item(fc)).map(Chunk.fromIterable);\nconst chunkPretty = item => c => `Chunk(${Chunk.toReadonlyArray(c).map(item).join(\", \")})`;\n\n/**\n * @category Chunk transformations\n * @since 1.0.0\n */\nconst chunkFromSelf = item => {\n  return declare([item], struct({\n    _id: uniqueSymbol(Symbol.for(\"effect/Chunk\")),\n    length: number\n  }), (isDecoding, item) => {\n    const parse$1 = isDecoding ? parse(array(item)) : encode(array(item));\n    return (u, options, ast) => {\n      if (Chunk.isChunk(u)) {\n        return Chunk.isEmpty(u) ? success(u) : map(parse$1(Chunk.toReadonlyArray(u), options), Chunk.fromIterable);\n      }\n      return failure(type(ast, u));\n    };\n  }, {\n    [IdentifierAnnotationId]: \"Chunk\",\n    [PrettyHookId]: chunkPretty,\n    [ArbitraryHookId]: chunkArbitrary\n  });\n};\n\n/**\n * @category Chunk transformations\n * @since 1.0.0\n */\nconst chunk = item => transform(array(item), to(chunkFromSelf(item)), as => as.length === 0 ? Chunk.empty() : Chunk.fromIterable(as), Chunk.toReadonlyArray);\n\n// ---------------------------------------------\n// Data transformations\n// ---------------------------------------------\n\nconst toData = a => Array.isArray(a) ? Data.array(a) : Data.struct(a);\nconst dataArbitrary = item => fc => item(fc).map(toData);\nconst dataPretty = item => d => `Data(${item(d)})`;\n\n/**\n * @category Data transformations\n * @since 1.0.0\n */\nconst dataFromSelf = item => {\n  return declare([item], item, (isDecoding, item) => {\n    const parse$1 = isDecoding ? parse(item) : encode(item);\n    return (u, options, ast) => !Equal.isEqual(u) ? failure(type(ast, u)) : map(parse$1(u, options), toData);\n  }, {\n    [IdentifierAnnotationId]: \"Data\",\n    [PrettyHookId]: dataPretty,\n    [ArbitraryHookId]: dataArbitrary\n  });\n};\n\n/**\n * @category Data transformations\n * @since 1.0.0\n */\nconst data = item => transform(item, to(dataFromSelf(item)), toData, a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a));\n\n// ---------------------------------------------\n// classes\n// ---------------------------------------------\n/**\n * @category classes\n * @since 1.0.0\n */\n/**\n * @category classes\n * @since 1.0.0\n */\nconst Class = () => fields => makeClass(struct(fields), fields, Data.Class.prototype);\nconst makeClass = (selfSchema, selfFields, base) => {\n  const validator = validateSync(selfSchema);\n  const fn = function (props) {\n    Object.assign(this, validator(props));\n  };\n  fn.prototype = Object.create(base);\n  fn[TypeId] = variance;\n  fn.pipe = function pipe() {\n    return pipeArguments(this, arguments);\n  };\n  Object.defineProperty(fn, \"ast\", {\n    get() {\n      if (this._ast) {\n        return this._ast;\n      }\n      const toSchema = to(selfSchema);\n      this._ast = transform(selfSchema, declare([toSchema], toSchema, () => (input, _, ast) => input instanceof this ? success(input) : failure(type(ast, input)), {\n        [DescriptionAnnotationId]: `an instance of ${this.name}`,\n        [ArbitraryHookId]: struct => fc => struct(fc).map(props => new this(props))\n      }), input => Object.assign(Object.create(this.prototype), input), input => ({\n        ...input\n      })).ast;\n      return this._ast;\n    }\n  });\n  fn.struct = selfSchema;\n  fn.extend = function () {\n    return fields => {\n      const newFields = {\n        ...selfFields,\n        ...fields\n      };\n      return makeClass(struct(newFields), newFields, this.prototype);\n    };\n  };\n  fn.transform = function () {\n    return (fields, decode, encode) => {\n      const newFields = {\n        ...selfFields,\n        ...fields\n      };\n      return makeClass(transformOrFail(selfSchema, to(struct(newFields)), decode, encode), newFields, this.prototype);\n    };\n  };\n  fn.transformFrom = function () {\n    return (fields, decode, encode) => {\n      const newFields = {\n        ...selfFields,\n        ...fields\n      };\n      return makeClass(transformOrFail(from(selfSchema), struct(newFields), decode, encode), newFields, this.prototype);\n    };\n  };\n  return fn;\n};\n\nexport { Base64, Base64Url, BetweenBigintTypeId, BetweenTypeId, BigintFromNumber, BrandTypeId, Class, _Date as Date, DateFromSelf, EndsWithTypeId, Finite, FiniteTypeId, GreaterThanBigintTypeId, GreaterThanOrEqualToBigintTypeId, GreaterThanOrEqualToTypeId, GreaterThanTypeId, Hex, IncludesTypeId, InstanceOfTypeId, Int, IntTypeId, ItemsCountTypeId, JsonNumber, JsonNumberTypeId, LengthTypeId, LessThanBigintTypeId, LessThanOrEqualToBigintTypeId, LessThanOrEqualToTypeId, LessThanTypeId, Lowercase, LowercasedTypeId, MaxItemsTypeId, MaxLengthTypeId, MinItemsTypeId, MinLengthTypeId, MultipleOfTypeId, Negative, NegativeBigint, NegativeBigintFromSelf, NonEmpty, NonNaN, NonNaNTypeId, NonNegative, NonNegativeBigint, NonNegativeBigintFromSelf, NonPositive, NonPositiveBigint, NonPositiveBigintFromSelf, Not, NumberFromString, ParseJson, PatternTypeId, Positive, PositiveBigint, PositiveBigintFromSelf, PropertySignatureImpl, StartsWithTypeId, Trim, Trimmed, TrimmedTypeId, ULID, ULIDTypeId, UUID, UUIDTypeId, _Uint8Array as Uint8Array, Uint8ArrayFromSelf, ValidDate, ValidDateFromSelf, ValidDateTypeId, annotations, any, array, attachPropertySignature, base64, base64url, between, betweenBigint, bigint, bigintFromNumber, bigintFromSelf, bigintFromString, boolean, brand, chunk, chunkFromSelf, clamp, clampBigint, compose, data, dataFromSelf, dateFromString, declare, description, documentation, either, eitherFromSelf, element, endsWith, enums, examples, extend, filter, finite, from, fromBrand, greaterThan, greaterThanBigint, greaterThanOrEqualTo, greaterThanOrEqualToBigint, hex, identifier, includes, instanceOf, int, intersectUnionMembers, isSchema, itemsCount, jsonSchema, keyof, lazy, length, lessThan, lessThanBigint, lessThanOrEqualTo, lessThanOrEqualToBigint, literal, lowercase, lowercased, make, maxItems, maxLength, message, minItems, minLength, multipleOf, mutable, negative, negativeBigint, never, nonEmpty, nonEmptyArray, nonNaN, nonNegative, nonNegativeBigint, nonPositive, nonPositiveBigint, not, _null as null, nullable, number, numberFromString, object, omit, option, optionFromNullable, optionFromSelf, optional, optionalElement, parseJson, partial, pattern, pick, positive, positiveBigint, propertySignature, readonlyMap, readonlyMapFromSelf, readonlySet, readonlySetFromSelf, record, required, rest, split, startsWith, string, struct, symbol, symbolFromSelf, symbolFromString, templateLiteral, title, to, transform, transformOrFail, trim, trimmed, tuple, uint8ArrayFromNumbers, _undefined as undefined, union, uniqueSymbol, unknown, validDate, _void as void };\n","import { head, prepend, filter, isEmpty as isEmpty$2, fromIterable as fromIterable$1, appendAll, append, empty as empty$1 } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { pipe, dual } from '../Function/dist/effect-Function.esm.js';\nimport { flatMap, sync, map, deferredMake, fiberId, withFiberRuntime, unit, succeed, deferredUnsafeDone, deferredInterruptWith, asUnit, deferredUnsafeMake, onInterrupt, suspend, interrupt, deferredAwait, catchAll, uninterruptible, whenEffect, deferredSucceed, zipRight } from './core.esm.js';\nimport { forEachParUnboundedDiscard } from './fiberRuntime.esm.js';\nimport { bounded as bounded$1, unbounded as unbounded$1, length, isEmpty as isEmpty$1, poll as poll$1, EmptyMutableQueue, offer as offer$1, offerAll as offerAll$1, pollUpTo, capacity as capacity$1 } from '../MutableQueue/dist/effect-MutableQueue.esm.js';\nimport { make as make$1, get, set } from '../MutableRef/dist/effect-MutableRef.esm.js';\nimport { none, some } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { fromIterable, empty, splitAt } from '../ReadonlyArray/dist/effect-ReadonlyArray.esm.js';\n\n/** @internal */\nconst EnqueueSymbolKey = \"effect/QueueEnqueue\";\n\n/** @internal */\nconst EnqueueTypeId = /*#__PURE__*/Symbol.for(EnqueueSymbolKey);\n\n/** @internal */\nconst DequeueSymbolKey = \"effect/QueueDequeue\";\n\n/** @internal */\nconst DequeueTypeId = /*#__PURE__*/Symbol.for(DequeueSymbolKey);\n\n/** @internal */\nconst QueueStrategySymbolKey = \"effect/QueueStrategy\";\n\n/** @internal */\nconst QueueStrategyTypeId = /*#__PURE__*/Symbol.for(QueueStrategySymbolKey);\n\n/** @internal */\nconst queueStrategyVariance = {\n  _A: _ => _\n};\n\n/** @internal */\nconst enqueueVariance = {\n  _In: _ => _\n};\n\n/** @internal */\nconst dequeueVariance = {\n  _Out: _ => _\n};\n\n/** @internal */\nclass QueueImpl {\n  [EnqueueTypeId] = enqueueVariance;\n  [DequeueTypeId] = dequeueVariance;\n  constructor( /** @internal */\n  queue, /** @internal */\n  takers, /** @internal */\n  shutdownHook, /** @internal */\n  shutdownFlag, /** @internal */\n  strategy) {\n    this.queue = queue;\n    this.takers = takers;\n    this.shutdownHook = shutdownHook;\n    this.shutdownFlag = shutdownFlag;\n    this.strategy = strategy;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  capacity() {\n    return this.queue.capacity();\n  }\n  size() {\n    return suspend(() => catchAll(this.unsafeSize(), () => interrupt));\n  }\n  unsafeSize() {\n    if (get(this.shutdownFlag)) {\n      return none();\n    }\n    return some(this.queue.length() - length(this.takers) + this.strategy.surplusSize());\n  }\n  isEmpty() {\n    return map(this.size(), size => size <= 0);\n  }\n  isFull() {\n    return map(this.size(), size => size >= this.capacity());\n  }\n  shutdown() {\n    return uninterruptible(withFiberRuntime(state => {\n      pipe(this.shutdownFlag, set(true));\n      return pipe(forEachParUnboundedDiscard(unsafePollAll(this.takers), d => deferredInterruptWith(d, state.id()), false), zipRight(this.strategy.shutdown()), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asUnit);\n    }));\n  }\n  isShutdown() {\n    return sync(() => get(this.shutdownFlag));\n  }\n  awaitShutdown() {\n    return deferredAwait(this.shutdownHook);\n  }\n  isActive() {\n    return !get(this.shutdownFlag);\n  }\n  unsafeOffer(value) {\n    if (get(this.shutdownFlag)) {\n      return false;\n    }\n    let noRemaining;\n    if (this.queue.length() === 0) {\n      const taker = pipe(this.takers, poll$1(EmptyMutableQueue));\n      if (taker !== EmptyMutableQueue) {\n        unsafeCompleteDeferred(taker, value);\n        noRemaining = true;\n      } else {\n        noRemaining = false;\n      }\n    } else {\n      noRemaining = false;\n    }\n    if (noRemaining) {\n      return true;\n    }\n    // Not enough takers, offer to the queue\n    const succeeded = this.queue.offer(value);\n    unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n    return succeeded;\n  }\n  offer(value) {\n    return suspend(() => {\n      if (get(this.shutdownFlag)) {\n        return interrupt;\n      }\n      let noRemaining;\n      if (this.queue.length() === 0) {\n        const taker = pipe(this.takers, poll$1(EmptyMutableQueue));\n        if (taker !== EmptyMutableQueue) {\n          unsafeCompleteDeferred(taker, value);\n          noRemaining = true;\n        } else {\n          noRemaining = false;\n        }\n      } else {\n        noRemaining = false;\n      }\n      if (noRemaining) {\n        return succeed(true);\n      }\n      // Not enough takers, offer to the queue\n      const succeeded = this.queue.offer(value);\n      unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n      return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);\n    });\n  }\n  offerAll(iterable) {\n    return suspend(() => {\n      if (get(this.shutdownFlag)) {\n        return interrupt;\n      }\n      const values = fromIterable(iterable);\n      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values.length)) : empty;\n      const [forTakers, remaining] = pipe(values, splitAt(pTakers.length));\n      for (let i = 0; i < pTakers.length; i++) {\n        const taker = pTakers[i];\n        const item = forTakers[i];\n        unsafeCompleteDeferred(taker, item);\n      }\n      if (remaining.length === 0) {\n        return succeed(true);\n      }\n      // Not enough takers, offer to the queue\n      const surplus = this.queue.offerAll(remaining);\n      unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n      return isEmpty$2(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);\n    });\n  }\n  take() {\n    return withFiberRuntime(state => {\n      if (get(this.shutdownFlag)) {\n        return interrupt;\n      }\n      const item = this.queue.poll(EmptyMutableQueue);\n      if (item !== EmptyMutableQueue) {\n        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n        return succeed(item);\n      } else {\n        // Add the deferred to takers, then:\n        // - Try to take again in case a value was added since\n        // - Wait for the deferred to be completed\n        // - Clean up resources in case of interruption\n        const deferred = deferredUnsafeMake(state.id());\n        return pipe(suspend(() => {\n          pipe(this.takers, offer$1(deferred));\n          unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n          return get(this.shutdownFlag) ? interrupt : deferredAwait(deferred);\n        }), onInterrupt(() => {\n          return sync(() => unsafeRemove(this.takers, deferred));\n        }));\n      }\n    });\n  }\n  takeAll() {\n    return suspend(() => {\n      return get(this.shutdownFlag) ? interrupt : sync(() => {\n        const values = this.queue.pollUpTo(Number.POSITIVE_INFINITY);\n        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n        return fromIterable$1(values);\n      });\n    });\n  }\n  takeUpTo(max) {\n    return suspend(() => get(this.shutdownFlag) ? interrupt : sync(() => {\n      const values = this.queue.pollUpTo(max);\n      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n      return fromIterable$1(values);\n    }));\n  }\n  takeBetween(min, max) {\n    return suspend(() => takeRemainderLoop(this, min, max, empty$1()));\n  }\n}\n\n/** @internal */\nconst takeRemainderLoop = (self, min, max, acc) => {\n  if (max < min) {\n    return succeed(acc);\n  }\n  return pipe(takeUpTo(self, max), flatMap(bs => {\n    const remaining = min - bs.length;\n    if (remaining === 1) {\n      return pipe(take(self), map(b => pipe(acc, appendAll(bs), append(b))));\n    }\n    if (remaining > 1) {\n      return pipe(take(self), flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, pipe(acc, appendAll(bs), append(b)))));\n    }\n    return succeed(pipe(acc, appendAll(bs)));\n  }));\n};\n\n/** @internal */\nconst isQueue = u => isEnqueue(u) && isDequeue(u);\n\n/** @internal */\nconst isEnqueue = u => typeof u === \"object\" && u != null && EnqueueTypeId in u;\n\n/** @internal */\nconst isDequeue = u => typeof u === \"object\" && u != null && DequeueTypeId in u;\n\n/** @internal */\nconst bounded = requestedCapacity => pipe(sync(() => bounded$1(requestedCapacity)), flatMap(queue => make(backingQueueFromMutableQueue(queue), backPressureStrategy())));\n\n/** @internal */\nconst dropping = requestedCapacity => pipe(sync(() => bounded$1(requestedCapacity)), flatMap(queue => make(backingQueueFromMutableQueue(queue), droppingStrategy())));\n\n/** @internal */\nconst sliding = requestedCapacity => pipe(sync(() => bounded$1(requestedCapacity)), flatMap(queue => make(backingQueueFromMutableQueue(queue), slidingStrategy())));\n\n/** @internal */\nconst unbounded = () => pipe(sync(() => unbounded$1()), flatMap(queue => make(backingQueueFromMutableQueue(queue), droppingStrategy())));\n\n/** @internal */\nconst unsafeMake = (queue, takers, shutdownHook, shutdownFlag, strategy) => {\n  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);\n};\n\n/** @internal */\nconst make = (queue, strategy) => pipe(deferredMake(), map(deferred => unsafeMake(queue, unbounded$1(), deferred, make$1(false), strategy)));\n\n/** @internal */\nclass BackingQueueFromMutableQueue {\n  constructor(mutable) {\n    this.mutable = mutable;\n  }\n  poll(def) {\n    return poll$1(this.mutable, def);\n  }\n  pollUpTo(limit) {\n    return pollUpTo(this.mutable, limit);\n  }\n  offerAll(elements) {\n    return offerAll$1(this.mutable, elements);\n  }\n  offer(element) {\n    return offer$1(this.mutable, element);\n  }\n  capacity() {\n    return capacity$1(this.mutable);\n  }\n  length() {\n    return length(this.mutable);\n  }\n}\n\n/** @internal */\nconst backingQueueFromMutableQueue = mutable => new BackingQueueFromMutableQueue(mutable);\n\n/** @internal */\nconst capacity = self => self.capacity();\n\n/** @internal */\nconst size = self => self.size();\n\n/** @internal */\nconst isFull = self => self.isFull();\n\n/** @internal */\nconst isEmpty = self => self.isEmpty();\n\n/** @internal */\nconst isShutdown = self => self.isShutdown();\n\n/** @internal */\nconst awaitShutdown = self => self.awaitShutdown();\n\n/** @internal */\nconst shutdown = self => self.shutdown();\n\n/** @internal */\nconst offer = /*#__PURE__*/dual(2, (self, value) => self.offer(value));\n\n/** @internal */\nconst unsafeOffer = /*#__PURE__*/dual(2, (self, value) => self.unsafeOffer(value));\n\n/** @internal */\nconst offerAll = /*#__PURE__*/dual(2, (self, iterable) => self.offerAll(iterable));\n\n/** @internal */\nconst poll = self => map(self.takeUpTo(1), head);\n\n/** @internal */\nconst take = self => self.take();\n\n/** @internal */\nconst takeAll = self => self.takeAll();\n\n/** @internal */\nconst takeUpTo = /*#__PURE__*/dual(2, (self, max) => self.takeUpTo(max));\n\n/** @internal */\nconst takeBetween = /*#__PURE__*/dual(3, (self, min, max) => self.takeBetween(min, max));\n\n/** @internal */\nconst takeN = /*#__PURE__*/dual(2, (self, n) => self.takeBetween(n, n));\n\n// -----------------------------------------------------------------------------\n// Strategy\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst backPressureStrategy = () => new BackPressureStrategy();\n\n/** @internal */\nconst droppingStrategy = () => new DroppingStrategy();\n\n/** @internal */\nconst slidingStrategy = () => new SlidingStrategy();\n\n/** @internal */\nclass BackPressureStrategy {\n  [QueueStrategyTypeId] = queueStrategyVariance;\n  putters = unbounded$1();\n  surplusSize() {\n    return length(this.putters);\n  }\n  onCompleteTakersWithEmptyQueue(takers) {\n    while (!isEmpty$1(this.putters) && !isEmpty$1(takers)) {\n      const taker = poll$1(takers, void 0);\n      const putter = poll$1(this.putters, void 0);\n      if (putter[2]) {\n        unsafeCompleteDeferred(putter[1], true);\n      }\n      unsafeCompleteDeferred(taker, putter[0]);\n    }\n  }\n  shutdown() {\n    return pipe(fiberId, flatMap(fiberId => pipe(sync(() => unsafePollAll(this.putters)), flatMap(putters => forEachParUnboundedDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId), asUnit) : unit, false)))));\n  }\n  handleSurplus(iterable, queue, takers, isShutdown) {\n    return withFiberRuntime(state => {\n      const deferred = deferredUnsafeMake(state.id());\n      return pipe(suspend(() => {\n        this.unsafeOffer(iterable, deferred);\n        this.unsafeOnQueueEmptySpace(queue, takers);\n        unsafeCompleteTakers(this, queue, takers);\n        return get(isShutdown) ? interrupt : deferredAwait(deferred);\n      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));\n    });\n  }\n  unsafeOnQueueEmptySpace(queue, takers) {\n    let keepPolling = true;\n    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {\n      const putter = pipe(this.putters, poll$1(EmptyMutableQueue));\n      if (putter === EmptyMutableQueue) {\n        keepPolling = false;\n      } else {\n        const offered = queue.offer(putter[0]);\n        if (offered && putter[2]) {\n          unsafeCompleteDeferred(putter[1], true);\n        } else if (!offered) {\n          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend(putter)));\n        }\n        unsafeCompleteTakers(this, queue, takers);\n      }\n    }\n  }\n  unsafeOffer(iterable, deferred) {\n    const stuff = Array.from(iterable);\n    for (let i = 0; i < stuff.length; i++) {\n      const value = stuff[i];\n      if (i === stuff.length - 1) {\n        pipe(this.putters, offer$1([value, deferred, true]));\n      } else {\n        pipe(this.putters, offer$1([value, deferred, false]));\n      }\n    }\n  }\n  unsafeRemove(deferred) {\n    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter(([, _]) => _ !== deferred)));\n  }\n}\n\n/** @internal */\nclass DroppingStrategy {\n  [QueueStrategyTypeId] = queueStrategyVariance;\n  surplusSize() {\n    return 0;\n  }\n  shutdown() {\n    return unit;\n  }\n  onCompleteTakersWithEmptyQueue() {}\n  handleSurplus(_iterable, _queue, _takers, _isShutdown) {\n    return succeed(false);\n  }\n  unsafeOnQueueEmptySpace(_queue, _takers) {\n    //\n  }\n}\n\n/** @internal */\nclass SlidingStrategy {\n  [QueueStrategyTypeId] = queueStrategyVariance;\n  surplusSize() {\n    return 0;\n  }\n  shutdown() {\n    return unit;\n  }\n  onCompleteTakersWithEmptyQueue() {}\n  handleSurplus(iterable, queue, takers, _isShutdown) {\n    return sync(() => {\n      this.unsafeOffer(queue, iterable);\n      unsafeCompleteTakers(this, queue, takers);\n      return true;\n    });\n  }\n  unsafeOnQueueEmptySpace(_queue, _takers) {\n    //\n  }\n  unsafeOffer(queue, iterable) {\n    const iterator = iterable[Symbol.iterator]();\n    let next;\n    let offering = true;\n    while (!(next = iterator.next()).done && offering) {\n      if (queue.capacity() === 0) {\n        return;\n      }\n      // Poll 1 and retry\n      queue.poll(EmptyMutableQueue);\n      offering = queue.offer(next.value);\n    }\n  }\n}\n\n/** @internal */\nconst unsafeCompleteDeferred = (deferred, a) => {\n  return deferredUnsafeDone(deferred, succeed(a));\n};\n\n/** @internal */\nconst unsafeOfferAll = (queue, as) => {\n  return pipe(queue, offerAll$1(as));\n};\n\n/** @internal */\nconst unsafePollAll = queue => {\n  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));\n};\n\n/** @internal */\nconst unsafePollN = (queue, max) => {\n  return pipe(queue, pollUpTo(max));\n};\n\n/** @internal */\nconst unsafeRemove = (queue, a) => {\n  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter(b => a !== b)));\n};\n\n/** @internal */\nconst unsafeCompleteTakers = (strategy, queue, takers) => {\n  // Check both a taker and an item are in the queue, starting with the taker\n  let keepPolling = true;\n  while (keepPolling && queue.length() !== 0) {\n    const taker = pipe(takers, poll$1(EmptyMutableQueue));\n    if (taker !== EmptyMutableQueue) {\n      const element = queue.poll(EmptyMutableQueue);\n      if (element !== EmptyMutableQueue) {\n        unsafeCompleteDeferred(taker, element);\n        strategy.unsafeOnQueueEmptySpace(queue, takers);\n      } else {\n        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend(taker)));\n      }\n      keepPolling = true;\n    } else {\n      keepPolling = false;\n    }\n  }\n  if (keepPolling && queue.length() === 0 && !isEmpty$1(takers)) {\n    strategy.onCompleteTakersWithEmptyQueue(takers);\n  }\n};\n\nexport { BackingQueueFromMutableQueue, DequeueTypeId, EnqueueTypeId, QueueStrategyTypeId, awaitShutdown, backPressureStrategy, backingQueueFromMutableQueue, bounded, capacity, dequeueVariance, dropping, droppingStrategy, enqueueVariance, isDequeue, isEmpty, isEnqueue, isFull, isQueue, isShutdown, make, offer, offerAll, poll, shutdown, size, sliding, slidingStrategy, take, takeAll, takeBetween, takeN, takeUpTo, unbounded, unsafeCompleteTakers, unsafeOffer, unsafeRemove };\n","import { EnqueueTypeId as EnqueueTypeId$1, DequeueTypeId as DequeueTypeId$1, QueueStrategyTypeId as QueueStrategyTypeId$1, isQueue as isQueue$1, isDequeue as isDequeue$1, isEnqueue as isEnqueue$1, backPressureStrategy as backPressureStrategy$1, droppingStrategy as droppingStrategy$1, slidingStrategy as slidingStrategy$1, make as make$1, bounded as bounded$1, dropping as dropping$1, sliding as sliding$1, unbounded as unbounded$1, capacity as capacity$1, size as size$1, isEmpty as isEmpty$1, isFull as isFull$1, isShutdown as isShutdown$1, awaitShutdown as awaitShutdown$1, shutdown as shutdown$1, offer as offer$1, unsafeOffer as unsafeOffer$1, offerAll as offerAll$1, poll as poll$1, take as take$1, takeAll as takeAll$1, takeUpTo as takeUpTo$1, takeBetween as takeBetween$1, takeN as takeN$1 } from '../../internal/queue.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst EnqueueTypeId = EnqueueTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst DequeueTypeId = DequeueTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst QueueStrategyTypeId = QueueStrategyTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * The base interface that all `Queue`s must implement.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Returns `true` if the specified value is a `Queue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isQueue = isQueue$1;\n\n/**\n * Returns `true` if the specified value is a `Dequeue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isDequeue = isDequeue$1;\n\n/**\n * Returns `true` if the specified value is a `Enqueue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isEnqueue = isEnqueue$1;\n\n/**\n * @since 2.0.0\n * @category strategies\n */\nconst backPressureStrategy = backPressureStrategy$1;\n\n/**\n * @since 2.0.0\n * @category strategies\n */\nconst droppingStrategy = droppingStrategy$1;\n\n/**\n * @since 2.0.0\n * @category strategies\n */\nconst slidingStrategy = slidingStrategy$1;\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Makes a new bounded `Queue`. When the capacity of the queue is reached, any\n * additional calls to `offer` will be suspended until there is more room in\n * the queue.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst bounded = bounded$1;\n\n/**\n * Makes a new bounded `Queue` with the dropping strategy.\n *\n * When the capacity of the queue is reached, new elements will be dropped and the\n * old elements will remain.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst dropping = dropping$1;\n\n/**\n * Makes a new bounded `Queue` with the sliding strategy.\n *\n * When the capacity of the queue is reached, new elements will be added and the\n * old elements will be dropped.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst sliding = sliding$1;\n\n/**\n * Creates a new unbounded `Queue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unbounded = unbounded$1;\n\n/**\n * Returns the number of elements the queue can hold.\n *\n * @since 2.0.0\n * @category getters\n */\nconst capacity = capacity$1;\n\n/**\n * Retrieves the size of the queue, which is equal to the number of elements\n * in the queue. This may be negative if fibers are suspended waiting for\n * elements to be added to the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nconst size = size$1;\n\n/**\n * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isEmpty = isEmpty$1;\n\n/**\n * Returns `true` if the `Queue` contains at least one element, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isFull = isFull$1;\n\n/**\n * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isShutdown = isShutdown$1;\n\n/**\n * Waits until the queue is shutdown. The `Effect` returned by this method will\n * not resume until the queue has been shutdown. If the queue is already\n * shutdown, the `Effect` will resume right away.\n *\n * @since 2.0.0\n * @category utils\n */\nconst awaitShutdown = awaitShutdown$1;\n\n/**\n * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n * to `offer*` and `take*` will be interrupted immediately.\n *\n * @since 2.0.0\n * @category utils\n */\nconst shutdown = shutdown$1;\n\n/**\n * Places one value in the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nconst offer = offer$1;\n\n/**\n * Places one value in the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nconst unsafeOffer = unsafeOffer$1;\n\n/**\n * For Bounded Queue: uses the `BackPressure` Strategy, places the values in\n * the queue and always returns true. If the queue has reached capacity, then\n * the fiber performing the `offerAll` will be suspended until there is room\n * in the queue.\n *\n * For Unbounded Queue: Places all values in the queue and returns true.\n *\n * For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\n * it places the values otherwise it removes the old elements and enqueues the\n * new ones. Always returns true.\n *\n * For Dropping Queue: uses `Dropping` Strategy, It places the values in the\n * queue but if there is no room it will not enqueue them and return false.\n *\n * @since 2.0.0\n * @category utils\n */\nconst offerAll = offerAll$1;\n\n/**\n * Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\n * is empty.\n *\n * @since 2.0.0\n * @category utils\n */\nconst poll = poll$1;\n\n/**\n * Takes the oldest value in the queue. If the queue is empty, this will return\n * a computation that resumes when an item has been added to the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nconst take = take$1;\n\n/**\n * Takes all the values in the queue and returns the values. If the queue is\n * empty returns an empty collection.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeAll = takeAll$1;\n\n/**\n * Takes up to max number of values from the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeUpTo = takeUpTo$1;\n\n/**\n * Takes a number of elements from the queue between the specified minimum and\n * maximum. If there are fewer than the minimum number of elements available,\n * suspends until at least the minimum number of elements have been collected.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeBetween = takeBetween$1;\n\n/**\n * Takes the specified number of elements from the queue. If there are fewer\n * than the specified number of elements available, it suspends until they\n * become available.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeN = takeN$1;\n\nexport { DequeueTypeId, EnqueueTypeId, QueueStrategyTypeId, awaitShutdown, backPressureStrategy, bounded, capacity, dropping, droppingStrategy, isDequeue, isEmpty, isEnqueue, isFull, isQueue, isShutdown, make, offer, offerAll, poll, shutdown, size, sliding, slidingStrategy, take, takeAll, takeBetween, takeN, takeUpTo, unbounded, unsafeOffer };\n","import { add } from '../../Context/dist/effect-Context.esm.js';\nimport { clockTag } from '../../internal/clock.esm.js';\nimport { currentRequestBatching, isEffect, flatMap as flatMap$2, currentTracerTimingEnabled, currentUnhandledErrorLogLevel } from '../../internal/core.esm.js';\nimport { currentServices } from '../../internal/defaultServices.esm.js';\nimport { fiberRefLocallyScopedWith as fiberRefLocallyScopedWith$2, fiberRefLocallyScoped as fiberRefLocallyScoped$1 } from '../../internal/fiberRuntime.esm.js';\nimport { LayerTypeId as LayerTypeId$1, isLayer as isLayer$1, isFresh as isFresh$1, build as build$1, buildWithScope as buildWithScope$1, catchAll as catchAll$1, catchAllCause as catchAllCause$1, context as context$1, die as die$1, dieSync as dieSync$1, discard as discard$1, fromEffect, fromEffectDiscard, fromEffectContext, extendScope as extendScope$1, fail as fail$1, failSync as failSync$1, failCause as failCause$1, failCauseSync as failCauseSync$1, flatMap as flatMap$1, flatten as flatten$1, fresh as fresh$1, fromFunction as fromFunction$1, launch as launch$1, map as map$1, mapError as mapError$1, match as match$1, matchCause as matchCause$1, memoize as memoize$1, merge as merge$1, mergeAll as mergeAll$1, orDie as orDie$1, orElse as orElse$1, passthrough as passthrough$1, project as project$1, provide as provide$1, locallyEffect as locallyEffect$1, fiberRefLocally, fiberRefLocallyWith, fiberRefLocallyScoped, fiberRefLocallyScopedWith as fiberRefLocallyScopedWith$1, provideMerge as provideMerge$1, retry as retry$1, scope as scope$1, scoped as scoped$1, scopedDiscard as scopedDiscard$1, scopedContext as scopedContext$1, service as service$1, succeed as succeed$1, succeedContext as succeedContext$1, suspend as suspend$1, sync as sync$1, syncContext as syncContext$1, tap as tap$1, tapError as tapError$1, tapErrorCause as tapErrorCause$1, toRuntime as toRuntime$1, use as use$1, useMerge as useMerge$1, zipWithPar as zipWithPar$1, unwrapEffect as unwrapEffect$1, unwrapScoped as unwrapScoped$1, withSpan as withSpan$1, withParentSpan as withParentSpan$1 } from '../../internal/layer.esm.js';\nimport { setConfigProvider as setConfigProvider$1, setParentSpan as setParentSpan$1, setSpan as setSpan$1, setTracer as setTracer$1 } from '../../internal/layer/circular.esm.js';\nimport { currentCacheEnabled, currentCache } from '../../internal/query.esm.js';\nimport { currentScheduler } from '../../Scheduler/dist/effect-Scheduler.esm.js';\n\n/**\n * A `Layer<RIn, E, ROut>` describes how to build one or more services in your\n * application. Services can be injected into effects via\n * `Effect.provideService`. Effects can require services via `Effect.service`.\n *\n * Layer can be thought of as recipes for producing bundles of services, given\n * their dependencies (other services).\n *\n * Construction of services can be effectful and utilize resources that must be\n * acquired and safely released when the services are done being utilized.\n *\n * By default layers are shared, meaning that if the same layer is used twice\n * the layer will only be allocated a single time.\n *\n * Because of their excellent composition properties, layers are the idiomatic\n * way in Effect-TS to create services that depend on other services.\n *\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst LayerTypeId = LayerTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * Returns `true` if the specified value is a `Layer`, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isLayer = isLayer$1;\n\n/**\n * Returns `true` if the specified `Layer` is a fresh version that will not be\n * shared, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nconst isFresh = isFresh$1;\n\n/**\n * Builds a layer into a scoped value.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst build = build$1;\n\n/**\n * Builds a layer into an `Effect` value. Any resources associated with this\n * layer will be released when the specified scope is closed unless their scope\n * has been extended. This allows building layers where the lifetime of some of\n * the services output by the layer exceed the lifetime of the effect the\n * layer is provided to.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst buildWithScope = buildWithScope$1;\n\n/**\n * Recovers from all errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAll = catchAll$1;\n\n/**\n * Recovers from all errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAllCause = catchAllCause$1;\n\n/**\n * Constructs a `Layer` that passes along the specified context as an\n * output.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst context = context$1;\n\n/**\n * Constructs a layer that dies with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst die = die$1;\n\n/**\n * Constructs a layer that dies with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst dieSync = dieSync$1;\n\n/**\n * Replaces the layer's output with `void` and includes the layer only for its\n * side-effects.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst discard = discard$1;\n\n/**\n * Constructs a layer from the specified effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst effect = fromEffect;\n\n/**\n * Constructs a layer from the specified effect discarding it's output.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst effectDiscard = fromEffectDiscard;\n\n/**\n * Constructs a layer from the specified effect, which must return one or more\n * services.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst effectContext = fromEffectContext;\n\n/**\n * Extends the scope of this layer, returning a new layer that when provided\n * to an effect will not immediately release its associated resources when\n * that effect completes execution but instead when the scope the resulting\n * effect depends on is closed.\n *\n * @since 2.0.0\n * @category utils\n */\nconst extendScope = extendScope$1;\n\n/**\n * Constructs a layer that fails with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fail = fail$1;\n\n/**\n * Constructs a layer that fails with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failSync = failSync$1;\n\n/**\n * Constructs a layer that fails with the specified cause.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failCause = failCause$1;\n\n/**\n * Constructs a layer that fails with the specified cause.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failCauseSync = failCauseSync$1;\n\n/**\n * Constructs a layer dynamically based on the output of this layer.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = flatMap$1;\n\n/**\n * Flattens layers nested in the context of an effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatten = flatten$1;\n\n/**\n * Creates a fresh version of this layer that will not be shared.\n *\n * @since 2.0.0\n * @category utils\n */\nconst fresh = fresh$1;\nconst fromFunction = fromFunction$1;\n\n/**\n * Builds this layer and uses it until it is interrupted. This is useful when\n * your entire application is a layer, such as an HTTP server.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst launch = launch$1;\n\n/**\n * Returns a new layer whose output is mapped by the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * Returns a layer with its error channel mapped using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapError = mapError$1;\n\n/**\n * Feeds the error or output services of this layer into the input of either\n * the specified `failure` or `success` layers, resulting in a new layer with\n * the inputs of this layer, and the error or outputs of the specified layer.\n *\n * @since 2.0.0\n * @category folding\n */\nconst match = match$1;\n\n/**\n * Feeds the error or output services of this layer into the input of either\n * the specified `failure` or `success` layers, resulting in a new layer with\n * the inputs of this layer, and the error or outputs of the specified layer.\n *\n * @since 2.0.0\n * @category folding\n */\nconst matchCause = matchCause$1;\n\n/**\n * Returns a scoped effect that, if evaluated, will return the lazily computed\n * result of this layer.\n *\n * @since 2.0.0\n * @category utils\n */\nconst memoize = memoize$1;\n\n/**\n * Combines this layer with the specified layer, producing a new layer that\n * has the inputs and outputs of both.\n *\n * @since 2.0.0\n * @category utils\n */\nconst merge = merge$1;\n\n/**\n * Merges all the layers together in parallel.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst mergeAll = mergeAll$1;\n\n/**\n * Translates effect failure into death of the fiber, making all failures\n * unchecked and not a part of the type of the layer.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orDie = orDie$1;\n\n/**\n * Executes this layer and returns its output, if it succeeds, but otherwise\n * executes the specified layer.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElse = orElse$1;\n\n/**\n * Returns a new layer that produces the outputs of this layer but also\n * passes through the inputs.\n *\n * @since 2.0.0\n * @category utils\n */\nconst passthrough = passthrough$1;\n\n/**\n * Projects out part of one of the services output by this layer using the\n * specified function.\n *\n * @since 2.0.0\n * @category utils\n */\nconst project = project$1;\n\n/**\n * Feeds the output services of this builder into the input of the specified\n * builder, resulting in a new builder with the inputs of this builder as\n * well as any leftover inputs, and the outputs of the specified builder.\n *\n * @since 2.0.0\n * @category utils\n */\nconst provide = provide$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst locallyEffect = locallyEffect$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst locally = fiberRefLocally;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst locallyWith = fiberRefLocallyWith;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst locallyScoped = fiberRefLocallyScoped;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst fiberRefLocallyScopedWith = fiberRefLocallyScopedWith$1;\n\n/**\n * Feeds the output services of this layer into the input of the specified\n * layer, resulting in a new layer with the inputs of this layer, and the\n * outputs of both layers.\n *\n * @since 2.0.0\n * @category utils\n */\nconst provideMerge = provideMerge$1;\n\n/**\n * Retries constructing this layer according to the specified schedule.\n *\n * @since 2.0.0\n * @category retrying\n */\nconst retry = retry$1;\n\n/**\n * A layer that constructs a scope and closes it when the workflow the layer\n * is provided to completes execution, whether by success, failure, or\n * interruption. This can be used to close a scope when providing a layer to a\n * workflow.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst scope = scope$1;\n\n/**\n * Constructs a layer from the specified scoped effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst scoped = scoped$1;\n\n/**\n * Constructs a layer from the specified scoped effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst scopedDiscard = scopedDiscard$1;\n\n/**\n * Constructs a layer from the specified scoped effect, which must return one\n * or more services.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst scopedContext = scopedContext$1;\n\n/**\n * Constructs a layer that accesses and returns the specified service from the\n * context.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst service = service$1;\n\n/**\n * Constructs a layer from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeed = succeed$1;\n\n/**\n * Constructs a layer from the specified value, which must return one or more\n * services.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeedContext = succeedContext$1;\n\n/**\n * Lazily constructs a layer. This is useful to avoid infinite recursion when\n * creating layers that refer to themselves.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst suspend = suspend$1;\n\n/**\n * Lazily constructs a layer from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst sync = sync$1;\n\n/**\n * Lazily constructs a layer from the specified value, which must return one or more\n * services.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst syncContext = syncContext$1;\n\n/**\n * Performs the specified effect if this layer succeeds.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tap = tap$1;\n\n/**\n * Performs the specified effect if this layer fails.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapError = tapError$1;\n\n/**\n * Performs the specified effect if this layer fails.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapErrorCause = tapErrorCause$1;\n\n/**\n * Converts a layer that requires no services into a scoped runtime, which can\n * be used to execute effects.\n *\n * @since 2.0.0\n * @category conversions\n */\nconst toRuntime = toRuntime$1;\n\n/**\n * Feeds the output services of this builder into the input of the specified\n * builder, resulting in a new builder with the inputs of this builder as\n * well as any leftover inputs, and the outputs of the specified builder.\n *\n * @since 2.0.0\n * @category utils\n */\nconst use = use$1;\n\n/**\n * Feeds the output services of this layer into the input of the specified\n * layer, resulting in a new layer with the inputs of this layer, and the\n * outputs of both layers.\n *\n * @since 2.0.0\n * @category utils\n */\nconst useMerge = useMerge$1;\n\n/**\n * Combines this layer the specified layer, producing a new layer that has the\n * inputs of both, and the outputs of both combined using the specified\n * function.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWithPar = zipWithPar$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst unwrapEffect = unwrapEffect$1;\n\n/**\n * @since 2.0.0\n * @category utils\n */\nconst unwrapScoped = unwrapScoped$1;\n\n/**\n * @since 2.0.0\n * @category clock\n */\nconst setClock = clock => scopedDiscard(fiberRefLocallyScopedWith$2(currentServices, add(clockTag, clock)));\n\n/**\n * Sets the current `ConfigProvider`.\n *\n * @since 2.0.0\n * @category config\n */\nconst setConfigProvider = setConfigProvider$1;\n\n/**\n * Adds the provided span to the span stack.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst setParentSpan = setParentSpan$1;\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst setRequestBatching = requestBatching => scopedDiscard(fiberRefLocallyScoped$1(currentRequestBatching, requestBatching));\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst setRequestCaching = requestCaching => scopedDiscard(fiberRefLocallyScoped$1(currentCacheEnabled, requestCaching));\n\n/**\n * @since 2.0.0\n * @category requests & batching\n */\nconst setRequestCache = cache => scopedDiscard(isEffect(cache) ? flatMap$2(cache, x => fiberRefLocallyScoped$1(currentCache, x)) : fiberRefLocallyScoped$1(currentCache, cache));\n\n/**\n * @since 2.0.0\n * @category scheduler\n */\nconst setScheduler = scheduler => scopedDiscard(fiberRefLocallyScoped$1(currentScheduler, scheduler));\n\n/**\n * Create and add a span to the current span stack.\n *\n * The span is ended when the Layer is released.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst setSpan = setSpan$1;\n\n/**\n * Create a Layer that sets the current Tracer\n *\n * @since 2.0.0\n * @category tracing\n */\nconst setTracer = setTracer$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst setTracerTiming = enabled => scopedDiscard(fiberRefLocallyScoped$1(currentTracerTimingEnabled, enabled));\n\n/**\n * @since 2.0.0\n * @category logging\n */\nconst setUnhandledErrorLogLevel = level => scopedDiscard(fiberRefLocallyScoped$1(currentUnhandledErrorLogLevel, level));\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst withSpan = withSpan$1;\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nconst withParentSpan = withParentSpan$1;\n\nexport { LayerTypeId, build, buildWithScope, catchAll, catchAllCause, context, die, dieSync, discard, effect, effectContext, effectDiscard, extendScope, fail, failCause, failCauseSync, failSync, fiberRefLocallyScopedWith, flatMap, flatten, fresh, fromFunction as function, isFresh, isLayer, launch, locally, locallyEffect, locallyScoped, locallyWith, map, mapError, match, matchCause, memoize, merge, mergeAll, orDie, orElse, passthrough, project, provide, provideMerge, retry, scope, scoped, scopedContext, scopedDiscard, service, setClock, setConfigProvider, setParentSpan, setRequestBatching, setRequestCache, setRequestCaching, setScheduler, setSpan, setTracer, setTracerTiming, setUnhandledErrorLogLevel, succeed, succeedContext, suspend, sync, syncContext, tap, tapError, tapErrorCause, toRuntime, unwrapEffect, unwrapScoped, use, useMerge, withParentSpan, withSpan, zipWithPar };\n","/** @internal */\nconst OP_CONTINUE = \"Continue\";\n\n/** @internal */\n\n/** @internal */\nconst OP_CLOSE = \"Close\";\n\n/** @internal */\n\n/** @internal */\nconst OP_YIELD = \"Yield\";\n\n/** @internal */\n\nexport { OP_CLOSE, OP_CONTINUE, OP_YIELD };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { OP_CONTINUE, OP_CLOSE, OP_YIELD } from '../opCodes/channelChildExecutorDecision.esm.js';\n\n/** @internal */\nconst ChildExecutorDecisionSymbolKey = \"effect/ChannelChildExecutorDecision\";\n\n/** @internal */\nconst ChildExecutorDecisionTypeId = /*#__PURE__*/Symbol.for(ChildExecutorDecisionSymbolKey);\n\n/** @internal */\nconst proto = {\n  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId\n};\n\n/** @internal */\nconst Continue = _ => {\n  const op = Object.create(proto);\n  op._tag = OP_CONTINUE;\n  return op;\n};\n\n/** @internal */\nconst Close = value => {\n  const op = Object.create(proto);\n  op._tag = OP_CLOSE;\n  op.value = value;\n  return op;\n};\n\n/** @internal */\nconst Yield = _ => {\n  const op = Object.create(proto);\n  op._tag = OP_YIELD;\n  return op;\n};\n\n/** @internal */\nconst isChildExecutorDecision = u => typeof u === \"object\" && u != null && ChildExecutorDecisionTypeId in u;\n\n/** @internal */\nconst isContinue = self => self._tag === OP_CONTINUE;\n\n/** @internal */\nconst isClose = self => self._tag === OP_CLOSE;\n\n/** @internal */\nconst isYield = self => self._tag === OP_YIELD;\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onClose,\n  onContinue,\n  onYield\n}) => {\n  switch (self._tag) {\n    case OP_CONTINUE:\n      {\n        return onContinue();\n      }\n    case OP_CLOSE:\n      {\n        return onClose(self.value);\n      }\n    case OP_YIELD:\n      {\n        return onYield();\n      }\n  }\n});\n\nexport { ChildExecutorDecisionTypeId, Close, Continue, Yield, isChildExecutorDecision, isClose, isContinue, isYield, match };\n","/** @internal */\nconst OP_CONTINUATION_K = \"ContinuationK\";\n\n/** @internal */\n\n/** @internal */\nconst OP_CONTINUATION_FINALIZER = \"ContinuationFinalizer\";\n\n/** @internal */\n\nexport { OP_CONTINUATION_FINALIZER, OP_CONTINUATION_K };\n","import { isFailure } from '../../Exit/dist/effect-Exit.esm.js';\nimport { OP_CONTINUATION_K, OP_CONTINUATION_FINALIZER } from '../opCodes/continuation.esm.js';\n\n/** @internal */\nconst ContinuationTypeId = /*#__PURE__*/Symbol.for(\"effect/ChannelContinuation\");\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst continuationVariance = {\n  _Env: _ => _,\n  _InErr: _ => _,\n  _InElem: _ => _,\n  _InDone: _ => _,\n  _OutErr: _ => _,\n  _OutDone: _ => _,\n  _OutErr2: _ => _,\n  _OutElem: _ => _,\n  _OutDone2: _ => _\n};\n\n/** @internal */\nclass ContinuationKImpl {\n  _tag = OP_CONTINUATION_K;\n  [ContinuationTypeId] = continuationVariance;\n  constructor(onSuccess, onHalt) {\n    this.onSuccess = onSuccess;\n    this.onHalt = onHalt;\n  }\n  onExit(exit) {\n    return isFailure(exit) ? this.onHalt(exit.cause) : this.onSuccess(exit.value);\n  }\n}\n\n/** @internal */\nclass ContinuationFinalizerImpl {\n  _tag = OP_CONTINUATION_FINALIZER;\n  [ContinuationTypeId] = continuationVariance;\n  constructor(finalizer) {\n    this.finalizer = finalizer;\n  }\n}\n\nexport { ContinuationFinalizerImpl, ContinuationKImpl, ContinuationTypeId };\n","/** @internal */\nconst OP_PULL_AFTER_NEXT = \"PullAfterNext\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PULL_AFTER_ALL_ENQUEUED = \"PullAfterAllEnqueued\";\n\n/** @internal */\n\nexport { OP_PULL_AFTER_ALL_ENQUEUED, OP_PULL_AFTER_NEXT };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { OP_PULL_AFTER_NEXT, OP_PULL_AFTER_ALL_ENQUEUED } from '../opCodes/channelUpstreamPullStrategy.esm.js';\n\n/** @internal */\nconst UpstreamPullStrategySymbolKey = \"effect/ChannelUpstreamPullStrategy\";\n\n/** @internal */\nconst UpstreamPullStrategyTypeId = /*#__PURE__*/Symbol.for(UpstreamPullStrategySymbolKey);\n\n/** @internal */\nconst upstreamPullStrategyVariance = {\n  _A: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance\n};\n\n/** @internal */\nconst PullAfterNext = emitSeparator => {\n  const op = Object.create(proto);\n  op._tag = OP_PULL_AFTER_NEXT;\n  op.emitSeparator = emitSeparator;\n  return op;\n};\n\n/** @internal */\nconst PullAfterAllEnqueued = emitSeparator => {\n  const op = Object.create(proto);\n  op._tag = OP_PULL_AFTER_ALL_ENQUEUED;\n  op.emitSeparator = emitSeparator;\n  return op;\n};\n\n/** @internal */\nconst isUpstreamPullStrategy = u => typeof u === \"object\" && u != null && UpstreamPullStrategyTypeId in u;\n\n/** @internal */\nconst isPullAfterNext = self => self._tag === OP_PULL_AFTER_NEXT;\n\n/** @internal */\nconst isPullAfterAllEnqueued = self => self._tag === OP_PULL_AFTER_ALL_ENQUEUED;\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onAllEnqueued,\n  onNext\n}) => {\n  switch (self._tag) {\n    case OP_PULL_AFTER_NEXT:\n      {\n        return onNext(self.emitSeparator);\n      }\n    case OP_PULL_AFTER_ALL_ENQUEUED:\n      {\n        return onAllEnqueued(self.emitSeparator);\n      }\n  }\n});\n\nexport { PullAfterAllEnqueued, PullAfterNext, UpstreamPullStrategyTypeId, isPullAfterAllEnqueued, isPullAfterNext, isUpstreamPullStrategy, match };\n","/** @internal */\nconst OP_BRACKET_OUT = \"BracketOut\";\n\n/** @internal */\n\n/** @internal */\nconst OP_BRIDGE = \"Bridge\";\n\n/** @internal */\n\n/** @internal */\nconst OP_CONCAT_ALL = \"ConcatAll\";\n\n/** @internal */\n\n/** @internal */\nconst OP_EMIT = \"Emit\";\n\n/** @internal */\n\n/** @internal */\nconst OP_ENSURING = \"Ensuring\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FAIL = \"Fail\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FOLD = \"Fold\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FROM_EFFECT = \"FromEffect\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PIPE_TO = \"PipeTo\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PROVIDE = \"Provide\";\n\n/** @internal */\n\n/** @internal */\nconst OP_READ = \"Read\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SUCCEED = \"Succeed\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SUCCEED_NOW = \"SucceedNow\";\n\n/** @internal */\n\n/** @internal */\nconst OP_SUSPEND = \"Suspend\";\n\n/** @internal */\n\nexport { OP_BRACKET_OUT, OP_BRIDGE, OP_CONCAT_ALL, OP_EMIT, OP_ENSURING, OP_FAIL, OP_FOLD, OP_FROM_EFFECT, OP_PIPE_TO, OP_PROVIDE, OP_READ, OP_SUCCEED, OP_SUCCEED_NOW, OP_SUSPEND };\n","import { fail as fail$1, failureOrCause } from '../Cause/dist/effect-Cause.esm.js';\nimport { fromIterable } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { isEffect } from '../Effect/dist/effect-Effect.esm.js';\nimport { match } from '../Either/dist/effect-Either.esm.js';\nimport { dual, identity, constVoid } from '../Function/dist/effect-Function.esm.js';\nimport { none } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { Continue } from './channel/childExecutorDecision.esm.js';\nimport { ContinuationKImpl } from './channel/continuation.esm.js';\nimport { PullAfterNext } from './channel/upstreamPullStrategy.esm.js';\nimport { OP_BRACKET_OUT, OP_FOLD, OP_CONCAT_ALL, OP_BRIDGE, OP_ENSURING, OP_FAIL, OP_FROM_EFFECT, OP_PIPE_TO, OP_PROVIDE, OP_READ, OP_SUCCEED, OP_EMIT, OP_SUCCEED_NOW, OP_SUSPEND } from './opCodes/channel.esm.js';\n\n/** @internal */\nconst ChannelSymbolKey = \"effect/Channel\";\n\n/** @internal */\nconst ChannelTypeId = /*#__PURE__*/Symbol.for(ChannelSymbolKey);\n\n/** @internal */\nconst channelVariance = {\n  _Env: _ => _,\n  _InErr: _ => _,\n  _InElem: _ => _,\n  _InDone: _ => _,\n  _OutErr: _ => _,\n  _OutElem: _ => _,\n  _OutDone: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [ChannelTypeId]: channelVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst isChannel = u => typeof u === \"object\" && u != null && ChannelTypeId in u || isEffect(u);\n\n/** @internal */\nconst acquireReleaseOut = /*#__PURE__*/dual(2, (self, release) => {\n  const op = Object.create(proto);\n  op._tag = OP_BRACKET_OUT;\n  op.acquire = () => self;\n  op.finalizer = release;\n  return op;\n});\n\n/** @internal */\nconst catchAllCause = /*#__PURE__*/dual(2, (self, f) => {\n  const op = Object.create(proto);\n  op._tag = OP_FOLD;\n  op.channel = self;\n  op.k = new ContinuationKImpl(succeed, f);\n  return op;\n});\n\n/** @internal */\nconst collectElements = self => {\n  return suspend(() => {\n    const builder = [];\n    return flatMap(pipeTo(self, collectElementsReader(builder)), value => sync(() => [fromIterable(builder), value]));\n  });\n};\n\n/** @internal */\nconst collectElementsReader = builder => readWith({\n  onInput: outElem => flatMap(sync(() => {\n    builder.push(outElem);\n  }), () => collectElementsReader(builder)),\n  onFailure: fail,\n  onDone: succeedNow\n});\n\n/** @internal */\nconst concatAll = channels => concatAllWith(channels, constVoid, constVoid);\n\n/** @internal */\nconst concatAllWith = (channels, f, g) => {\n  const op = Object.create(proto);\n  op._tag = OP_CONCAT_ALL;\n  op.combineInners = f;\n  op.combineAll = g;\n  op.onPull = () => PullAfterNext(none());\n  op.onEmit = () => Continue;\n  op.value = () => channels;\n  op.k = identity;\n  return op;\n};\n\n/** @internal */\nconst concatMapWith = /*#__PURE__*/dual(4, (self, f, g, h) => {\n  const op = Object.create(proto);\n  op._tag = OP_CONCAT_ALL;\n  op.combineInners = g;\n  op.combineAll = h;\n  op.onPull = () => PullAfterNext(none());\n  op.onEmit = () => Continue;\n  op.value = () => self;\n  op.k = f;\n  return op;\n});\n\n/** @internal */\nconst concatMapWithCustom = /*#__PURE__*/dual(6, (self, f, g, h, onPull, onEmit) => {\n  const op = Object.create(proto);\n  op._tag = OP_CONCAT_ALL;\n  op.combineInners = g;\n  op.combineAll = h;\n  op.onPull = onPull;\n  op.onEmit = onEmit;\n  op.value = () => self;\n  op.k = f;\n  return op;\n});\n\n/** @internal */\nconst embedInput = /*#__PURE__*/dual(2, (self, input) => {\n  const op = Object.create(proto);\n  op._tag = OP_BRIDGE;\n  op.input = input;\n  op.channel = self;\n  return op;\n});\n\n/** @internal */\nconst ensuringWith = /*#__PURE__*/dual(2, (self, finalizer) => {\n  const op = Object.create(proto);\n  op._tag = OP_ENSURING;\n  op.channel = self;\n  op.finalizer = finalizer;\n  return op;\n});\n\n/** @internal */\nconst fail = error => failCause(fail$1(error));\n\n/** @internal */\nconst failSync = evaluate => failCauseSync(() => fail$1(evaluate()));\n\n/** @internal */\nconst failCause = cause => failCauseSync(() => cause);\n\n/** @internal */\nconst failCauseSync = evaluate => {\n  const op = Object.create(proto);\n  op._tag = OP_FAIL;\n  op.error = evaluate;\n  return op;\n};\n\n/** @internal */\nconst flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  const op = Object.create(proto);\n  op._tag = OP_FOLD;\n  op.channel = self;\n  op.k = new ContinuationKImpl(f, failCause);\n  return op;\n});\n\n/** @internal */\nconst foldCauseChannel = /*#__PURE__*/dual(2, (self, options) => {\n  const op = Object.create(proto);\n  op._tag = OP_FOLD;\n  op.channel = self;\n  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);\n  return op;\n});\n\n/** @internal */\nconst fromEffect = effect => {\n  const op = Object.create(proto);\n  op._tag = OP_FROM_EFFECT;\n  op.effect = () => effect;\n  return op;\n};\n\n/** @internal */\nconst pipeTo = /*#__PURE__*/dual(2, (self, that) => {\n  const op = Object.create(proto);\n  op._tag = OP_PIPE_TO;\n  op.left = () => self;\n  op.right = () => that;\n  return op;\n});\n\n/** @internal */\nconst provideContext = /*#__PURE__*/dual(2, (self, env) => {\n  const op = Object.create(proto);\n  op._tag = OP_PROVIDE;\n  op.context = () => env;\n  op.inner = self;\n  return op;\n});\n\n/** @internal */\nconst readOrFail = error => {\n  const op = Object.create(proto);\n  op._tag = OP_READ;\n  op.more = succeed;\n  op.done = new ContinuationKImpl(() => fail(error), () => fail(error));\n  return op;\n};\n\n/** @internal */\nconst readWith = options => readWithCause({\n  onInput: options.onInput,\n  onFailure: cause => match(failureOrCause(cause), {\n    onLeft: options.onFailure,\n    onRight: failCause\n  }),\n  onDone: options.onDone\n});\n\n/** @internal */\nconst readWithCause = options => {\n  const op = Object.create(proto);\n  op._tag = OP_READ;\n  op.more = options.onInput;\n  op.done = new ContinuationKImpl(options.onDone, options.onFailure);\n  return op;\n};\n\n/** @internal */\nconst succeed = value => sync(() => value);\n\n/** @internal */\nconst succeedNow = result => {\n  const op = Object.create(proto);\n  op._tag = OP_SUCCEED_NOW;\n  op.terminal = result;\n  return op;\n};\n\n/** @internal */\nconst suspend = evaluate => {\n  const op = Object.create(proto);\n  op._tag = OP_SUSPEND;\n  op.channel = evaluate;\n  return op;\n};\nconst sync = evaluate => {\n  const op = Object.create(proto);\n  op._tag = OP_SUCCEED;\n  op.evaluate = evaluate;\n  return op;\n};\n\n/** @internal */\nconst unit = /*#__PURE__*/succeedNow(void 0);\n\n/** @internal */\nconst write = out => {\n  const op = Object.create(proto);\n  op._tag = OP_EMIT;\n  op.out = out;\n  return op;\n};\n\nexport { ChannelTypeId, acquireReleaseOut, catchAllCause, collectElements, concatAll, concatAllWith, concatMapWith, concatMapWithCustom, embedInput, ensuringWith, fail, failCause, failCauseSync, failSync, flatMap, foldCauseChannel, fromEffect, isChannel, pipeTo, provideContext, readOrFail, readWith, readWithCause, succeed, succeedNow, suspend, sync, unit, write };\n","/** @internal */\nconst OP_DONE = \"Done\";\n\n/** @internal */\n\n/** @internal */\nconst OP_EMIT = \"Emit\";\n\n/** @internal */\n\n/** @internal */\nconst OP_FROM_EFFECT = \"FromEffect\";\n\n/** @internal */\n\n/** @internal */\nconst OP_READ = \"Read\";\n\n/** @internal */\n\nexport { OP_DONE, OP_EMIT, OP_FROM_EFFECT, OP_READ };\n","import { unit, ignore } from '../../Effect/dist/effect-Effect.esm.js';\nimport { OP_DONE, OP_EMIT, OP_FROM_EFFECT, OP_READ } from '../opCodes/channelState.esm.js';\n\n/** @internal */\nconst ChannelStateTypeId = /*#__PURE__*/Symbol.for(\"effect/ChannelState\");\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst channelStateVariance = {\n  _R: _ => _,\n  _E: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [ChannelStateTypeId]: channelStateVariance\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst Done = () => {\n  const op = Object.create(proto);\n  op._tag = OP_DONE;\n  return op;\n};\n\n/** @internal */\nconst Emit = () => {\n  const op = Object.create(proto);\n  op._tag = OP_EMIT;\n  return op;\n};\n\n/** @internal */\nconst FromEffect = effect => {\n  const op = Object.create(proto);\n  op._tag = OP_FROM_EFFECT;\n  op.effect = effect;\n  return op;\n};\n\n/** @internal */\nconst Read = (upstream, onEffect, onEmit, onDone) => {\n  const op = Object.create(proto);\n  op._tag = OP_READ;\n  op.upstream = upstream;\n  op.onEffect = onEffect;\n  op.onEmit = onEmit;\n  op.onDone = onDone;\n  return op;\n};\n\n/** @internal */\nconst isFromEffect = self => self._tag === OP_FROM_EFFECT;\n\n/** @internal */\nconst effect = self => isFromEffect(self) ? self.effect : unit;\n\n/** @internal */\nconst effectOrUndefinedIgnored = self => isFromEffect(self) ? ignore(self.effect) : undefined;\n\nexport { ChannelStateTypeId, Done, Emit, FromEffect, Read, effect, effectOrUndefinedIgnored, isFromEffect };\n","import { zipWith, exit } from '../../Effect/dist/effect-Effect.esm.js';\nimport { zipRight } from '../../Exit/dist/effect-Exit.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst OP_PULL_FROM_CHILD = \"PullFromChild\";\n\n/** @internal */\n\n/** @internal */\nconst OP_PULL_FROM_UPSTREAM = \"PullFromUpstream\";\n\n/** @internal */\n\n/** @internal */\nconst OP_DRAIN_CHILD_EXECUTORS = \"DrainChildExecutors\";\n\n/** @internal */\n\n/** @internal */\nconst OP_EMIT = \"Emit\";\n\n/** @internal */\n\n/**\n * Execute the `childExecutor` and on each emitted value, decide what to do by\n * `onEmit`.\n *\n * @internal\n */\nclass PullFromChild {\n  _tag = OP_PULL_FROM_CHILD;\n  constructor(childExecutor, parentSubexecutor, onEmit) {\n    this.childExecutor = childExecutor;\n    this.parentSubexecutor = parentSubexecutor;\n    this.onEmit = onEmit;\n  }\n  close(exit$1) {\n    const fin1 = this.childExecutor.close(exit$1);\n    const fin2 = this.parentSubexecutor.close(exit$1);\n    if (fin1 !== undefined && fin2 !== undefined) {\n      return zipWith(exit(fin1), exit(fin2), (exit1, exit2) => pipe(exit1, zipRight(exit2)));\n    } else if (fin1 !== undefined) {\n      return fin1;\n    } else if (fin2 !== undefined) {\n      return fin2;\n    } else {\n      return undefined;\n    }\n  }\n  enqueuePullFromChild(_child) {\n    return this;\n  }\n}\n\n/**\n * Execute `upstreamExecutor` and for each emitted element, spawn a child\n * channel and continue with processing it by `PullFromChild`.\n *\n * @internal\n */\nclass PullFromUpstream {\n  _tag = OP_PULL_FROM_UPSTREAM;\n  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {\n    this.upstreamExecutor = upstreamExecutor;\n    this.createChild = createChild;\n    this.lastDone = lastDone;\n    this.activeChildExecutors = activeChildExecutors;\n    this.combineChildResults = combineChildResults;\n    this.combineWithChildResult = combineWithChildResult;\n    this.onPull = onPull;\n    this.onEmit = onEmit;\n  }\n  close(exit$1) {\n    const fin1 = this.upstreamExecutor.close(exit$1);\n    const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit$1) : undefined), fin1];\n    const result = fins.reduce((acc, next) => {\n      if (acc !== undefined && next !== undefined) {\n        return zipWith(acc, exit(next), (exit1, exit2) => zipRight(exit1, exit2));\n      } else if (acc !== undefined) {\n        return acc;\n      } else if (next !== undefined) {\n        return exit(next);\n      } else {\n        return undefined;\n      }\n    }, undefined);\n    return result === undefined ? result : result;\n  }\n  enqueuePullFromChild(child) {\n    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);\n  }\n}\n\n/**\n * Transformed from `PullFromUpstream` when upstream has finished but there\n * are still active child executors.\n *\n * @internal\n */\nclass DrainChildExecutors {\n  _tag = OP_DRAIN_CHILD_EXECUTORS;\n  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {\n    this.upstreamExecutor = upstreamExecutor;\n    this.lastDone = lastDone;\n    this.activeChildExecutors = activeChildExecutors;\n    this.upstreamDone = upstreamDone;\n    this.combineChildResults = combineChildResults;\n    this.combineWithChildResult = combineWithChildResult;\n    this.onPull = onPull;\n  }\n  close(exit$1) {\n    const fin1 = this.upstreamExecutor.close(exit$1);\n    const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit$1) : undefined), fin1];\n    const result = fins.reduce((acc, next) => {\n      if (acc !== undefined && next !== undefined) {\n        return zipWith(acc, exit(next), (exit1, exit2) => zipRight(exit1, exit2));\n      } else if (acc !== undefined) {\n        return acc;\n      } else if (next !== undefined) {\n        return exit(next);\n      } else {\n        return undefined;\n      }\n    }, undefined);\n    return result === undefined ? result : result;\n  }\n  enqueuePullFromChild(child) {\n    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);\n  }\n}\n\n/** @internal */\nclass Emit {\n  _tag = OP_EMIT;\n  constructor(value, next) {\n    this.value = value;\n    this.next = next;\n  }\n  close(exit) {\n    const result = this.next.close(exit);\n    return result === undefined ? result : result;\n  }\n  enqueuePullFromChild(_child) {\n    return this;\n  }\n}\n\nexport { DrainChildExecutors, Emit, OP_DRAIN_CHILD_EXECUTORS, OP_EMIT, OP_PULL_FROM_CHILD, OP_PULL_FROM_UPSTREAM, PullFromChild, PullFromUpstream };\n","/** @internal */\nconst OP_PULLED = \"Pulled\";\n\n/** @internal */\n\n/** @internal */\nconst OP_NO_UPSTREAM = \"NoUpstream\";\n\n/** @internal */\n\nexport { OP_NO_UPSTREAM, OP_PULLED };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { OP_PULLED, OP_NO_UPSTREAM } from '../opCodes/channelUpstreamPullRequest.esm.js';\n\n/** @internal */\nconst UpstreamPullRequestSymbolKey = \"effect/ChannelUpstreamPullRequest\";\n\n/** @internal */\nconst UpstreamPullRequestTypeId = /*#__PURE__*/Symbol.for(UpstreamPullRequestSymbolKey);\n\n/** @internal */\nconst upstreamPullRequestVariance = {\n  _A: _ => _\n};\n\n/** @internal */\nconst proto = {\n  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance\n};\n\n/** @internal */\nconst Pulled = value => {\n  const op = Object.create(proto);\n  op._tag = OP_PULLED;\n  op.value = value;\n  return op;\n};\n\n/** @internal */\nconst NoUpstream = activeDownstreamCount => {\n  const op = Object.create(proto);\n  op._tag = OP_NO_UPSTREAM;\n  op.activeDownstreamCount = activeDownstreamCount;\n  return op;\n};\n\n/** @internal */\nconst isUpstreamPullRequest = u => typeof u === \"object\" && u != null && UpstreamPullRequestTypeId in u;\n\n/** @internal */\nconst isPulled = self => self._tag === OP_PULLED;\n\n/** @internal */\nconst isNoUpstream = self => self._tag === OP_NO_UPSTREAM;\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onNoUpstream,\n  onPulled\n}) => {\n  switch (self._tag) {\n    case OP_PULLED:\n      {\n        return onPulled(self.value);\n      }\n    case OP_NO_UPSTREAM:\n      {\n        return onNoUpstream(self.activeDownstreamCount);\n      }\n  }\n});\n\nexport { NoUpstream, Pulled, UpstreamPullRequestTypeId, isNoUpstream, isPulled, isUpstreamPullRequest, match };\n","import { die as die$1 } from '../../Cause/dist/effect-Cause.esm.js';\nimport { succeed as succeed$2, await as _await, make } from '../../Deferred/dist/effect-Deferred.esm.js';\nimport { isEffect, sync, unit, provide, matchCauseEffect, zipRight, flatMap, suspend, forkDaemon, ensuring, uninterruptible, map, zip, exit, forEach, succeed as succeed$1, scoped, uninterruptibleMask, scope, forkScoped, addFinalizer, zipLeft, all as all$1, dieMessage, catchAllCause, acquireUseRelease, intoDeferred, tapErrorCause, failCause as failCause$2 } from '../../Effect/dist/effect-Effect.esm.js';\nimport { sequential } from '../../ExecutionStrategy/dist/effect-ExecutionStrategy.esm.js';\nimport { die, match, zipRight as zipRight$1, succeed, failCause as failCause$1, all, unit as unit$2, map as map$1 } from '../../Exit/dist/effect-Exit.esm.js';\nimport { interrupt, inheritAll } from '../../Fiber/dist/effect-Fiber.esm.js';\nimport { identity, pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { isSome, getOrElse } from '../../Option/dist/effect-Option.esm.js';\nimport { fork, addFinalizer as addFinalizer$1 } from '../../Scope/dist/effect-Scope.esm.js';\nimport { fromEffect, unit as unit$1, failCause, write } from '../core-stream.esm.js';\nimport { OP_SUSPEND, OP_SUCCEED_NOW, OP_SUCCEED, OP_READ, OP_PROVIDE, OP_PIPE_TO, OP_FROM_EFFECT, OP_FOLD, OP_FAIL, OP_ENSURING, OP_EMIT, OP_CONCAT_ALL, OP_BRIDGE, OP_BRACKET_OUT } from '../opCodes/channel.esm.js';\nimport { OP_YIELD, OP_CLOSE, OP_CONTINUE } from '../opCodes/channelChildExecutorDecision.esm.js';\nimport { OP_READ as OP_READ$1, OP_FROM_EFFECT as OP_FROM_EFFECT$1, OP_EMIT as OP_EMIT$1, OP_DONE } from '../opCodes/channelState.esm.js';\nimport { OP_PULL_AFTER_ALL_ENQUEUED, OP_PULL_AFTER_NEXT } from '../opCodes/channelUpstreamPullStrategy.esm.js';\nimport { OP_CONTINUATION_K } from '../opCodes/continuation.esm.js';\nimport { Done, Read, FromEffect, isFromEffect, Emit, effect, effectOrUndefinedIgnored } from './channelState.esm.js';\nimport { ContinuationFinalizerImpl } from './continuation.esm.js';\nimport { PullFromUpstream, OP_EMIT as OP_EMIT$2, OP_DRAIN_CHILD_EXECUTORS, OP_PULL_FROM_UPSTREAM, OP_PULL_FROM_CHILD, Emit as Emit$1, DrainChildExecutors, PullFromChild } from './subexecutor.esm.js';\nimport { NoUpstream, Pulled } from './upstreamPullRequest.esm.js';\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\nclass ChannelExecutor {\n  _activeSubexecutor = undefined;\n  _cancelled = undefined;\n  _closeLastSubstream = undefined;\n  _done = undefined;\n  _doneStack = [];\n  _emitted = undefined;\n  _input = undefined;\n  _inProgressFinalizer = undefined;\n  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {\n    this._currentChannel = initialChannel;\n    this._executeCloseLastSubstream = executeCloseLastSubstream;\n    this._providedEnv = providedEnv;\n  }\n  run() {\n    let result = undefined;\n    while (result === undefined) {\n      if (this._cancelled !== undefined) {\n        result = this.processCancellation();\n      } else if (this._activeSubexecutor !== undefined) {\n        result = this.runSubexecutor();\n      } else {\n        try {\n          if (this._currentChannel === undefined) {\n            result = Done();\n          } else {\n            if (isEffect(this._currentChannel)) {\n              this._currentChannel = fromEffect(this._currentChannel);\n            } else {\n              switch (this._currentChannel._tag) {\n                case OP_BRACKET_OUT:\n                  {\n                    result = this.runBracketOut(this._currentChannel);\n                    break;\n                  }\n                case OP_BRIDGE:\n                  {\n                    const bridgeInput = this._currentChannel.input;\n\n                    // PipeTo(left, Bridge(queue, channel))\n                    // In a fiber: repeatedly run left and push its outputs to the queue\n                    // Add a finalizer to interrupt the fiber and close the executor\n                    this._currentChannel = this._currentChannel.channel;\n                    if (this._input !== undefined) {\n                      const inputExecutor = this._input;\n                      this._input = undefined;\n                      const drainer = () => flatMap(bridgeInput.awaitRead(), () => suspend(() => {\n                        const state = inputExecutor.run();\n                        switch (state._tag) {\n                          case OP_DONE:\n                            {\n                              return match(inputExecutor.getDone(), {\n                                onFailure: cause => bridgeInput.error(cause),\n                                onSuccess: value => bridgeInput.done(value)\n                              });\n                            }\n                          case OP_EMIT$1:\n                            {\n                              return flatMap(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());\n                            }\n                          case OP_FROM_EFFECT$1:\n                            {\n                              return matchCauseEffect(state.effect, {\n                                onFailure: cause => bridgeInput.error(cause),\n                                onSuccess: () => drainer()\n                              });\n                            }\n                          case OP_READ$1:\n                            {\n                              return readUpstream(state, () => drainer(), cause => bridgeInput.error(cause));\n                            }\n                        }\n                      }));\n                      result = FromEffect(flatMap(forkDaemon(drainer()), fiber => sync(() => this.addFinalizer(exit => flatMap(interrupt(fiber), () => suspend(() => {\n                        const effect = this.restorePipe(exit, inputExecutor);\n                        return effect !== undefined ? effect : unit;\n                      }))))));\n                    }\n                    break;\n                  }\n                case OP_CONCAT_ALL:\n                  {\n                    const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, effect => sync(() => {\n                      const prevLastClose = this._closeLastSubstream === undefined ? unit : this._closeLastSubstream;\n                      this._closeLastSubstream = pipe(prevLastClose, zipRight(effect));\n                    }));\n                    executor._input = this._input;\n                    const channel = this._currentChannel;\n                    this._activeSubexecutor = new PullFromUpstream(executor, value => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), request => channel.onPull(request), value => channel.onEmit(value));\n                    this._closeLastSubstream = undefined;\n                    this._currentChannel = undefined;\n                    break;\n                  }\n                case OP_EMIT:\n                  {\n                    this._emitted = this._currentChannel.out;\n                    this._currentChannel = this._activeSubexecutor !== undefined ? undefined : unit$1;\n                    result = Emit();\n                    break;\n                  }\n                case OP_ENSURING:\n                  {\n                    this.runEnsuring(this._currentChannel);\n                    break;\n                  }\n                case OP_FAIL:\n                  {\n                    result = this.doneHalt(this._currentChannel.error());\n                    break;\n                  }\n                case OP_FOLD:\n                  {\n                    this._doneStack.push(this._currentChannel.k);\n                    this._currentChannel = this._currentChannel.channel;\n                    break;\n                  }\n                case OP_FROM_EFFECT:\n                  {\n                    const effect = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide(this._providedEnv));\n                    result = FromEffect(matchCauseEffect(effect, {\n                      onFailure: cause => {\n                        const state = this.doneHalt(cause);\n                        return state !== undefined && isFromEffect(state) ? state.effect : unit;\n                      },\n                      onSuccess: value => {\n                        const state = this.doneSucceed(value);\n                        return state !== undefined && isFromEffect(state) ? state.effect : unit;\n                      }\n                    }));\n                    break;\n                  }\n                case OP_PIPE_TO:\n                  {\n                    const previousInput = this._input;\n                    const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, effect => this._executeCloseLastSubstream(effect));\n                    leftExec._input = previousInput;\n                    this._input = leftExec;\n                    this.addFinalizer(exit => {\n                      const effect = this.restorePipe(exit, previousInput);\n                      return effect !== undefined ? effect : unit;\n                    });\n                    this._currentChannel = this._currentChannel.right();\n                    break;\n                  }\n                case OP_PROVIDE:\n                  {\n                    const previousEnv = this._providedEnv;\n                    this._providedEnv = this._currentChannel.context();\n                    this._currentChannel = this._currentChannel.inner;\n                    this.addFinalizer(() => sync(() => {\n                      this._providedEnv = previousEnv;\n                    }));\n                    break;\n                  }\n                case OP_READ:\n                  {\n                    const read = this._currentChannel;\n                    result = Read(this._input, identity, emitted => {\n                      try {\n                        this._currentChannel = read.more(emitted);\n                      } catch (error) {\n                        this._currentChannel = read.done.onExit(die(error));\n                      }\n                      return undefined;\n                    }, exit => {\n                      const onExit = exit => {\n                        return read.done.onExit(exit);\n                      };\n                      this._currentChannel = onExit(exit);\n                      return undefined;\n                    });\n                    break;\n                  }\n                case OP_SUCCEED:\n                  {\n                    result = this.doneSucceed(this._currentChannel.evaluate());\n                    break;\n                  }\n                case OP_SUCCEED_NOW:\n                  {\n                    result = this.doneSucceed(this._currentChannel.terminal);\n                    break;\n                  }\n                case OP_SUSPEND:\n                  {\n                    this._currentChannel = this._currentChannel.channel();\n                    break;\n                  }\n                default:\n                  {\n                    // @ts-expect-error\n                    this._currentChannel._tag;\n                  }\n              }\n            }\n          }\n        } catch (error) {\n          this._currentChannel = failCause(die$1(error));\n        }\n      }\n    }\n    return result;\n  }\n  getDone() {\n    return this._done;\n  }\n  getEmit() {\n    return this._emitted;\n  }\n  cancelWith(exit) {\n    this._cancelled = exit;\n  }\n  clearInProgressFinalizer() {\n    this._inProgressFinalizer = undefined;\n  }\n  storeInProgressFinalizer(finalizer) {\n    this._inProgressFinalizer = finalizer;\n  }\n  popAllFinalizers(exit) {\n    const finalizers = [];\n    let next = this._doneStack.pop();\n    while (next) {\n      if (next._tag === \"ContinuationFinalizer\") {\n        finalizers.push(next.finalizer);\n      }\n      next = this._doneStack.pop();\n    }\n    const effect = finalizers.length === 0 ? unit : runFinalizers(finalizers, exit);\n    this.storeInProgressFinalizer(effect);\n    return effect;\n  }\n  popNextFinalizers() {\n    const builder = [];\n    while (this._doneStack.length !== 0) {\n      const cont = this._doneStack[this._doneStack.length - 1];\n      if (cont._tag === OP_CONTINUATION_K) {\n        return builder;\n      }\n      builder.push(cont);\n      this._doneStack.pop();\n    }\n    return builder;\n  }\n  restorePipe(exit, prev) {\n    const currInput = this._input;\n    this._input = prev;\n    if (currInput !== undefined) {\n      const effect = currInput.close(exit);\n      return effect;\n    }\n    return unit;\n  }\n  close(exit$1) {\n    let runInProgressFinalizers = undefined;\n    const finalizer = this._inProgressFinalizer;\n    if (finalizer !== undefined) {\n      runInProgressFinalizers = pipe(finalizer, ensuring(sync(() => this.clearInProgressFinalizer())));\n    }\n    let closeSelf = undefined;\n    const selfFinalizers = this.popAllFinalizers(exit$1);\n    if (selfFinalizers !== undefined) {\n      closeSelf = pipe(selfFinalizers, ensuring(sync(() => this.clearInProgressFinalizer())));\n    }\n    const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit$1);\n    if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {\n      return undefined;\n    }\n    return pipe(exit(ifNotNull(closeSubexecutors)), zip(exit(ifNotNull(runInProgressFinalizers))), zip(exit(ifNotNull(closeSelf))), map(([[exit1, exit2], exit3]) => pipe(exit1, zipRight$1(exit2), zipRight$1(exit3))), uninterruptible,\n    // TODO: remove\n    flatMap(exit => suspend(() => exit)));\n  }\n  doneSucceed(value) {\n    if (this._doneStack.length === 0) {\n      this._done = succeed(value);\n      this._currentChannel = undefined;\n      return Done();\n    }\n    const head = this._doneStack[this._doneStack.length - 1];\n    if (head._tag === OP_CONTINUATION_K) {\n      this._doneStack.pop();\n      this._currentChannel = head.onSuccess(value);\n      return undefined;\n    }\n    const finalizers = this.popNextFinalizers();\n    if (this._doneStack.length === 0) {\n      this._doneStack = finalizers.reverse();\n      this._done = succeed(value);\n      this._currentChannel = undefined;\n      return Done();\n    }\n    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), succeed(value));\n    this.storeInProgressFinalizer(finalizerEffect);\n    const effect = pipe(finalizerEffect, ensuring(sync(() => this.clearInProgressFinalizer())), uninterruptible, flatMap(() => sync(() => this.doneSucceed(value))));\n    return FromEffect(effect);\n  }\n  doneHalt(cause) {\n    if (this._doneStack.length === 0) {\n      this._done = failCause$1(cause);\n      this._currentChannel = undefined;\n      return Done();\n    }\n    const head = this._doneStack[this._doneStack.length - 1];\n    if (head._tag === OP_CONTINUATION_K) {\n      this._doneStack.pop();\n      this._currentChannel = head.onHalt(cause);\n      return undefined;\n    }\n    const finalizers = this.popNextFinalizers();\n    if (this._doneStack.length === 0) {\n      this._doneStack = finalizers.reverse();\n      this._done = failCause$1(cause);\n      this._currentChannel = undefined;\n      return Done();\n    }\n    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), failCause$1(cause));\n    this.storeInProgressFinalizer(finalizerEffect);\n    const effect = pipe(finalizerEffect, ensuring(sync(() => this.clearInProgressFinalizer())), uninterruptible, flatMap(() => sync(() => this.doneHalt(cause))));\n    return FromEffect(effect);\n  }\n  processCancellation() {\n    this._currentChannel = undefined;\n    this._done = this._cancelled;\n    this._cancelled = undefined;\n    return Done();\n  }\n  runBracketOut(bracketOut) {\n    const effect = uninterruptible(matchCauseEffect(this.provide(bracketOut.acquire()), {\n      onFailure: cause => sync(() => {\n        this._currentChannel = failCause(cause);\n      }),\n      onSuccess: out => sync(() => {\n        this.addFinalizer(exit => this.provide(bracketOut.finalizer(out, exit)));\n        this._currentChannel = write(out);\n      })\n    }));\n    return FromEffect(effect);\n  }\n  provide(effect) {\n    if (this._providedEnv === undefined) {\n      return effect;\n    }\n    return pipe(effect, provide(this._providedEnv));\n  }\n  runEnsuring(ensuring) {\n    this.addFinalizer(ensuring.finalizer);\n    this._currentChannel = ensuring.channel;\n  }\n  addFinalizer(f) {\n    this._doneStack.push(new ContinuationFinalizerImpl(f));\n  }\n  runSubexecutor() {\n    const subexecutor = this._activeSubexecutor;\n    switch (subexecutor._tag) {\n      case OP_PULL_FROM_CHILD:\n        {\n          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);\n        }\n      case OP_PULL_FROM_UPSTREAM:\n        {\n          return this.pullFromUpstream(subexecutor);\n        }\n      case OP_DRAIN_CHILD_EXECUTORS:\n        {\n          return this.drainChildExecutors(subexecutor);\n        }\n      case OP_EMIT$2:\n        {\n          this._emitted = subexecutor.value;\n          this._activeSubexecutor = subexecutor.next;\n          return Emit();\n        }\n    }\n  }\n  replaceSubexecutor(nextSubExec) {\n    this._currentChannel = undefined;\n    this._activeSubexecutor = nextSubExec;\n  }\n  finishWithExit(exit) {\n    const state = match(exit, {\n      onFailure: cause => this.doneHalt(cause),\n      onSuccess: value => this.doneSucceed(value)\n    });\n    this._activeSubexecutor = undefined;\n    return state === undefined ? unit : effect(state);\n  }\n  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {\n    this.addFinalizer(() => pipe(closeFuncs, forEach(closeFunc => pipe(sync(() => closeFunc(subexecutorDone)), flatMap(closeEffect => closeEffect !== undefined ? closeEffect : unit)), {\n      discard: true\n    })));\n    const state = pipe(subexecutorDone, match({\n      onFailure: cause => this.doneHalt(cause),\n      onSuccess: value => this.doneSucceed(value)\n    }));\n    this._activeSubexecutor = undefined;\n    return state;\n  }\n  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {\n    switch (strategy._tag) {\n      case OP_PULL_AFTER_NEXT:\n        {\n          const shouldPrepend = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);\n          return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];\n        }\n      case OP_PULL_AFTER_ALL_ENQUEUED:\n        {\n          const shouldEnqueue = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);\n          return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];\n        }\n    }\n  }\n  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {\n    return Read(childExecutor, identity, emitted => {\n      const childExecutorDecision = onEmitted(emitted);\n      switch (childExecutorDecision._tag) {\n        case OP_CONTINUE:\n          {\n            break;\n          }\n        case OP_CLOSE:\n          {\n            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);\n            break;\n          }\n        case OP_YIELD:\n          {\n            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);\n            this.replaceSubexecutor(modifiedParent);\n            break;\n          }\n      }\n      this._activeSubexecutor = new Emit$1(emitted, this._activeSubexecutor);\n      return undefined;\n    }, match({\n      onFailure: cause => {\n        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause);\n        return state === undefined ? undefined : effectOrUndefinedIgnored(state);\n      },\n      onSuccess: doneValue => {\n        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);\n        return undefined;\n      }\n    }));\n  }\n  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {\n    const subexecutor = parentSubexecutor;\n    switch (subexecutor._tag) {\n      case OP_PULL_FROM_UPSTREAM:\n        {\n          const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);\n          this._closeLastSubstream = childExecutor.close(succeed(doneValue));\n          this.replaceSubexecutor(modifiedParent);\n          break;\n        }\n      case OP_DRAIN_CHILD_EXECUTORS:\n        {\n          const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);\n          this._closeLastSubstream = childExecutor.close(succeed(doneValue));\n          this.replaceSubexecutor(modifiedParent);\n          break;\n        }\n    }\n  }\n  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause) {\n    return this.finishSubexecutorWithCloseEffect(failCause$1(cause), exit => parentSubexecutor.close(exit), exit => childExecutor.close(exit));\n  }\n  pullFromUpstream(subexecutor) {\n    if (subexecutor.activeChildExecutors.length === 0) {\n      return this.performPullFromUpstream(subexecutor);\n    }\n    const activeChild = subexecutor.activeChildExecutors[0];\n    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);\n    if (activeChild === undefined) {\n      return this.performPullFromUpstream(parentSubexecutor);\n    }\n    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));\n    return undefined;\n  }\n  performPullFromUpstream(subexecutor) {\n    return Read(subexecutor.upstreamExecutor, effect => {\n      const closeLastSubstream = this._closeLastSubstream === undefined ? unit : this._closeLastSubstream;\n      this._closeLastSubstream = undefined;\n      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight(effect));\n    }, emitted => {\n      if (this._closeLastSubstream !== undefined) {\n        const closeLastSubstream = this._closeLastSubstream;\n        this._closeLastSubstream = undefined;\n        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map(() => {\n          const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);\n          childExecutor._input = this._input;\n          const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));\n          this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);\n          if (isSome(emitSeparator)) {\n            this._activeSubexecutor = new Emit$1(emitSeparator.value, this._activeSubexecutor);\n          }\n          return undefined;\n        }));\n      }\n      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);\n      childExecutor._input = this._input;\n      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));\n      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);\n      if (isSome(emitSeparator)) {\n        this._activeSubexecutor = new Emit$1(emitSeparator.value, this._activeSubexecutor);\n      }\n      return undefined;\n    }, exit => {\n      if (subexecutor.activeChildExecutors.some(subexecutor => subexecutor !== undefined)) {\n        const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);\n        if (this._closeLastSubstream !== undefined) {\n          const closeLastSubstream = this._closeLastSubstream;\n          this._closeLastSubstream = undefined;\n          return pipe(this._executeCloseLastSubstream(closeLastSubstream), map(() => this.replaceSubexecutor(drain)));\n        }\n        this.replaceSubexecutor(drain);\n        return undefined;\n      }\n      const closeLastSubstream = this._closeLastSubstream;\n      const state = this.finishSubexecutorWithCloseEffect(pipe(exit, map$1(a => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, exit => subexecutor.upstreamExecutor.close(exit));\n      return state === undefined ? undefined :\n      // NOTE: assuming finalizers cannot fail\n      effectOrUndefinedIgnored(state);\n    });\n  }\n  drainChildExecutors(subexecutor) {\n    if (subexecutor.activeChildExecutors.length === 0) {\n      const lastClose = this._closeLastSubstream;\n      if (lastClose !== undefined) {\n        this.addFinalizer(() => succeed$1(lastClose));\n      }\n      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, exit => subexecutor.upstreamExecutor.close(exit));\n    }\n    const activeChild = subexecutor.activeChildExecutors[0];\n    const rest = subexecutor.activeChildExecutors.slice(1);\n    if (activeChild === undefined) {\n      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));\n      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));\n      if (isSome(emitSeparator)) {\n        this._emitted = emitSeparator.value;\n        return Emit();\n      }\n      return undefined;\n    }\n    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);\n    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));\n    return undefined;\n  }\n}\nconst ifNotNull = effect => effect !== undefined ? effect : unit;\nconst runFinalizers = (finalizers, exit$1) => {\n  return pipe(forEach(finalizers, fin => exit(fin(exit$1))), map(exits => pipe(all(exits), getOrElse(() => unit$2))), flatMap(exit => suspend(() => exit)));\n};\n\n/**\n * @internal\n */\nconst readUpstream = (r, onSuccess, onFailure) => {\n  const readStack = [r];\n  const read = () => {\n    const current = readStack.pop();\n    if (current === undefined || current.upstream === undefined) {\n      return dieMessage(\"Unexpected end of input for channel execution\");\n    }\n    const state = current.upstream.run();\n    switch (state._tag) {\n      case OP_EMIT$1:\n        {\n          const emitEffect = current.onEmit(current.upstream.getEmit());\n          if (readStack.length === 0) {\n            if (emitEffect === undefined) {\n              return suspend(onSuccess);\n            }\n            return pipe(emitEffect, matchCauseEffect({\n              onFailure,\n              onSuccess\n            }));\n          }\n          if (emitEffect === undefined) {\n            return suspend(() => read());\n          }\n          return pipe(emitEffect, matchCauseEffect({\n            onFailure,\n            onSuccess: () => read()\n          }));\n        }\n      case OP_DONE:\n        {\n          const doneEffect = current.onDone(current.upstream.getDone());\n          if (readStack.length === 0) {\n            if (doneEffect === undefined) {\n              return suspend(onSuccess);\n            }\n            return pipe(doneEffect, matchCauseEffect({\n              onFailure,\n              onSuccess\n            }));\n          }\n          if (doneEffect === undefined) {\n            return suspend(() => read());\n          }\n          return pipe(doneEffect, matchCauseEffect({\n            onFailure,\n            onSuccess: () => read()\n          }));\n        }\n      case OP_FROM_EFFECT$1:\n        {\n          readStack.push(current);\n          return pipe(current.onEffect(state.effect), catchAllCause(cause => suspend(() => {\n            const doneEffect = current.onDone(failCause$1(cause));\n            return doneEffect === undefined ? unit : doneEffect;\n          })), matchCauseEffect({\n            onFailure,\n            onSuccess: () => read()\n          }));\n        }\n      case OP_READ$1:\n        {\n          readStack.push(current);\n          readStack.push(state);\n          return suspend(() => read());\n        }\n    }\n  };\n  return read();\n};\n\n/** @internal */\nconst run = self => pipe(runScoped(self), scoped);\n\n/** @internal */\nconst runScoped = self => {\n  const run = (channelDeferred, scopeDeferred, scope) => acquireUseRelease(sync(() => new ChannelExecutor(self, void 0, identity)), exec => suspend(() => pipe(runScopedInterpret(exec.run(), exec), intoDeferred(channelDeferred), zipRight(_await(channelDeferred)), zipLeft(_await(scopeDeferred)))), (exec, exit) => {\n    const finalize = exec.close(exit);\n    if (finalize === undefined) {\n      return unit;\n    }\n    return tapErrorCause(finalize, cause => addFinalizer$1(scope, failCause$2(cause)));\n  });\n  return uninterruptibleMask(restore => flatMap(scope, parent => pipe(all$1([fork(parent, sequential), make(), make()]), flatMap(([child, channelDeferred, scopeDeferred]) => pipe(forkScoped(restore(run(channelDeferred, scopeDeferred, child))), flatMap(fiber => pipe(addFinalizer(() => succeed$2(scopeDeferred, void 0)), zipRight(restore(_await(channelDeferred))), zipLeft(inheritAll(fiber)))))))));\n};\n\n/** @internal */\nconst runScopedInterpret = (channelState, exec) => {\n  const op = channelState;\n  switch (op._tag) {\n    case OP_FROM_EFFECT$1:\n      {\n        return pipe(op.effect, flatMap(() => runScopedInterpret(exec.run(), exec)));\n      }\n    case OP_EMIT$1:\n      {\n        // Can't really happen because Out <:< Nothing. So just skip ahead.\n        return runScopedInterpret(exec.run(), exec);\n      }\n    case OP_DONE:\n      {\n        return suspend(() => exec.getDone());\n      }\n    case OP_READ$1:\n      {\n        return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause$2);\n      }\n  }\n};\n\nexport { ChannelExecutor, readUpstream, run, runScoped };\n","/** @internal */\nconst OP_DONE = \"Done\";\n\n/** @internal */\n\n/** @internal */\nconst OP_AWAIT = \"Await\";\n\n/** @internal */\n\nexport { OP_AWAIT, OP_DONE };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { OP_DONE, OP_AWAIT } from '../opCodes/channelMergeDecision.esm.js';\n\n/** @internal */\nconst MergeDecisionSymbolKey = \"effect/ChannelMergeDecision\";\n\n/** @internal */\nconst MergeDecisionTypeId = /*#__PURE__*/Symbol.for(MergeDecisionSymbolKey);\n\n/** @internal */\nconst proto = {\n  [MergeDecisionTypeId]: {\n    _R: _ => _,\n    _E0: _ => _,\n    _Z0: _ => _,\n    _E: _ => _,\n    _Z: _ => _\n  }\n};\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst Done = effect => {\n  const op = Object.create(proto);\n  op._tag = OP_DONE;\n  op.effect = effect;\n  return op;\n};\n\n/** @internal */\nconst Await = f => {\n  const op = Object.create(proto);\n  op._tag = OP_AWAIT;\n  op.f = f;\n  return op;\n};\n\n/** @internal */\nconst AwaitConst = effect => Await(() => effect);\n\n/** @internal */\nconst isMergeDecision = u => typeof u === \"object\" && u != null && MergeDecisionTypeId in u;\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onAwait,\n  onDone\n}) => {\n  const op = self;\n  switch (op._tag) {\n    case OP_DONE:\n      {\n        return onDone(op.effect);\n      }\n    case OP_AWAIT:\n      {\n        return onAwait(op.f);\n      }\n  }\n});\n\nexport { Await, AwaitConst, Done, MergeDecisionTypeId, isMergeDecision, match };\n","/** @internal */\nconst OP_BOTH_RUNNING = \"BothRunning\";\n\n/** @internal */\n\n/** @internal */\nconst OP_LEFT_DONE = \"LeftDone\";\n\n/** @internal */\n\n/** @internal */\nconst OP_RIGHT_DONE = \"RightDone\";\n\n/** @internal */\n\nexport { OP_BOTH_RUNNING, OP_LEFT_DONE, OP_RIGHT_DONE };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { OP_BOTH_RUNNING, OP_LEFT_DONE, OP_RIGHT_DONE } from '../opCodes/channelMergeState.esm.js';\n\n/** @internal */\nconst MergeStateSymbolKey = \"effect/ChannelMergeState\";\n\n/** @internal */\nconst MergeStateTypeId = /*#__PURE__*/Symbol.for(MergeStateSymbolKey);\n\n/** @internal */\nconst proto = {\n  [MergeStateTypeId]: MergeStateTypeId\n};\n\n/** @internal */\nconst BothRunning = (left, right) => {\n  const op = Object.create(proto);\n  op._tag = OP_BOTH_RUNNING;\n  op.left = left;\n  op.right = right;\n  return op;\n};\n\n/** @internal */\nconst LeftDone = f => {\n  const op = Object.create(proto);\n  op._tag = OP_LEFT_DONE;\n  op.f = f;\n  return op;\n};\n\n/** @internal */\nconst RightDone = f => {\n  const op = Object.create(proto);\n  op._tag = OP_RIGHT_DONE;\n  op.f = f;\n  return op;\n};\n\n/** @internal */\nconst isMergeState = u => {\n  return typeof u === \"object\" && u != null && MergeStateTypeId in u;\n};\n\n/** @internal */\nconst isBothRunning = self => {\n  return self._tag === OP_BOTH_RUNNING;\n};\n\n/** @internal */\nconst isLeftDone = self => {\n  return self._tag === OP_LEFT_DONE;\n};\n\n/** @internal */\nconst isRightDone = self => {\n  return self._tag === OP_RIGHT_DONE;\n};\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onBothRunning,\n  onLeftDone,\n  onRightDone\n}) => {\n  switch (self._tag) {\n    case OP_BOTH_RUNNING:\n      {\n        return onBothRunning(self.left, self.right);\n      }\n    case OP_LEFT_DONE:\n      {\n        return onLeftDone(self.f);\n      }\n    case OP_RIGHT_DONE:\n      {\n        return onRightDone(self.f);\n      }\n  }\n});\n\nexport { BothRunning, LeftDone, MergeStateTypeId, RightDone, isBothRunning, isLeftDone, isMergeState, isRightDone, match };\n","/** @internal */\nconst OP_BACK_PRESSURE = \"BackPressure\";\n\n/** @internal */\n\n/** @internal */\nconst OP_BUFFER_SLIDING = \"BufferSliding\";\n\n/** @internal */\n\nexport { OP_BACK_PRESSURE, OP_BUFFER_SLIDING };\n","import { dual } from '../../Function/dist/effect-Function.esm.js';\nimport { OP_BACK_PRESSURE, OP_BUFFER_SLIDING } from '../opCodes/channelMergeStrategy.esm.js';\n\n/** @internal */\nconst MergeStrategySymbolKey = \"effect/ChannelMergeStrategy\";\n\n/** @internal */\nconst MergeStrategyTypeId = /*#__PURE__*/Symbol.for(MergeStrategySymbolKey);\n\n/** @internal */\nconst proto = {\n  [MergeStrategyTypeId]: MergeStrategyTypeId\n};\n\n/** @internal */\nconst BackPressure = _ => {\n  const op = Object.create(proto);\n  op._tag = OP_BACK_PRESSURE;\n  return op;\n};\n\n/** @internal */\nconst BufferSliding = _ => {\n  const op = Object.create(proto);\n  op._tag = OP_BUFFER_SLIDING;\n  return op;\n};\n\n/** @internal */\nconst isMergeStrategy = u => typeof u === \"object\" && u != null && MergeStrategyTypeId in u;\n\n/** @internal */\nconst isBackPressure = self => self._tag === OP_BACK_PRESSURE;\n\n/** @internal */\nconst isBufferSliding = self => self._tag === OP_BUFFER_SLIDING;\n\n/** @internal */\nconst match = /*#__PURE__*/dual(2, (self, {\n  onBackPressure,\n  onBufferSliding\n}) => {\n  switch (self._tag) {\n    case OP_BACK_PRESSURE:\n      {\n        return onBackPressure();\n      }\n    case OP_BUFFER_SLIDING:\n      {\n        return onBufferSliding();\n      }\n  }\n});\n\nexport { BackPressure, BufferSliding, MergeStrategyTypeId, isBackPressure, isBufferSliding, isMergeStrategy, match };\n","import { interrupt, map as map$1 } from '../../Cause/dist/effect-Cause.esm.js';\nimport { make as make$2, await as _await, succeed, failCause } from '../../Deferred/dist/effect-Deferred.esm.js';\nimport { map, flatMap, flatten, unit, fiberIdWith, interrupt as interrupt$1, forEach, succeed as succeed$2, matchCause, zipRight } from '../../Effect/dist/effect-Effect.esm.js';\nimport { left, right, match } from '../../Either/dist/effect-Either.esm.js';\nimport { failCause as failCause$1, succeed as succeed$1, fail } from '../../Exit/dist/effect-Exit.esm.js';\nimport { pipe } from '../../Function/dist/effect-Function.esm.js';\nimport { make as make$1, modify } from '../../Ref/dist/effect-Ref.esm.js';\n\n/** @internal */\n\n/** @internal */\nconst OP_STATE_EMPTY = \"Empty\";\n\n/** @internal */\n\n/** @internal */\nconst OP_STATE_EMIT = \"Emit\";\n\n/** @internal */\n\n/** @internal */\nconst OP_STATE_ERROR = \"Error\";\n\n/** @internal */\n\n/** @internal */\nconst OP_STATE_DONE = \"Done\";\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\n\n/** @internal */\nconst stateEmpty = notifyProducer => ({\n  _tag: OP_STATE_EMPTY,\n  notifyProducer\n});\n\n/** @internal */\nconst stateEmit = notifyConsumers => ({\n  _tag: OP_STATE_EMIT,\n  notifyConsumers\n});\n\n/** @internal */\nconst stateError = cause => ({\n  _tag: OP_STATE_ERROR,\n  cause\n});\n\n/** @internal */\nconst stateDone = done => ({\n  _tag: OP_STATE_DONE,\n  done\n});\n\n/** @internal */\nclass SingleProducerAsyncInputImpl {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  awaitRead() {\n    return flatten(modify(this.ref, state => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [unit, state]));\n  }\n  close() {\n    return fiberIdWith(fiberId => this.error(interrupt(fiberId)));\n  }\n  done(value) {\n    return flatten(modify(this.ref, state => {\n      switch (state._tag) {\n        case OP_STATE_EMPTY:\n          {\n            return [_await(state.notifyProducer), state];\n          }\n        case OP_STATE_EMIT:\n          {\n            return [forEach(state.notifyConsumers, deferred => succeed(deferred, left(value)), {\n              discard: true\n            }), stateDone(value)];\n          }\n        case OP_STATE_ERROR:\n          {\n            return [interrupt$1, state];\n          }\n        case OP_STATE_DONE:\n          {\n            return [interrupt$1, state];\n          }\n      }\n    }));\n  }\n  emit(element) {\n    return flatMap(make$2(), deferred => flatten(modify(this.ref, state => {\n      switch (state._tag) {\n        case OP_STATE_EMPTY:\n          {\n            return [_await(state.notifyProducer), state];\n          }\n        case OP_STATE_EMIT:\n          {\n            const notifyConsumer = state.notifyConsumers[0];\n            const notifyConsumers = state.notifyConsumers.slice(1);\n            if (notifyConsumer !== undefined) {\n              return [succeed(notifyConsumer, right(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];\n            }\n            throw new Error(\"Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! Please report an issue at https://github.com/Effect-TS/stream/issues\");\n          }\n        case OP_STATE_ERROR:\n          {\n            return [interrupt$1, state];\n          }\n        case OP_STATE_DONE:\n          {\n            return [interrupt$1, state];\n          }\n      }\n    })));\n  }\n  error(cause) {\n    return flatten(modify(this.ref, state => {\n      switch (state._tag) {\n        case OP_STATE_EMPTY:\n          {\n            return [_await(state.notifyProducer), state];\n          }\n        case OP_STATE_EMIT:\n          {\n            return [forEach(state.notifyConsumers, deferred => failCause(deferred, cause), {\n              discard: true\n            }), stateError(cause)];\n          }\n        case OP_STATE_ERROR:\n          {\n            return [interrupt$1, state];\n          }\n        case OP_STATE_DONE:\n          {\n            return [interrupt$1, state];\n          }\n      }\n    }));\n  }\n  take() {\n    return this.takeWith(cause => failCause$1(map$1(cause, left)), elem => succeed$1(elem), done => fail(right(done)));\n  }\n  takeWith(onError, onElement, onDone) {\n    return flatMap(make$2(), deferred => flatten(modify(this.ref, state => {\n      switch (state._tag) {\n        case OP_STATE_EMPTY:\n          {\n            return [zipRight(succeed(state.notifyProducer, void 0), matchCause(_await(deferred), {\n              onFailure: onError,\n              onSuccess: match({\n                onLeft: onDone,\n                onRight: onElement\n              })\n            })), stateEmit([deferred])];\n          }\n        case OP_STATE_EMIT:\n          {\n            return [matchCause(_await(deferred), {\n              onFailure: onError,\n              onSuccess: match({\n                onLeft: onDone,\n                onRight: onElement\n              })\n            }), stateEmit([...state.notifyConsumers, deferred])];\n          }\n        case OP_STATE_ERROR:\n          {\n            return [succeed$2(onError(state.cause)), state];\n          }\n        case OP_STATE_DONE:\n          {\n            return [succeed$2(onDone(state.done)), state];\n          }\n      }\n    })));\n  }\n}\n\n/** @internal */\nconst make = () => pipe(make$2(), flatMap(deferred => make$1(stateEmpty(deferred))), map(ref => new SingleProducerAsyncInputImpl(ref)));\n\nexport { make };\n","import { failureOrCause, map as map$2, isInterrupted, die, isDieType } from '../Cause/dist/effect-Cause.esm.js';\nimport { fromIterable, unsafeGet as unsafeGet$1, empty, isEmpty, unsafeFromArray } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { add, merge as merge$1, make as make$4, unsafeGet } from '../Context/dist/effect-Context.esm.js';\nimport { await as _await, make as make$1, succeed as succeed$2, failCause as failCause$2, isDone } from '../Deferred/dist/effect-Deferred.esm.js';\nimport { unit, flatMap as flatMap$1, uninterruptible, tap, context as context$1, map as map$1, suspend as suspend$1, matchCause, flatten as flatten$1, gen, acquireRelease, makeSemaphore, matchCauseEffect, failCause as failCause$1, zipRight as zipRight$1, interruptible, asUnit as asUnit$1, succeed as succeed$1, uninterruptibleMask, exit, raceFirst, tapErrorCause, intoDeferred, forkScoped, forever, raceWith, as as as$1, race, scoped as scoped$1, when, repeatWhile, zip as zip$1, zipWith, forkDaemon, never as never$1, sync as sync$1, setSpan, repeatUntil, catchAllCause as catchAllCause$1 } from '../Effect/dist/effect-Effect.esm.js';\nimport { match, left, right } from '../Either/dist/effect-Either.esm.js';\nimport { equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { failCause as failCause$3, match as match$3, succeed as succeed$3, zip as zip$2 } from '../Exit/dist/effect-Exit.esm.js';\nimport { interrupt, join, await as _await$1 } from '../Fiber/dist/effect-Fiber.esm.js';\nimport { pipe, dual, constVoid, identity } from '../Function/dist/effect-Function.esm.js';\nimport { build, merge, context as context$2 } from '../Layer/dist/effect-Layer.esm.js';\nimport { match as match$1, none, some, isSome } from '../Option/dist/effect-Option.esm.js';\nimport { subscribe } from '../PubSub/dist/effect-PubSub.esm.js';\nimport { take, bounded, shutdown, offer, unbounded, size } from '../Queue/dist/effect-Queue.esm.js';\nimport { make, get, set, update, modify } from '../Ref/dist/effect-Ref.esm.js';\nimport { make as make$3, extend, close } from '../Scope/dist/effect-Scope.esm.js';\nimport { runScoped, run as run$1, ChannelExecutor, readUpstream } from './channel/channelExecutor.esm.js';\nimport { Done, Await } from './channel/mergeDecision.esm.js';\nimport { BothRunning, RightDone, LeftDone } from './channel/mergeState.esm.js';\nimport { match as match$2, BackPressure } from './channel/mergeStrategy.esm.js';\nimport { make as make$2 } from './channel/singleProducerAsyncInput.esm.js';\nimport { flatMap, fromEffect, ensuringWith, suspend, catchAllCause, failCause, concatMapWith, readWith, write, fail, succeedNow, pipeTo, concatAll, readWithCause, succeed, foldCauseChannel, sync, embedInput, provideContext, readOrFail, collectElements, acquireReleaseOut, concatAllWith, unit as unit$1, isChannel } from './core-stream.esm.js';\nimport { OP_DONE as OP_DONE$1 } from './opCodes/channelMergeDecision.esm.js';\nimport { OP_RIGHT_DONE, OP_LEFT_DONE, OP_BOTH_RUNNING } from './opCodes/channelMergeState.esm.js';\nimport { OP_READ, OP_FROM_EFFECT, OP_EMIT, OP_DONE } from './opCodes/channelState.esm.js';\n\n/** @internal */\nconst acquireUseRelease = (acquire, use, release) => flatMap(fromEffect(make(() => unit)), ref => pipe(fromEffect(uninterruptible(tap(acquire, a => set(ref, exit => release(a, exit))))), flatMap(use), ensuringWith(exit => flatMap$1(get(ref), f => f(exit)))));\n\n/** @internal */\nconst as = /*#__PURE__*/dual(2, (self, value) => map(self, () => value));\n\n/** @internal */\nconst asUnit = self => map(self, constVoid);\n\n/** @internal */\nconst buffer = options => suspend(() => {\n  const doBuffer = (empty, isEmpty, ref) => unwrap(modify(ref, inElem => isEmpty(inElem) ? [readWith({\n    onInput: input => flatMap(write(input), () => doBuffer(empty, isEmpty, ref)),\n    onFailure: error => fail(error),\n    onDone: done => succeedNow(done)\n  }), inElem] : [flatMap(write(inElem), () => doBuffer(empty, isEmpty, ref)), empty]));\n  return doBuffer(options.empty, options.isEmpty, options.ref);\n});\n\n/** @internal */\nconst bufferChunk = ref => buffer({\n  empty: empty(),\n  isEmpty: isEmpty,\n  ref\n});\n\n/** @internal */\nconst catchAll = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => match(failureOrCause(cause), {\n  onLeft: f,\n  onRight: failCause\n})));\n\n/** @internal */\nconst concatMap = /*#__PURE__*/dual(2, (self, f) => concatMapWith(self, f, () => void 0, () => void 0));\n\n/** @internal */\nconst collect = /*#__PURE__*/dual(2, (self, pf) => {\n  const collector = readWith({\n    onInput: out => match$1(pf(out), {\n      onNone: () => collector,\n      onSome: out2 => flatMap(write(out2), () => collector)\n    }),\n    onFailure: fail,\n    onDone: succeedNow\n  });\n  return pipeTo(self, collector);\n});\n\n/** @internal */\nconst concatOut = self => concatAll(self);\n\n/** @internal */\nconst mapInput = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: inElem => flatMap(write(inElem), () => reader),\n    onFailure: fail,\n    onDone: done => succeedNow(f(done))\n  });\n  return pipeTo(reader, self);\n});\n\n/** @internal */\nconst mapInputEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: inElem => flatMap(write(inElem), () => reader),\n    onFailure: fail,\n    onDone: done => fromEffect(f(done))\n  });\n  return pipeTo(reader, self);\n});\n\n/** @internal */\nconst mapInputError = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: inElem => flatMap(write(inElem), () => reader),\n    onFailure: error => fail(f(error)),\n    onDone: succeedNow\n  });\n  return pipeTo(reader, self);\n});\n\n/** @internal */\nconst mapInputErrorEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: inElem => flatMap(write(inElem), () => reader),\n    onFailure: error => fromEffect(f(error)),\n    onDone: succeedNow\n  });\n  return pipeTo(reader, self);\n});\n\n/** @internal */\nconst mapInputIn = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: inElem => flatMap(write(f(inElem)), () => reader),\n    onFailure: fail,\n    onDone: succeedNow\n  });\n  return pipeTo(reader, self);\n});\nconst mapInputInEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: inElem => flatMap(flatMap(fromEffect(f(inElem)), write), () => reader),\n    onFailure: fail,\n    onDone: succeedNow\n  });\n  return pipeTo(reader, self);\n});\n\n/** @internal */\nconst doneCollect = self => suspend(() => {\n  const builder = [];\n  return pipe(pipeTo(self, doneCollectReader(builder)), flatMap(outDone => succeed([unsafeFromArray(builder), outDone])));\n});\n\n/** @internal */\nconst doneCollectReader = builder => {\n  return readWith({\n    onInput: outElem => flatMap(sync(() => {\n      builder.push(outElem);\n    }), () => doneCollectReader(builder)),\n    onFailure: fail,\n    onDone: succeed\n  });\n};\n\n/** @internal */\nconst drain = self => {\n  const drainer = readWithCause({\n    onInput: () => drainer,\n    onFailure: failCause,\n    onDone: succeed\n  });\n  return pipeTo(self, drainer);\n};\n\n/** @internal */\nconst emitCollect = self => flatMap(doneCollect(self), write);\n\n/** @internal */\nconst ensuring = /*#__PURE__*/dual(2, (self, finalizer) => ensuringWith(self, () => finalizer));\n\n/** @internal */\nconst context = () => fromEffect(context$1());\n\n/** @internal */\nconst contextWith = f => map(context(), f);\n\n/** @internal */\nconst contextWithChannel = f => flatMap(context(), f);\n\n/** @internal */\nconst contextWithEffect = f => mapEffect(context(), f);\n\n/** @internal */\nconst flatten = self => flatMap(self, identity);\n\n/** @internal */\nconst foldChannel = /*#__PURE__*/dual(2, (self, options) => foldCauseChannel(self, {\n  onFailure: cause => {\n    const either = failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return options.onFailure(either.left);\n        }\n      case \"Right\":\n        {\n          return failCause(either.right);\n        }\n    }\n  },\n  onSuccess: options.onSuccess\n}));\n\n/** @internal */\nconst fromEither = either => suspend(() => match(either, {\n  onLeft: fail,\n  onRight: succeed\n}));\n\n/** @internal */\nconst fromInput = input => unwrap(input.takeWith(failCause, elem => flatMap(write(elem), () => fromInput(input)), succeed));\n\n/** @internal */\nconst fromPubSub = pubsub => unwrapScoped(map$1(subscribe(pubsub), fromQueue));\n\n/** @internal */\nconst fromPubSubScoped = pubsub => map$1(subscribe(pubsub), fromQueue);\n\n/** @internal */\nconst fromOption = option => suspend(() => match$1(option, {\n  onNone: () => fail(none()),\n  onSome: succeed\n}));\n\n/** @internal */\nconst fromQueue = queue => suspend(() => fromQueueInternal(queue));\n\n/** @internal */\nconst fromQueueInternal = queue => pipe(fromEffect(take(queue)), flatMap(match({\n  onLeft: match$3({\n    onFailure: failCause,\n    onSuccess: succeedNow\n  }),\n  onRight: elem => flatMap(write(elem), () => fromQueueInternal(queue))\n})));\n\n/** @internal */\nconst identityChannel = () => readWith({\n  onInput: input => flatMap(write(input), () => identityChannel()),\n  onFailure: fail,\n  onDone: succeedNow\n});\n\n/** @internal */\nconst interruptWhen = /*#__PURE__*/dual(2, (self, effect) => mergeWith(self, {\n  other: fromEffect(effect),\n  onSelfDone: selfDone => Done(suspend$1(() => selfDone)),\n  onOtherDone: effectDone => Done(suspend$1(() => effectDone))\n}));\n\n/** @internal */\nconst interruptWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => sync(() => f(a))));\n\n/** @internal */\nconst mapEffect = /*#__PURE__*/dual(2, (self, f) => flatMap(self, z => fromEffect(f(z))));\n\n/** @internal */\nconst mapError = /*#__PURE__*/dual(2, (self, f) => mapErrorCause(self, map$2(f)));\n\n/** @internal */\nconst mapErrorCause = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => failCause(f(cause))));\n\n/** @internal */\nconst mapOut = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWith({\n    onInput: outElem => flatMap(write(f(outElem)), () => reader),\n    onFailure: fail,\n    onDone: succeedNow\n  });\n  return pipeTo(self, reader);\n});\n\n/** @internal */\nconst mapOutEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const reader = readWithCause({\n    onInput: outElem => pipe(fromEffect(f(outElem)), flatMap(write), flatMap(() => reader)),\n    onFailure: failCause,\n    onDone: succeedNow\n  });\n  return pipeTo(self, reader);\n});\n\n/** @internal */\nconst mapOutEffectPar = /*#__PURE__*/dual(3, (self, f, n) => pipe(gen(function* ($) {\n  const queue = yield* $(acquireRelease(bounded(n), queue => shutdown(queue)));\n  const errorSignal = yield* $(make$1());\n  const withPermits = n === Number.POSITIVE_INFINITY ? _ => identity : (yield* $(makeSemaphore(n))).withPermits;\n  const pull = yield* $(toPull(self));\n  yield* $(matchCauseEffect(pull, {\n    onFailure: cause => offer(queue, failCause$1(cause)),\n    onSuccess: either => match(either, {\n      onLeft: outDone => {\n        const lock = withPermits(n);\n        return zipRight$1(interruptible(lock(unit)), asUnit$1(offer(queue, succeed$1(left(outDone)))));\n      },\n      onRight: outElem => gen(function* ($) {\n        const deferred = yield* $(make$1());\n        const latch = yield* $(make$1());\n        yield* $(asUnit$1(offer(queue, map$1(_await(deferred), right))));\n        yield* $(succeed$2(latch, void 0), zipRight$1(pipe(uninterruptibleMask(restore => pipe(exit(restore(_await(errorSignal))), raceFirst(exit(restore(f(outElem)))),\n        // TODO: remove\n        flatMap$1(exit => suspend$1(() => exit)))), tapErrorCause(cause => failCause$2(errorSignal, cause)), intoDeferred(deferred))), withPermits(1), forkScoped);\n        yield* $(_await(latch));\n      })\n    })\n  }), forever, interruptible, forkScoped);\n  return queue;\n}), map$1(queue => {\n  const consumer = unwrap(matchCause(flatten$1(take(queue)), {\n    onFailure: failCause,\n    onSuccess: match({\n      onLeft: succeedNow,\n      onRight: outElem => flatMap(write(outElem), () => consumer)\n    })\n  }));\n  return consumer;\n}), unwrapScoped));\n\n/** @internal */\nconst mergeAll = options => {\n  return channels => mergeAllWith(options)(channels, constVoid);\n};\n\n/** @internal */\nconst mergeAllUnbounded = channels => mergeAllWith({\n  concurrency: \"unbounded\"\n})(channels, constVoid);\n\n/** @internal */\nconst mergeAllUnboundedWith = (channels, f) => mergeAllWith({\n  concurrency: \"unbounded\"\n})(channels, f);\n\n/** @internal */\nconst mergeAllWith = ({\n  bufferSize = 16,\n  concurrency,\n  mergeStrategy = BackPressure()\n}) => (channels, f) => pipe(gen(function* ($) {\n  const input = yield* $(make$2());\n  const queueReader = fromInput(input);\n  const queue = yield* $(acquireRelease(bounded(bufferSize), queue => shutdown(queue)));\n  const cancelers = yield* $(acquireRelease(unbounded(), queue => shutdown(queue)));\n  const lastDone = yield* $(make(none()));\n  const errorSignal = yield* $(make$1());\n  const withPermits = concurrency === \"unbounded\" ? _ => identity : (yield* $(makeSemaphore(concurrency))).withPermits;\n  const pull = yield* $(toPull(channels));\n  const evaluatePull = pull => pipe(flatMap$1(pull, match({\n    onLeft: done => succeed$1(some(done)),\n    onRight: outElem => as$1(offer(queue, succeed$1(right(outElem))), none())\n  })), repeatUntil(isSome), flatMap$1(match$1({\n    onNone: () => unit,\n    onSome: outDone => update(lastDone, match$1({\n      onNone: () => some(outDone),\n      onSome: lastDone => some(f(lastDone, outDone))\n    }))\n  })), catchAllCause$1(cause => isInterrupted(cause) ? failCause$1(cause) : pipe(offer(queue, failCause$1(cause)), zipRight$1(succeed$2(errorSignal, void 0)), asUnit$1)));\n  yield* $(matchCauseEffect(pull, {\n    onFailure: cause => pipe(offer(queue, failCause$1(cause)), zipRight$1(succeed$1(false))),\n    onSuccess: match({\n      onLeft: outDone => raceWith(_await(errorSignal), withPermits(concurrency)(unit), {\n        onSelfDone: (_, permitAcquisition) => pipe(interrupt(permitAcquisition), as$1(false)),\n        onOtherDone: (_, failureAwait) => pipe(interrupt(failureAwait), zipRight$1(pipe(get(lastDone), flatMap$1(match$1({\n          onNone: () => offer(queue, succeed$1(left(outDone))),\n          onSome: lastDone => offer(queue, succeed$1(left(f(lastDone, outDone))))\n        })), as$1(false))))\n      }),\n      onRight: channel => pipe(mergeStrategy, match$2({\n        onBackPressure: () => gen(function* ($) {\n          const latch = yield* $(make$1());\n          const raceEffects = pipe(queueReader, pipeTo(channel), toPull, flatMap$1(pull => pipe(evaluatePull(pull), race(_await(errorSignal)))), scoped$1);\n          yield* $(succeed$2(latch, void 0), zipRight$1(raceEffects), withPermits(1), forkScoped);\n          yield* $(_await(latch));\n          const errored = yield* $(isDone(errorSignal));\n          return !errored;\n        }),\n        onBufferSliding: () => gen(function* ($) {\n          const canceler = yield* $(make$1());\n          const latch = yield* $(make$1());\n          const size$1 = yield* $(size(cancelers));\n          yield* $(take(cancelers), flatMap$1(_ => succeed$2(_, void 0)), when(() => concurrency === \"unbounded\" ? false : size$1 >= concurrency));\n          yield* $(offer(cancelers, canceler));\n          const raceEffects = pipe(queueReader, pipeTo(channel), toPull, flatMap$1(pull => pipe(evaluatePull(pull), race(_await(errorSignal)), race(_await(canceler)))), scoped$1);\n          yield* $(succeed$2(latch, void 0), zipRight$1(raceEffects), withPermits(1), forkScoped);\n          yield* $(_await(latch));\n          const errored = yield* $(isDone(errorSignal));\n          return !errored;\n        })\n      }))\n    })\n  }), repeatWhile(identity), forkScoped);\n  return [queue, input];\n}), map$1(([queue, input]) => {\n  const consumer = pipe(take(queue), flatten$1, matchCause({\n    onFailure: failCause,\n    onSuccess: match({\n      onLeft: succeedNow,\n      onRight: outElem => flatMap(write(outElem), () => consumer)\n    })\n  }), unwrap);\n  return embedInput(consumer, input);\n}), unwrapScoped);\n\n/** @internal */\nconst mergeMap = /*#__PURE__*/dual(3, (self, f, options) => mergeAll(options)(mapOut(self, f)));\n\n/** @internal */\nconst mergeOut = /*#__PURE__*/dual(2, (self, n) => mergeAll({\n  concurrency: n\n})(mapOut(self, identity)));\n\n/** @internal */\nconst mergeOutWith = /*#__PURE__*/dual(3, (self, n, f) => mergeAllWith({\n  concurrency: n\n})(mapOut(self, identity), f));\n\n/** @internal */\nconst mergeWith = /*#__PURE__*/dual(2, (self, options) => unwrapScoped(flatMap$1(make$2(), input => {\n  const queueReader = fromInput(input);\n  return map$1(zip$1(toPull(pipeTo(queueReader, self)), toPull(pipeTo(queueReader, options.other))), ([pullL, pullR]) => {\n    const handleSide = (exit, fiber, pull) => (done, both, single) => {\n      const onDecision = decision => {\n        const op = decision;\n        if (op._tag === OP_DONE$1) {\n          return succeed$1(fromEffect(zipRight$1(interrupt(fiber), op.effect)));\n        }\n        return map$1(_await$1(fiber), match$3({\n          onFailure: cause => fromEffect(op.f(failCause$3(cause))),\n          onSuccess: match({\n            onLeft: done => fromEffect(op.f(succeed$3(done))),\n            onRight: elem => zipRight(write(elem), go(single(op.f)))\n          })\n        }));\n      };\n      return match$3(exit, {\n        onFailure: cause => onDecision(done(failCause$3(cause))),\n        onSuccess: match({\n          onLeft: z => onDecision(done(succeed$3(z))),\n          onRight: elem => succeed$1(flatMap(write(elem), () => flatMap(fromEffect(forkDaemon(pull)), leftFiber => go(both(leftFiber, fiber)))))\n        })\n      });\n    };\n    const go = state => {\n      switch (state._tag) {\n        case OP_BOTH_RUNNING:\n          {\n            const leftJoin = interruptible(join(state.left));\n            const rightJoin = interruptible(join(state.right));\n            return unwrap(raceWith(leftJoin, rightJoin, {\n              onSelfDone: (leftExit, rf) => zipRight$1(interrupt(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, f => LeftDone(f))),\n              onOtherDone: (rightExit, lf) => zipRight$1(interrupt(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left, right) => BothRunning(right, left), f => RightDone(f)))\n            }));\n          }\n        case OP_LEFT_DONE:\n          {\n            return unwrap(map$1(exit(pullR), match$3({\n              onFailure: cause => fromEffect(state.f(failCause$3(cause))),\n              onSuccess: match({\n                onLeft: done => fromEffect(state.f(succeed$3(done))),\n                onRight: elem => flatMap(write(elem), () => go(LeftDone(state.f)))\n              })\n            })));\n          }\n        case OP_RIGHT_DONE:\n          {\n            return unwrap(map$1(exit(pullL), match$3({\n              onFailure: cause => fromEffect(state.f(failCause$3(cause))),\n              onSuccess: match({\n                onLeft: done => fromEffect(state.f(succeed$3(done))),\n                onRight: elem => flatMap(write(elem), () => go(RightDone(state.f)))\n              })\n            })));\n          }\n      }\n    };\n    return pipe(fromEffect(zipWith(forkDaemon(pullL), forkDaemon(pullR), (left, right) => BothRunning(left, right))), flatMap(go), embedInput(input));\n  });\n})));\n\n/** @internal */\nconst never = /*#__PURE__*/fromEffect(never$1);\n\n/** @internal */\nconst orDie = /*#__PURE__*/dual(2, (self, error) => orDieWith(self, error));\n\n/** @internal */\nconst orDieWith = /*#__PURE__*/dual(2, (self, f) => catchAll(self, e => {\n  throw f(e);\n}));\n\n/** @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => catchAll(self, that));\n\n/** @internal */\nconst pipeToOrFail = /*#__PURE__*/dual(2, (self, that) => suspend(() => {\n  let channelException = undefined;\n  const reader = readWith({\n    onInput: outElem => flatMap(write(outElem), () => reader),\n    onFailure: outErr => {\n      channelException = ChannelException(outErr);\n      return failCause(die(channelException));\n    },\n    onDone: succeedNow\n  });\n  const writer = readWithCause({\n    onInput: outElem => pipe(write(outElem), flatMap(() => writer)),\n    onFailure: cause => isDieType(cause) && isChannelException(cause.defect) && equals(cause.defect, channelException) ? fail(cause.defect.error) : failCause(cause),\n    onDone: succeedNow\n  });\n  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);\n}));\n\n/** @internal */\nconst provideService = /*#__PURE__*/dual(3, (self, tag, service) => {\n  return flatMap(context(), context => provideContext(self, add(context, tag, service)));\n});\n\n/** @internal */\nconst provideLayer = /*#__PURE__*/dual(2, (self, layer) => unwrapScoped(map$1(build(layer), env => provideContext(self, env))));\n\n/** @internal */\nconst mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithChannel(context => provideContext(self, f(context))));\n\n/** @internal */\nconst provideSomeLayer = /*#__PURE__*/dual(2, (self, layer) =>\n// @ts-expect-error\nprovideLayer(self, merge(context$2(), layer)));\n\n/** @internal */\nconst read = () => readOrFail(none());\n\n/** @internal */\nconst repeated = self => flatMap(self, () => repeated(self));\n\n/** @internal */\nconst run = self => scoped$1(runScoped(self));\n\n/** @internal */\nconst runCollect = self => run$1(collectElements(self));\n\n/** @internal */\nconst runDrain = self => run$1(drain(self));\n\n/** @internal */\nconst scoped = effect => unwrap(uninterruptibleMask(restore => map$1(make$3(), scope => acquireReleaseOut(tapErrorCause(restore(extend(scope)(effect)), cause => close(scope, failCause$3(cause))), (_, exit) => close(scope, exit)))));\n\n/** @internal */\nconst toPubSub = pubsub => toQueue(pubsub);\n\n/** @internal */\nconst toPull = self => map$1(acquireRelease(sync$1(() => new ChannelExecutor(self, void 0, identity)), (exec, exit) => {\n  const finalize = exec.close(exit);\n  return finalize === undefined ? unit : finalize;\n}), exec => suspend$1(() => interpretToPull(exec.run(), exec)));\n\n/** @internal */\nconst interpretToPull = (channelState, exec) => {\n  const state = channelState;\n  switch (state._tag) {\n    case OP_DONE:\n      {\n        return match$3(exec.getDone(), {\n          onFailure: failCause$1,\n          onSuccess: done => succeed$1(left(done))\n        });\n      }\n    case OP_EMIT:\n      {\n        return succeed$1(right(exec.getEmit()));\n      }\n    case OP_FROM_EFFECT:\n      {\n        return pipe(state.effect, flatMap$1(() => interpretToPull(exec.run(), exec)));\n      }\n    case OP_READ:\n      {\n        return readUpstream(state, () => interpretToPull(exec.run(), exec), cause => failCause$1(cause));\n      }\n  }\n};\n\n/** @internal */\nconst toQueue = queue => suspend(() => toQueueInternal(queue));\n\n/** @internal */\nconst toQueueInternal = queue => {\n  return readWithCause({\n    onInput: elem => flatMap(fromEffect(offer(queue, right(elem))), () => toQueueInternal(queue)),\n    onFailure: cause => fromEffect(pipe(offer(queue, left(failCause$3(cause))))),\n    onDone: done => fromEffect(pipe(offer(queue, left(succeed$3(done)))))\n  });\n};\n\n/** @internal */\nconst unwrap = channel => flatten(fromEffect(channel));\n\n/** @internal */\nconst unwrapScoped = self => concatAllWith(scoped(self), (d, _) => d, (d, _) => d);\n\n/** @internal */\nconst updateService = /*#__PURE__*/dual(3, (self, tag, f) => mapInputContext(self, context => merge$1(context, make$4(tag, f(unsafeGet(context, tag))))));\n\n/** @internal */\nconst withSpan = /*#__PURE__*/dual(3, (self, name, options) => unwrapScoped(as$1(setSpan(name, options), self)));\n\n/** @internal */\nconst writeAll = (...outs) => writeChunk(fromIterable(outs));\n\n/** @internal */\nconst writeChunk = outs => writeChunkWriter(0, outs.length, outs);\n\n/** @internal */\nconst writeChunkWriter = (idx, len, chunk) => {\n  return idx === len ? unit$1 : pipe(write(pipe(chunk, unsafeGet$1(idx))), flatMap(() => writeChunkWriter(idx + 1, len, chunk)));\n};\n\n/** @internal */\nconst zip = /*#__PURE__*/dual(args => isChannel(args[1]), (self, that, options) => options?.concurrent ? mergeWith(self, {\n  other: that,\n  onSelfDone: exit1 => Await(exit2 => suspend$1(() => zip$2(exit1, exit2))),\n  onOtherDone: exit2 => Await(exit1 => suspend$1(() => zip$2(exit1, exit2)))\n}) : flatMap(self, a => map(that, b => [a, b])));\n\n/** @internal */\nconst zipLeft = /*#__PURE__*/dual(args => isChannel(args[1]), (self, that, options) => options?.concurrent ? map(zip(self, that, {\n  concurrent: true\n}), tuple => tuple[0]) : flatMap(self, z => as(that, z)));\n\n/** @internal */\nconst zipRight = /*#__PURE__*/dual(args => isChannel(args[1]), (self, that, options) => options?.concurrent ? map(zip(self, that, {\n  concurrent: true\n}), tuple => tuple[1]) : flatMap(self, () => that));\n\n/** @internal */\nconst ChannelExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Channel/ChannelException\");\n\n/** @internal */\nconst ChannelException = error => ({\n  _tag: \"ChannelException\",\n  [ChannelExceptionTypeId]: ChannelExceptionTypeId,\n  error\n});\n\n/** @internal */\nconst isChannelException = u => typeof u === \"object\" && u != null && ChannelExceptionTypeId in u;\n\nexport { ChannelException, ChannelExceptionTypeId, acquireUseRelease, as, asUnit, buffer, bufferChunk, catchAll, collect, concatMap, concatOut, context, contextWith, contextWithChannel, contextWithEffect, doneCollect, drain, emitCollect, ensuring, flatten, foldChannel, fromEither, fromInput, fromOption, fromPubSub, fromPubSubScoped, fromQueue, identityChannel, interruptWhen, interruptWhenDeferred, isChannelException, map, mapEffect, mapError, mapErrorCause, mapInput, mapInputContext, mapInputEffect, mapInputError, mapInputErrorEffect, mapInputIn, mapInputInEffect, mapOut, mapOutEffect, mapOutEffectPar, mergeAll, mergeAllUnbounded, mergeAllUnboundedWith, mergeAllWith, mergeMap, mergeOut, mergeOutWith, mergeWith, never, orDie, orDieWith, orElse, pipeToOrFail, provideLayer, provideService, provideSomeLayer, read, repeated, run, runCollect, runDrain, scoped, toPubSub, toPull, toQueue, unwrap, unwrapScoped, updateService, withSpan, writeAll, writeChunk, zip, zipLeft, zipRight };\n","import { flipCauseOption, failureOrCause, map as map$3, isInterrupted, die as die$2, IllegalArgumentException, RuntimeException, isDieType, isRuntimeException, squash } from '../Cause/dist/effect-Cause.esm.js';\nimport { Done, Await } from '../ChannelMergeDecision/dist/effect-ChannelMergeDecision.esm.js';\nimport { empty as empty$1, isNonEmpty, of, map as map$2, range as range$1, unsafeFromArray, reduceRight, prepend as prepend$1, isEmpty, dropWhile as dropWhile$1, filter as filter$1, filterMap as filterMap$1, filterMapWhile as filterMapWhile$1, findFirst, fromIterable as fromIterable$1, flatMap as flatMap$3, takeWhile as takeWhile$1, take as take$3, drop as drop$1, appendAll, unsafeLast, zipWith as zipWith$2, reduce, append, last as last$1, splitWhere, head as head$1, mapAccum as mapAccum$1, make as make$7, unsafeGet as unsafeGet$1, flatten as flatten$2, isChunk, appendAllNonEmpty, splitAt, takeRight as takeRight$1 } from '../Chunk/dist/effect-Chunk.esm.js';\nimport { sleep, currentTimeMillis } from '../Clock/dist/effect-Clock.esm.js';\nimport { add, unsafeGet } from '../Context/dist/effect-Context.esm.js';\nimport { make as make$4, succeed as succeed$2, await as _await, failCause as failCause$3, poll, fail as fail$4 } from '../Deferred/dist/effect-Deferred.esm.js';\nimport { toMillis, millis, greaterThan, zero } from '../Duration/dist/effect-Duration.esm.js';\nimport { acquireRelease as acquireRelease$1, all, when as when$1, flatMap as flatMap$2, zipRight as zipRight$1, succeed as succeed$1, map as map$1, forkScoped, scope, runtime, match as match$1, sync as sync$1, as as as$1, unit as unit$2, onError as onError$1, tap as tap$1, gen, suspend as suspend$1, transplant, die as die$1, dieSync as dieSync$1, dieMessage as dieMessage$1, makeSemaphore, matchCauseEffect, flatten as flatten$1, forEach, catchAllCause as catchAllCause$2, dropUntil as dropUntil$1, dropWhile as dropWhile$2, context as context$1, fail as fail$3, failSync as failSync$1, failCause as failCause$4, failCauseSync as failCauseSync$1, findFirst as findFirst$1, tryPromise, promise, isEffect, mapError as mapError$1, zip as zip$1, never as never$1, orDie as orDie$1, matchEffect, scoped as scoped$1, asUnit, forkDaemon, ensuring as ensuring$2, timeoutFail as timeoutFail$1, timeoutFailCause as timeoutFailCause$1, runSync, catchTags as catchTags$1, tapErrorCause as tapErrorCause$1, runPromise, setSpan, raceWith, zipWith as zipWith$1, forkIn, reduce as reduce$1, catchSomeCause as catchSomeCause$1, orElse as orElse$2, zipLeft as zipLeft$1, catchAll as catchAll$2, asSome, succeedNone, fork } from '../Effect/dist/effect-Effect.esm.js';\nimport { match, left, right } from '../Either/dist/effect-Either.esm.js';\nimport { equals } from '../Equal/dist/effect-Equal.esm.js';\nimport { match as match$3, failCause as failCause$2, fail as fail$2, isSuccess, succeed as succeed$4, unit as unit$3, isFailure } from '../Exit/dist/effect-Exit.esm.js';\nimport { join, interrupt, poll as poll$1 } from '../Fiber/dist/effect-Fiber.esm.js';\nimport { dual, pipe, identity, constTrue } from '../Function/dist/effect-Function.esm.js';\nimport { build, context as context$2, merge as merge$1 } from '../Layer/dist/effect-Layer.esm.js';\nimport { none, some as some$1, match as match$2, getOrElse, map as map$4, isSome, isNone } from '../Option/dist/effect-Option.esm.js';\nimport { pipeArguments } from '../Pipeable/dist/effect-Pipeable.esm.js';\nimport { bounded as bounded$1, subscribe, shutdown as shutdown$1 } from '../PubSub/dist/effect-PubSub.esm.js';\nimport { take as take$2, shutdown, bounded, dropping, sliding as sliding$1, isShutdown, takeBetween, offerAll, offer as offer$1, unbounded } from '../Queue/dist/effect-Queue.esm.js';\nimport { make as make$2, getAndSet, set, get, update, modify } from '../Ref/dist/effect-Ref.esm.js';\nimport { runPromiseExit } from '../Runtime/dist/effect-Runtime.esm.js';\nimport { forever as forever$1, driver, spaced } from '../Schedule/dist/effect-Schedule.esm.js';\nimport { make as make$6, close, use } from '../Scope/dist/effect-Scope.esm.js';\nimport { Both } from '../StreamHaltStrategy/dist/effect-StreamHaltStrategy.esm.js';\nimport { unwrap as unwrap$1, zipRight as zipRight$2, pipeToOrFail, unwrapScoped as unwrapScoped$1, concatMap, writeChunk, drain as drain$1, identityChannel, ensuring as ensuring$1, mapOut, mapOutEffectPar, repeated, interruptWhen as interruptWhen$1, interruptWhenDeferred as interruptWhenDeferred$1, mapOutEffect, mapError as mapError$2, mapErrorCause as mapErrorCause$1, mergeWith as mergeWith$1, orDieWith as orDieWith$1, orElse as orElse$1, catchAll as catchAll$1, runDrain as runDrain$1, scoped as scoped$2, toPull as toPull$1, fromInput as fromInput$1, mergeMap, writeAll } from './channel.esm.js';\nimport { run as run$1, runScoped as runScoped$1 } from './channel/channelExecutor.esm.js';\nimport { BufferSliding } from './channel/mergeStrategy.esm.js';\nimport { make as make$5 } from './channel/singleProducerAsyncInput.esm.js';\nimport { readWithCause, flatMap as flatMap$1, fromEffect as fromEffect$1, write, failCause as failCause$1, unit as unit$1, pipeTo, collectElements, fail as fail$1, catchAllCause as catchAllCause$1, readWith, suspend as suspend$2, succeedNow, ensuringWith as ensuringWith$1, succeed as succeed$3, provideContext as provideContext$1, foldCauseChannel, embedInput, sync as sync$2 } from './core-stream.esm.js';\nimport { RingBuffer } from './ringBuffer.esm.js';\nimport { toChannel as toChannel$1, collectAllN, mkString as mkString$1, foldSink, collectLeftover, zipRight as zipRight$3, fromEffect as fromEffect$2, fail as fail$5, fromChannel as fromChannel$1, collectAll, count, drain as drain$2, fold, foldEffect, forEach as forEach$1, forEachChunk, forEachWhile, head, last, sum } from './sink.esm.js';\nimport { OP_CURRENT, OP_PREVIOUS, current, OP_NOT_STARTED, notStarted, previous } from './stream/debounceState.esm.js';\nimport { make as make$3 } from './stream/emit.esm.js';\nimport { fromInput } from './stream/haltStrategy.esm.js';\nimport { make as make$1, offer, take as take$1 } from './stream/handoff.esm.js';\nimport { emit, halt, end, OP_END, OP_HALT, OP_EMIT } from './stream/handoffSignal.esm.js';\nimport { end as end$1, failCause as failCause$5 } from './stream/pull.esm.js';\nimport { ScheduleEnd, OP_SCHEDULE_END, UpstreamEnd, OP_UPSTREAM_END } from './stream/sinkEndReason.esm.js';\nimport { PullBoth, OP_PULL_RIGHT, DrainLeft, PullRight, OP_PULL_LEFT, DrainRight, PullLeft, OP_PULL_BOTH, OP_DRAIN_RIGHT, OP_DRAIN_LEFT } from './stream/zipAllState.esm.js';\nimport { PullBoth as PullBoth$1, OP_PULL_RIGHT as OP_PULL_RIGHT$1, PullRight as PullRight$1, PullLeft as PullLeft$1, OP_PULL_LEFT as OP_PULL_LEFT$1, OP_PULL_BOTH as OP_PULL_BOTH$1 } from './stream/zipChunksState.esm.js';\nimport { done, match as match$4, chunk, failCause as failCause$6, end as end$2, fromPull as fromPull$1, of as of$1 } from './take.esm.js';\n\n/** @internal */\nconst StreamSymbolKey = \"effect/Stream\";\n\n/** @internal */\nconst StreamTypeId = /*#__PURE__*/Symbol.for(StreamSymbolKey);\n\n/** @internal */\nconst streamVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n\n/** @internal */\nclass StreamImpl {\n  [StreamTypeId] = streamVariance;\n  constructor(channel) {\n    this.channel = channel;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst isStream = u => typeof u === \"object\" && u != null && StreamTypeId in u || isEffect(u);\n\n/** @internal */\nconst DefaultChunkSize = 4096;\n\n/** @internal */\nconst acquireRelease = (acquire, release) => scoped(acquireRelease$1(acquire, release));\n\n/** @internal */\nconst aggregate = /*#__PURE__*/dual(2, (self, sink) => aggregateWithin(self, sink, forever$1));\n\n/** @internal */\nconst aggregateWithin = /*#__PURE__*/dual(3, (self, sink, schedule) => filterMap(aggregateWithinEither(self, sink, schedule), _ => match(_, {\n  onLeft: none,\n  onRight: some$1\n})));\n\n/** @internal */\nconst aggregateWithinEither = /*#__PURE__*/dual(3, (self, sink, schedule) => {\n  const layer = all([make$1(), make$2(ScheduleEnd), make$2(empty$1()), driver(schedule), make$2(false), make$2(false)]);\n  return pipe(fromEffect(layer), flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {\n    const handoffProducer = readWithCause({\n      onInput: input => flatMap$1(fromEffect$1(pipe(handoff, offer(emit(input)), when$1(() => isNonEmpty(input)))), () => handoffProducer),\n      onFailure: cause => fromEffect$1(offer(handoff, halt(cause))),\n      onDone: () => fromEffect$1(offer(handoff, end(UpstreamEnd)))\n    });\n    const handoffConsumer = pipe(getAndSet(sinkLeftovers, empty$1()), flatMap$2(leftovers => {\n      if (isNonEmpty(leftovers)) {\n        return pipe(set(consumed, true), zipRight$1(succeed$1(pipe(write(leftovers), flatMap$1(() => handoffConsumer)))));\n      }\n      return pipe(take$1(handoff), map$1(signal => {\n        switch (signal._tag) {\n          case OP_EMIT:\n            {\n              return pipe(fromEffect$1(set(consumed, true)), zipRight$2(write(signal.elements)), zipRight$2(fromEffect$1(get(endAfterEmit))), flatMap$1(bool => bool ? unit$1 : handoffConsumer));\n            }\n          case OP_HALT:\n            {\n              return failCause$1(signal.cause);\n            }\n          case OP_END:\n            {\n              if (signal.reason._tag === OP_SCHEDULE_END) {\n                return pipe(get(consumed), map$1(bool => bool ? fromEffect$1(pipe(set(sinkEndReason, ScheduleEnd), zipRight$1(set(endAfterEmit, true)))) : pipe(fromEffect$1(pipe(set(sinkEndReason, ScheduleEnd), zipRight$1(set(endAfterEmit, true)))), flatMap$1(() => handoffConsumer))), unwrap$1);\n              }\n              return pipe(set(sinkEndReason, signal.reason), zipRight$1(set(endAfterEmit, true)), fromEffect$1);\n            }\n        }\n      }));\n    }), unwrap$1);\n    const timeout = lastB => scheduleDriver.next(lastB);\n    const scheduledAggregator = (sinkFiber, scheduleFiber, scope) => {\n      const forkSink = pipe(set(consumed, false), zipRight$1(set(endAfterEmit, false)), zipRight$1(pipe(handoffConsumer, pipeToOrFail(toChannel$1(sink)), collectElements, run$1, forkIn(scope))));\n      const handleSide = (leftovers, b, c) => pipe(set(sinkLeftovers, flatten$2(leftovers)), zipRight$1(map$1(get(sinkEndReason), reason => {\n        switch (reason._tag) {\n          case OP_SCHEDULE_END:\n            {\n              return pipe(all([get(consumed), forkSink, pipe(timeout(some$1(b)), forkIn(scope))]), map$1(([wasConsumed, sinkFiber, scheduleFiber]) => {\n                const toWrite = pipe(c, match$2({\n                  onNone: () => of(right(b)),\n                  onSome: c => make$7(right(b), left(c))\n                }));\n                if (wasConsumed) {\n                  return pipe(write(toWrite), flatMap$1(() => scheduledAggregator(sinkFiber, scheduleFiber, scope)));\n                }\n                return scheduledAggregator(sinkFiber, scheduleFiber, scope);\n              }), unwrap$1);\n            }\n          case OP_UPSTREAM_END:\n            {\n              return pipe(get(consumed), map$1(wasConsumed => wasConsumed ? write(of(right(b))) : unit$1), unwrap$1);\n            }\n        }\n      })), unwrap$1);\n      return unwrap$1(raceWith(join(sinkFiber), join(scheduleFiber), {\n        onSelfDone: (sinkExit, _) => pipe(interrupt(scheduleFiber), zipRight$1(pipe(suspend$1(() => sinkExit), map$1(([leftovers, b]) => handleSide(leftovers, b, none()))))),\n        onOtherDone: (scheduleExit, _) => matchCauseEffect(suspend$1(() => scheduleExit), {\n          onFailure: cause => match(failureOrCause(cause), {\n            onLeft: () => pipe(handoff, offer(end(ScheduleEnd)), forkDaemon, zipRight$1(pipe(join(sinkFiber), map$1(([leftovers, b]) => handleSide(leftovers, b, none()))))),\n            onRight: cause => pipe(handoff, offer(halt(cause)), forkDaemon, zipRight$1(pipe(join(sinkFiber), map$1(([leftovers, b]) => handleSide(leftovers, b, none())))))\n          }),\n          onSuccess: c => pipe(handoff, offer(end(ScheduleEnd)), forkDaemon, zipRight$1(pipe(join(sinkFiber), map$1(([leftovers, b]) => handleSide(leftovers, b, some$1(c))))))\n        })\n      }));\n    };\n    return unwrapScoped(pipe(self, toChannel, pipeTo(handoffProducer), run$1, forkScoped, zipRight$1(pipe(handoffConsumer, pipeToOrFail(toChannel$1(sink)), collectElements, run$1, forkScoped, flatMap$2(sinkFiber => pipe(forkScoped(timeout(none())), flatMap$2(scheduleFiber => pipe(scope, map$1(scope => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope)))))))))));\n  }));\n});\n\n/** @internal */\nconst as = /*#__PURE__*/dual(2, (self, value) => map(self, () => value));\n\n/** @internal */\nconst _async = (register, outputBuffer = 16) => asyncOption(cb => {\n  register(cb);\n  return none();\n}, outputBuffer);\n\n/** @internal */\nconst asyncEffect = (register, outputBuffer = 16) => pipe(acquireRelease$1(bounded(outputBuffer), queue => shutdown(queue)), flatMap$2(output => pipe(runtime(), flatMap$2(runtime => pipe(register(make$3(k => pipe(fromPull$1(k), flatMap$2(take => offer$1(output, take)), asUnit, runPromiseExit(runtime)).then(exit => {\n  if (isFailure(exit)) {\n    if (!isInterrupted(exit.cause)) {\n      throw squash(exit.cause);\n    }\n  }\n}))), map$1(() => {\n  const loop = pipe(take$2(output), flatMap$2(done), match$1({\n    onFailure: maybeError => pipe(fromEffect$1(shutdown(output)), zipRight$2(match$2(maybeError, {\n      onNone: () => unit$1,\n      onSome: fail$1\n    }))),\n    onSuccess: chunk => pipe(write(chunk), flatMap$1(() => loop))\n  }), unwrap$1);\n  return loop;\n}))))), unwrapScoped$1, fromChannel);\n\n/** @internal */\nconst asyncInterrupt = (register, outputBuffer = 16) => pipe(acquireRelease$1(bounded(outputBuffer), queue => shutdown(queue)), flatMap$2(output => pipe(runtime(), flatMap$2(runtime => pipe(sync$1(() => register(make$3(k => pipe(fromPull$1(k), flatMap$2(take => offer$1(output, take)), asUnit, runPromiseExit(runtime)).then(exit => {\n  if (isFailure(exit)) {\n    if (!isInterrupted(exit.cause)) {\n      throw squash(exit.cause);\n    }\n  }\n})))), map$1(match({\n  onLeft: canceler => {\n    const loop = pipe(take$2(output), flatMap$2(done), match$1({\n      onFailure: maybeError => zipRight$2(fromEffect$1(shutdown(output)), match$2(maybeError, {\n        onNone: () => unit$1,\n        onSome: fail$1\n      })),\n      onSuccess: chunk => pipe(write(chunk), flatMap$1(() => loop))\n    }), unwrap$1);\n    return pipe(fromChannel(loop), ensuring(canceler));\n  },\n  onRight: stream => unwrap(pipe(shutdown(output), as$1(stream)))\n})))))), unwrapScoped);\n\n/** @internal */\nconst asyncOption = (register, outputBuffer = 16) => asyncInterrupt(emit => match$2(register(emit), {\n  onNone: () => left(unit$2),\n  onSome: right\n}), outputBuffer);\n\n/** @internal */\nconst asyncScoped = (register, outputBuffer = 16) => pipe(acquireRelease$1(bounded(outputBuffer), queue => shutdown(queue)), flatMap$2(output => pipe(runtime(), flatMap$2(runtime => pipe(register(make$3(k => pipe(fromPull$1(k), flatMap$2(take => offer$1(output, take)), asUnit, runPromiseExit(runtime)).then(exit => {\n  if (isFailure(exit)) {\n    if (!isInterrupted(exit.cause)) {\n      throw squash(exit.cause);\n    }\n  }\n}))), zipRight$1(make$2(false)), flatMap$2(ref => pipe(get(ref), map$1(isDone => isDone ? end$1() : pipe(take$2(output), flatMap$2(done), onError$1(() => pipe(set(ref, true), zipRight$1(shutdown(output)))))))))))), scoped, flatMap(repeatEffectChunkOption));\n\n/** @internal */\nconst branchAfter = /*#__PURE__*/dual(3, (self, n, f) => suspend(() => {\n  const buffering = acc => readWith({\n    onInput: input => {\n      const nextSize = acc.length + input.length;\n      if (nextSize >= n) {\n        const [b1, b2] = pipe(input, splitAt(n - acc.length));\n        return running(pipe(acc, appendAll(b1)), b2);\n      }\n      return buffering(pipe(acc, appendAll(input)));\n    },\n    onFailure: fail$1,\n    onDone: () => running(acc, empty$1())\n  });\n  const running = (prefix, leftover) => pipeTo(zipRight$2(write(leftover), identityChannel()), toChannel(f(prefix)));\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(buffering(empty$1()))));\n}));\n\n/** @internal */\nconst broadcast = /*#__PURE__*/dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map$1(tuple => tuple.map(queue => flattenTake(fromQueue(queue, {\n  shutdown: true\n}))))));\n\n/** @internal */\nconst broadcastDynamic = /*#__PURE__*/dual(2, (self, maximumLag) => pipe(self, broadcastedQueuesDynamic(maximumLag), map$1(effect => flattenTake(flatMap(scoped(effect), fromQueue)))));\n\n/** @internal */\nconst broadcastedQueues = /*#__PURE__*/dual(3, (self, n, maximumLag) => flatMap$2(bounded$1(maximumLag), pubsub => pipe(all(Array.from({\n  length: n\n}, () => subscribe(pubsub))), tap$1(() => forkScoped(runIntoPubSubScoped(self, pubsub))))));\n\n/** @internal */\nconst broadcastedQueuesDynamic = /*#__PURE__*/dual(2, (self, maximumLag) => map$1(toPubSub(self, maximumLag), subscribe));\n\n/** @internal */\nconst buffer = /*#__PURE__*/dual(2, (self, options) => {\n  if (options.capacity === \"unbounded\") {\n    return bufferUnbounded(self);\n  } else if (options.strategy === \"dropping\") {\n    return bufferDropping(self, options.capacity);\n  } else if (options.strategy === \"sliding\") {\n    return bufferSliding(self, options.capacity);\n  }\n  const queue = toQueueOfElements(self, options);\n  return new StreamImpl(unwrapScoped$1(map$1(queue, queue => {\n    const process = pipe(fromEffect$1(take$2(queue)), flatMap$1(match$3({\n      onFailure: cause => pipe(flipCauseOption(cause), match$2({\n        onNone: () => unit$1,\n        onSome: failCause$1\n      })),\n      onSuccess: value => flatMap$1(write(of(value)), () => process)\n    })));\n    return process;\n  })));\n});\n\n/** @internal */\nconst bufferChunks = /*#__PURE__*/dual(2, (self, options) => {\n  if (options.strategy === \"dropping\") {\n    return bufferChunksDropping(self, options.capacity);\n  } else if (options.strategy === \"sliding\") {\n    return bufferChunksSliding(self, options.capacity);\n  }\n  const queue = toQueue(self, options);\n  return new StreamImpl(unwrapScoped$1(map$1(queue, queue => {\n    const process = pipe(fromEffect$1(take$2(queue)), flatMap$1(match$4({\n      onEnd: () => unit$1,\n      onFailure: failCause$1,\n      onSuccess: value => pipe(write(value), flatMap$1(() => process))\n    })));\n    return process;\n  })));\n});\nconst bufferChunksDropping = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = acquireRelease$1(dropping(capacity), queue => shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(self)));\n});\nconst bufferChunksSliding = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = acquireRelease$1(sliding$1(capacity), queue => shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(self)));\n});\nconst bufferDropping = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = acquireRelease$1(dropping(capacity), queue => shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));\n});\nconst bufferSliding = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = acquireRelease$1(sliding$1(capacity), queue => shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(pipe(self, rechunk(1)))));\n});\nconst bufferUnbounded = self => {\n  const queue = toQueue(self, {\n    strategy: \"unbounded\"\n  });\n  return new StreamImpl(unwrapScoped$1(map$1(queue, queue => {\n    const process = pipe(fromEffect$1(take$2(queue)), flatMap$1(match$4({\n      onEnd: () => unit$1,\n      onFailure: failCause$1,\n      onSuccess: value => flatMap$1(write(value), () => process)\n    })));\n    return process;\n  })));\n};\n\n/** @internal */\nconst bufferSignal = (scoped, bufferChannel) => {\n  const producer = (queue, ref) => {\n    const terminate = take => pipe(get(ref), tap$1(_await), zipRight$1(make$4()), flatMap$2(deferred => pipe(offer$1(queue, [take, deferred]), zipRight$1(set(ref, deferred)), zipRight$1(_await(deferred)))), asUnit, fromEffect$1);\n    return readWithCause({\n      onInput: input => pipe(make$4(), flatMap$2(deferred => pipe(offer$1(queue, [chunk(input), deferred]), flatMap$2(added => pipe(set(ref, deferred), when$1(() => added))))), asUnit, fromEffect$1, flatMap$1(() => producer(queue, ref))),\n      onFailure: error => terminate(failCause$6(error)),\n      onDone: () => terminate(end$2)\n    });\n  };\n  const consumer = queue => {\n    const process = pipe(fromEffect$1(take$2(queue)), flatMap$1(([take, deferred]) => zipRight$2(fromEffect$1(succeed$2(deferred, void 0)), match$4(take, {\n      onEnd: () => unit$1,\n      onFailure: failCause$1,\n      onSuccess: value => pipe(write(value), flatMap$1(() => process))\n    }))));\n    return process;\n  };\n  return unwrapScoped$1(pipe(scoped, flatMap$2(queue => pipe(make$4(), tap$1(start => succeed$2(start, void 0)), flatMap$2(start => pipe(make$2(start), flatMap$2(ref => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped$1, forkScoped)), as$1(consumer(queue))))))));\n};\n\n/** @internal */\nconst catchAll = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => match(failureOrCause(cause), {\n  onLeft: f,\n  onRight: failCause\n})));\n\n/** @internal */\nconst catchAllCause = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), catchAllCause$1(cause => toChannel(f(cause))))));\n\n/** @internal */\nconst catchSome = /*#__PURE__*/dual(2, (self, pf) => pipe(self, catchAll(error => pipe(pf(error), getOrElse(() => fail(error))))));\n\n/** @internal */\nconst catchSomeCause = /*#__PURE__*/dual(2, (self, pf) => pipe(self, catchAllCause(cause => pipe(pf(cause), getOrElse(() => failCause(cause))))));\n\n/* @internal */\nconst catchTag = /*#__PURE__*/dual(3, (self, k, f) => catchAll(self, e => {\n  if (\"_tag\" in e && e[\"_tag\"] === k) {\n    return f(e);\n  }\n  return fail(e);\n}));\n\n/** @internal */\nconst catchTags = /*#__PURE__*/dual(2, (self, cases) => catchAll(self, e => {\n  const keys = Object.keys(cases);\n  if (\"_tag\" in e && keys.includes(e[\"_tag\"])) {\n    return cases[e[\"_tag\"]](e);\n  }\n  return fail(e);\n}));\n\n/** @internal */\nconst changes = self => pipe(self, changesWith((x, y) => equals(y)(x)));\n\n/** @internal */\nconst changesWith = /*#__PURE__*/dual(2, (self, f) => {\n  const writer = last => readWithCause({\n    onInput: input => {\n      const [newLast, newChunk] = reduce(input, [last, empty$1()], ([option, outputs], output) => {\n        if (isSome(option) && f(option.value, output)) {\n          return [some$1(output), outputs];\n        }\n        return [some$1(output), pipe(outputs, append(output))];\n      });\n      return flatMap$1(write(newChunk), () => writer(newLast));\n    },\n    onFailure: failCause$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(writer(none()))));\n});\n\n/** @internal */\nconst changesWithEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const writer = last => readWithCause({\n    onInput: input => pipe(input, reduce$1([last, empty$1()], ([option, outputs], output) => {\n      if (isSome(option)) {\n        return pipe(f(option.value, output), map$1(bool => bool ? [some$1(output), outputs] : [some$1(output), pipe(outputs, append(output))]));\n      }\n      return succeed$1([some$1(output), pipe(outputs, append(output))]);\n    }), fromEffect$1, flatMap$1(([newLast, newChunk]) => pipe(write(newChunk), flatMap$1(() => writer(newLast))))),\n    onFailure: failCause$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(writer(none()))));\n});\n\n/** @internal */\nconst chunks = self => pipe(self, mapChunks(of));\n\n/** @internal */\nconst chunksWith = /*#__PURE__*/dual(2, (self, f) => flattenChunks(f(chunks(self))));\nconst unsome = effect => catchAll$2(asSome(effect), o => o._tag === \"None\" ? succeedNone : fail$3(o.value));\n\n/** @internal */\nconst combine = /*#__PURE__*/dual(4, (self, that, s, f) => {\n  const producer = (handoff, latch) => pipe(fromEffect$1(take$1(latch)), zipRight$2(readWithCause({\n    onInput: input => flatMap$1(fromEffect$1(pipe(handoff, offer(succeed$4(input)))), () => producer(handoff, latch)),\n    onFailure: cause => fromEffect$1(offer(handoff, failCause$2(pipe(cause, map$3(some$1))))),\n    onDone: () => flatMap$1(fromEffect$1(offer(handoff, fail$2(none()))), () => producer(handoff, latch))\n  })));\n  return new StreamImpl(unwrapScoped$1(gen(function* ($) {\n    const left = yield* $(make$1());\n    const right = yield* $(make$1());\n    const latchL = yield* $(make$1());\n    const latchR = yield* $(make$1());\n    yield* $(toChannel(self), concatMap(writeChunk), pipeTo(producer(left, latchL)), runScoped$1, forkScoped);\n    yield* $(toChannel(that), concatMap(writeChunk), pipeTo(producer(right, latchR)), runScoped$1, forkScoped);\n    const pullLeft = pipe(latchL, offer(void 0),\n    // TODO: remove\n    zipRight$1(pipe(take$1(left), flatMap$2(exit => suspend$1(() => exit)))));\n    const pullRight = pipe(latchR, offer(void 0),\n    // TODO: remove\n    zipRight$1(pipe(take$1(right), flatMap$2(exit => suspend$1(() => exit)))));\n    return toChannel(unfoldEffect(s, s => flatMap$2(f(s, pullLeft, pullRight), unsome)));\n  })));\n});\n\n/** @internal */\nconst combineChunks = /*#__PURE__*/dual(4, (self, that, s, f) => {\n  const producer = (handoff, latch) => zipRight$2(fromEffect$1(take$1(latch)), readWithCause({\n    onInput: input => flatMap$1(fromEffect$1(pipe(handoff, offer(chunk(input)))), () => producer(handoff, latch)),\n    onFailure: cause => fromEffect$1(offer(handoff, failCause$6(cause))),\n    onDone: () => fromEffect$1(offer(handoff, end$2))\n  }));\n  return new StreamImpl(pipe(all([make$1(), make$1(), make$1(), make$1()]), tap$1(([left, _, latchL]) => pipe(toChannel(self), pipeTo(producer(left, latchL)), runScoped$1, forkScoped)), tap$1(([_, right, __, latchR]) => pipe(toChannel(that), pipeTo(producer(right, latchR)), runScoped$1, forkScoped)), map$1(([left, right, latchL, latchR]) => {\n    const pullLeft = pipe(latchL, offer(void 0), zipRight$1(pipe(take$1(left), flatMap$2(done))));\n    const pullRight = pipe(latchR, offer(void 0), zipRight$1(pipe(take$1(right), flatMap$2(done))));\n    return toChannel(unfoldChunkEffect(s, s => flatMap$2(f(s, pullLeft, pullRight), unsome)));\n  }), unwrapScoped$1));\n});\n\n/** @internal */\nconst concat = /*#__PURE__*/dual(2, (self, that) => new StreamImpl(pipe(toChannel(self), zipRight$2(toChannel(that)))));\n\n/** @internal */\nconst concatAll = streams => suspend(() => pipe(streams, reduce(empty, (x, y) => concat(y)(x))));\n\n/** @internal */\nconst cross = /*#__PURE__*/dual(2, (self, that) => pipe(self, crossWith(that, (a, a2) => [a, a2])));\n\n/** @internal */\nconst crossLeft = /*#__PURE__*/dual(2, (self, that) => pipe(self, crossWith(that, (a, _) => a)));\n\n/** @internal */\nconst crossRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));\n\n/** @internal */\nconst crossWith = /*#__PURE__*/dual(3, (self, that, f) => pipe(self, flatMap(a => pipe(that, map(b => f(a, b))))));\n\n/** @internal */\nconst debounce = /*#__PURE__*/dual(2, (self, duration) => pipe(make$5(), flatMap$2(input => transplant(grafter => pipe(make$1(), map$1(handoff => {\n  const enqueue = last => pipe(sleep(duration), as$1(last), fork, grafter, map$1(fiber => consumer(previous(fiber))));\n  const producer = readWithCause({\n    onInput: input => match$2(last$1(input), {\n      onNone: () => producer,\n      onSome: last => flatMap$1(fromEffect$1(offer(handoff, emit(of(last)))), () => producer)\n    }),\n    onFailure: cause => fromEffect$1(offer(handoff, halt(cause))),\n    onDone: () => fromEffect$1(offer(handoff, end(UpstreamEnd)))\n  });\n  const consumer = state => {\n    switch (state._tag) {\n      case OP_NOT_STARTED:\n        {\n          return pipe(take$1(handoff), map$1(signal => {\n            switch (signal._tag) {\n              case OP_EMIT:\n                {\n                  return unwrap$1(enqueue(signal.elements));\n                }\n              case OP_HALT:\n                {\n                  return failCause$1(signal.cause);\n                }\n              case OP_END:\n                {\n                  return unit$1;\n                }\n            }\n          }), unwrap$1);\n        }\n      case OP_PREVIOUS:\n        {\n          return unwrap$1(raceWith(join(state.fiber), take$1(handoff), {\n            onSelfDone: (leftExit, current$1) => match$3(leftExit, {\n              onFailure: cause => pipe(interrupt(current$1), as$1(failCause$1(cause))),\n              onSuccess: chunk => succeed$1(pipe(write(chunk), flatMap$1(() => consumer(current(current$1)))))\n            }),\n            onOtherDone: (rightExit, previous) => match$3(rightExit, {\n              onFailure: cause => pipe(interrupt(previous), as$1(failCause$1(cause))),\n              onSuccess: signal => {\n                switch (signal._tag) {\n                  case OP_EMIT:\n                    {\n                      return pipe(interrupt(previous), zipRight$1(enqueue(signal.elements)));\n                    }\n                  case OP_HALT:\n                    {\n                      return pipe(interrupt(previous), as$1(failCause$1(signal.cause)));\n                    }\n                  case OP_END:\n                    {\n                      return pipe(join(previous), map$1(chunk => pipe(write(chunk), zipRight$2(unit$1))));\n                    }\n                }\n              }\n            })\n          }));\n        }\n      case OP_CURRENT:\n        {\n          return pipe(join(state.fiber), map$1(signal => {\n            switch (signal._tag) {\n              case OP_EMIT:\n                {\n                  return unwrap$1(enqueue(signal.elements));\n                }\n              case OP_HALT:\n                {\n                  return failCause$1(signal.cause);\n                }\n              case OP_END:\n                {\n                  return unit$1;\n                }\n            }\n          }), unwrap$1);\n        }\n    }\n  };\n  const debounceChannel = pipe(fromInput$1(input), pipeTo(producer), run$1, forkScoped, as$1(pipe(consumer(notStarted), embedInput(input))), unwrapScoped$1);\n  return new StreamImpl(pipe(toChannel(self), pipeTo(debounceChannel)));\n})))), unwrap));\n\n/** @internal */\nconst die = defect => fromEffect(die$1(defect));\n\n/** @internal */\nconst dieSync = evaluate => fromEffect(dieSync$1(evaluate));\n\n/** @internal */\nconst dieMessage = message => fromEffect(dieMessage$1(message));\n\n/** @internal */\nconst distributedWith = /*#__PURE__*/dual(2, (self, options) => pipe(make$4(), flatMap$2(deferred => pipe(self, distributedWithDynamic({\n  maximumLag: options.maximumLag,\n  decide: a => flatMap$2(_await(deferred), f => f(a))\n}), flatMap$2(next => pipe(all(map$2(range$1(0, options.size - 1), id => map$1(next, ([key, queue]) => [[key, id], queue]))), map$1(unsafeFromArray), flatMap$2(entries => {\n  const [mappings, queues] = reduceRight(entries, [new Map(), empty$1()], ([mappings, queues], [mapping, queue]) => [mappings.set(mapping[0], mapping[1]), pipe(queues, prepend$1(queue))]);\n  return pipe(succeed$2(deferred, a => map$1(options.decide(a), f => key => pipe(f(mappings.get(key))))), as$1(Array.from(queues)));\n})))))));\n\n/** @internal */\nconst distributedWithDynamicId = {\n  ref: 0\n};\nconst newDistributedWithDynamicId = () => {\n  const current = distributedWithDynamicId.ref;\n  distributedWithDynamicId.ref = current + 1;\n  return current;\n};\n\n/** @internal */\nconst distributedWithDynamic = /*#__PURE__*/dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => unit$2));\nconst distributedWithDynamicCallback = /*#__PURE__*/dual(4, (self, maximumLag, decide, done) => pipe(acquireRelease$1(make$2(new Map()), (ref, _) => pipe(get(ref), flatMap$2(queues => pipe(queues.values(), forEach(shutdown))))), flatMap$2(queuesRef => gen(function* ($) {\n  const offer = a => pipe(decide(a), flatMap$2(shouldProcess => pipe(get(queuesRef), flatMap$2(queues => pipe(queues.entries(), reduce$1(empty$1(), (acc, [id, queue]) => {\n    if (shouldProcess(id)) {\n      return pipe(offer$1(queue, succeed$4(a)), matchCauseEffect({\n        onFailure: cause =>\n        // Ignore all downstream queues that were shut\n        // down and remove them later\n        isInterrupted(cause) ? succeed$1(pipe(acc, prepend$1(id))) : failCause$4(cause),\n        onSuccess: () => succeed$1(acc)\n      }));\n    }\n    return succeed$1(acc);\n  }), flatMap$2(ids => {\n    if (isNonEmpty(ids)) {\n      return pipe(update(queuesRef, map => {\n        for (const id of ids) {\n          map.delete(id);\n        }\n        return map;\n      }));\n    }\n    return unit$2;\n  }))))), asUnit);\n  const queuesLock = yield* $(makeSemaphore(1));\n  const newQueue = yield* $(make$2(pipe(bounded(maximumLag), flatMap$2(queue => {\n    const id = newDistributedWithDynamicId();\n    return pipe(update(queuesRef, map => map.set(id, queue)), as$1([id, queue]));\n  }))));\n  const finalize = endTake =>\n  // Make sure that no queues are currently being added\n  queuesLock.withPermits(1)(pipe(set(newQueue, pipe(\n  // All newly created queues should end immediately\n  bounded(1), tap$1(queue => offer$1(queue, endTake)), flatMap$2(queue => {\n    const id = newDistributedWithDynamicId();\n    return pipe(update(queuesRef, map => map.set(id, queue)), as$1([id, queue]));\n  }))), zipRight$1(pipe(get(queuesRef), flatMap$2(map => pipe(fromIterable$1(map.values()), forEach(queue => pipe(offer$1(queue, endTake), catchSomeCause$1(cause => isInterrupted(cause) ? some$1(unit$2) : none()))))))), zipRight$1(done(endTake)), asUnit));\n  yield* $(self, runForEachScoped(offer), matchCauseEffect({\n    onFailure: cause => finalize(failCause$2(pipe(cause, map$3(some$1)))),\n    onSuccess: () => finalize(fail$2(none()))\n  }), forkScoped);\n  return queuesLock.withPermits(1)(flatten$1(get(newQueue)));\n}))));\n\n/** @internal */\nconst drain = self => new StreamImpl(drain$1(toChannel(self)));\n\n/** @internal */\nconst drainFork = /*#__PURE__*/dual(2, (self, that) => pipe(fromEffect(make$4()), flatMap(backgroundDied => pipe(scoped(pipe(that, runForEachScoped(() => unit$2), catchAllCause$2(cause => failCause$3(backgroundDied, cause)), forkScoped)), crossRight(pipe(self, interruptWhenDeferred(backgroundDied)))))));\n\n/** @internal */\nconst drop = /*#__PURE__*/dual(2, (self, n) => {\n  const loop = r => readWith({\n    onInput: input => {\n      const dropped = pipe(input, drop$1(r));\n      const leftover = Math.max(0, r - input.length);\n      const more = isEmpty(input) || leftover > 0;\n      if (more) {\n        return loop(leftover);\n      }\n      return pipe(write(dropped), zipRight$2(identityChannel()));\n    },\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(loop(n))));\n});\n\n/** @internal */\nconst dropRight = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return identityStream();\n  }\n  return suspend(() => {\n    const queue = new RingBuffer(n);\n    const reader = readWith({\n      onInput: input => {\n        const outputs = pipe(input, filterMap$1(elem => {\n          const head = queue.head();\n          queue.put(elem);\n          return head;\n        }));\n        return pipe(write(outputs), flatMap$1(() => reader));\n      },\n      onFailure: fail$1,\n      onDone: () => unit$1\n    });\n    return new StreamImpl(pipe(toChannel(self), pipeToOrFail(reader)));\n  });\n});\n\n/** @internal */\nconst dropUntil = /*#__PURE__*/dual(2, (self, predicate) => drop(dropWhile(self, a => !predicate(a)), 1));\n\n/** @internal */\nconst dropUntilEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => pipe(dropUntil$1(input, predicate), map$1(unsafeFromArray), map$1(leftover => {\n      const more = isEmpty(leftover);\n      if (more) {\n        return suspend$2(() => loop);\n      }\n      return pipe(write(leftover), zipRight$2(identityChannel()));\n    }), unwrap$1),\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(loop)));\n});\n\n/** @internal */\nconst dropWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => {\n      const output = dropWhile$1(input, predicate);\n      if (isEmpty(output)) {\n        return suspend$2(() => loop);\n      }\n      return zipRight$2(write(output), identityChannel());\n    },\n    onFailure: fail$1,\n    onDone: succeedNow\n  });\n  return new StreamImpl(pipeToOrFail(toChannel(self), loop));\n});\n\n/** @internal */\nconst dropWhileEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => pipe(dropWhile$2(input, predicate), map$1(unsafeFromArray), map$1(leftover => {\n      const more = isEmpty(leftover);\n      if (more) {\n        return suspend$2(() => loop);\n      }\n      return zipRight$2(write(leftover), identityChannel());\n    }), unwrap$1),\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipeToOrFail(toChannel(self), loop));\n});\n\n/** @internal */\nconst either = self => pipe(self, map(right), catchAll(error => make(left(error))));\n\n/** @internal */\nconst empty = /*#__PURE__*/new StreamImpl( /*#__PURE__*/write( /*#__PURE__*/empty$1()));\n\n/** @internal */\nconst ensuring = /*#__PURE__*/dual(2, (self, finalizer) => new StreamImpl(pipe(toChannel(self), ensuring$1(finalizer))));\n\n/** @internal */\nconst ensuringWith = /*#__PURE__*/dual(2, (self, finalizer) => new StreamImpl(ensuringWith$1(toChannel(self), finalizer)));\n\n/** @internal */\nconst context = () => fromEffect(context$1());\n\n/** @internal */\nconst contextWith = f => pipe(context(), map(f));\n\n/** @internal */\nconst contextWithEffect = f => pipe(context(), mapEffectSequential(f));\n\n/** @internal */\nconst contextWithStream = f => pipe(context(), flatMap(f));\n\n/** @internal */\nconst execute = effect => drain(fromEffect(effect));\n\n/** @internal */\nconst fail = error => fromEffectOption(fail$3(some$1(error)));\n\n/** @internal */\nconst failSync = evaluate => fromEffectOption(failSync$1(() => some$1(evaluate())));\n\n/** @internal */\nconst failCause = cause => fromEffect(failCause$4(cause));\n\n/** @internal */\nconst failCauseSync = evaluate => fromEffect(failCauseSync$1(evaluate));\n\n/** @internal */\nconst filter = /*#__PURE__*/dual(2, (self, predicate) => mapChunks(self, filter$1(predicate)));\n\n/** @internal */\nconst filterEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return readWithCause({\n        onInput: input => loop(input[Symbol.iterator]()),\n        onFailure: failCause$1,\n        onDone: succeed$3\n      });\n    } else {\n      return pipe(f(next.value), map$1(bool => bool ? pipe(write(of(next.value)), flatMap$1(() => loop(iterator))) : loop(iterator)), unwrap$1);\n    }\n  };\n  return new StreamImpl(suspend$2(() => pipe(toChannel(self), pipeTo(loop(empty$1()[Symbol.iterator]())))));\n});\n\n/** @internal */\nconst filterMap = /*#__PURE__*/dual(2, (self, pf) => mapChunks(self, filterMap$1(pf)));\n\n/** @internal */\nconst filterMapEffect = /*#__PURE__*/dual(2, (self, pf) => suspend(() => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return readWithCause({\n        onInput: input => loop(input[Symbol.iterator]()),\n        onFailure: failCause$1,\n        onDone: succeed$3\n      });\n    } else {\n      return pipe(pf(next.value), match$2({\n        onNone: () => sync$1(() => loop(iterator)),\n        onSome: map$1(a2 => flatMap$1(write(of(a2)), () => loop(iterator)))\n      }), unwrap$1);\n    }\n  };\n  return new StreamImpl(pipe(toChannel(self), pipeTo(loop(empty$1()[Symbol.iterator]()))));\n}));\n\n/** @internal */\nconst filterMapWhile = /*#__PURE__*/dual(2, (self, pf) => {\n  const loop = readWith({\n    onInput: input => {\n      const mapped = filterMapWhile$1(input, pf);\n      if (mapped.length === input.length) {\n        return pipe(write(mapped), flatMap$1(() => loop));\n      }\n      return write(mapped);\n    },\n    onFailure: fail$1,\n    onDone: succeed$3\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(loop)));\n});\n\n/** @internal */\nconst filterMapWhileEffect = /*#__PURE__*/dual(2, (self, pf) => suspend(() => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return readWithCause({\n        onInput: input => loop(input[Symbol.iterator]()),\n        onFailure: failCause$1,\n        onDone: succeed$3\n      });\n    } else {\n      return unwrap$1(match$2(pf(next.value), {\n        onNone: () => succeed$1(unit$1),\n        onSome: map$1(a2 => flatMap$1(write(of(a2)), () => loop(iterator)))\n      }));\n    }\n  };\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(loop(empty$1()[Symbol.iterator]()))));\n}));\n\n/** @internal */\nconst finalizer = finalizer => acquireRelease(unit$2, () => finalizer);\n\n/** @internal */\nconst find = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => match$2(findFirst(input, predicate), {\n      onNone: () => loop,\n      onSome: n => write(of(n))\n    }),\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(loop)));\n});\n\n/** @internal */\nconst findEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => pipe(findFirst$1(input, predicate), map$1(match$2({\n      onNone: () => loop,\n      onSome: n => write(of(n))\n    })), unwrap$1),\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(loop)));\n});\n\n/** @internal */\nconst flatMap = /*#__PURE__*/dual(args => typeof args[0] !== \"function\", (self, f, options) => {\n  const bufferSize = options?.bufferSize ?? 16;\n  if (options?.switch) {\n    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), n => flatMapParSwitchBuffer(self, n, bufferSize, f));\n  }\n  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel(self), as => pipe(as, map$2(a => toChannel(f(a))), reduce(unit$1, (left, right) => pipe(left, zipRight$2(right)))))), n => new StreamImpl(pipe(toChannel(self), concatMap(writeChunk), mergeMap(out => toChannel(f(out)), {\n    concurrency: n,\n    bufferSize\n  }))));\n});\n\n/** @internal */\nconst matchConcurrency = (concurrency, sequential, bounded) => {\n  switch (concurrency) {\n    case undefined:\n      return sequential();\n    case \"unbounded\":\n      return bounded(Number.POSITIVE_INFINITY);\n    default:\n      return concurrency > 1 ? bounded(concurrency) : sequential();\n  }\n};\nconst flatMapParSwitchBuffer = /*#__PURE__*/dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel(self), concatMap(writeChunk), mergeMap(out => toChannel(f(out)), {\n  concurrency: n,\n  mergeStrategy: BufferSliding(),\n  bufferSize\n}))));\n\n/** @internal */\nconst flatten = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => flatMap(self, identity, options));\n\n/** @internal */\nconst flattenChunks = self => {\n  const flatten = readWithCause({\n    onInput: chunks => flatMap$1(writeChunk(chunks), () => flatten),\n    onFailure: failCause$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(flatten)));\n};\n\n/** @internal */\nconst flattenEffect = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => options?.unordered ? flatMap(self, a => fromEffect(a), {\n  concurrency: options.concurrency\n}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), n => new StreamImpl(pipe(toChannel(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of)))));\n\n/** @internal */\nconst flattenExitOption = self => {\n  const processChunk = (chunk, cont) => {\n    const [toEmit, rest] = pipe(chunk, splitWhere(exit => !isSuccess(exit)));\n    const next = pipe(head$1(rest), match$2({\n      onNone: () => cont,\n      onSome: match$3({\n        onFailure: cause => match$2(flipCauseOption(cause), {\n          onNone: () => unit$1,\n          onSome: failCause$1\n        }),\n        onSuccess: () => unit$1\n      })\n    }));\n    return pipe(write(pipe(toEmit, filterMap$1(exit => isSuccess(exit) ? some$1(exit.value) : none()))), flatMap$1(() => next));\n  };\n  const process = readWithCause({\n    onInput: chunk => processChunk(chunk, process),\n    onFailure: cause => failCause$1(cause),\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(process)));\n};\n\n/** @internal */\nconst flattenIterables = self => pipe(self, map(fromIterable$1), flattenChunks);\n\n/** @internal */\nconst flattenTake = self => flattenChunks(flattenExitOption(pipe(self, map(take => take.exit))));\n\n/** @internal */\nconst forever = self => new StreamImpl(repeated(toChannel(self)));\n\n/** @internal */\nconst fromAsyncIterable = (iterable, onError) => pipe(acquireRelease$1(sync$1(() => iterable[Symbol.asyncIterator]()), iterator => iterator.return ? promise(async () => iterator.return()) : unit$2), map$1(iterator => repeatEffectOption(pipe(tryPromise({\n  try: async () => iterator.next(),\n  catch: reason => some$1(onError(reason))\n}), flatMap$2(result => result.done ? fail$3(none()) : succeed$1(result.value))))), unwrapScoped);\n\n/** @internal */\nconst fromChannel = channel => new StreamImpl(channel);\n\n/** @internal */\nconst toChannel = stream => {\n  if (\"channel\" in stream) {\n    return stream.channel;\n  } else if (isEffect(stream)) {\n    return toChannel(fromEffect(stream));\n  } else {\n    throw new TypeError(`Expected a Stream.`);\n  }\n};\n\n/** @internal */\nconst fromChunk = chunk => new StreamImpl(isEmpty(chunk) ? unit$1 : write(chunk));\n\n/** @internal */\nconst fromChunkPubSub = (pubsub, options) => {\n  if (options?.scoped) {\n    const effect = map$1(subscribe(pubsub), fromChunkQueue);\n    return options.shutdown ? map$1(effect, ensuring(shutdown$1(pubsub))) : effect;\n  }\n  const stream = flatMap(scoped(subscribe(pubsub)), fromChunkQueue);\n  return options?.shutdown ? ensuring(stream, shutdown$1(pubsub)) : stream;\n};\n\n/** @internal */\nconst fromChunkQueue = (queue, options) => pipe(take$2(queue), catchAllCause$2(cause => pipe(isShutdown(queue), flatMap$2(isShutdown => isShutdown && isInterrupted(cause) ? end$1() : failCause$5(cause)))), repeatEffectChunkOption, options?.shutdown ? ensuring(shutdown(queue)) : identity);\n\n/** @internal */\nconst fromChunks = (...chunks) => pipe(fromIterable(chunks), flatMap(fromChunk));\n\n/** @internal */\nconst fromEffect = effect => pipe(effect, mapError$1(some$1), fromEffectOption);\n\n/** @internal */\nconst fromEffectOption = effect => new StreamImpl(unwrap$1(match$1(effect, {\n  onFailure: match$2({\n    onNone: () => unit$1,\n    onSome: fail$1\n  }),\n  onSuccess: a => write(of(a))\n})));\n\n/** @internal */\nconst fromPubSub = (pubsub, options) => {\n  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;\n  if (options?.scoped) {\n    const effect = map$1(subscribe(pubsub), queue => fromQueue(queue, {\n      maxChunkSize,\n      shutdown: true\n    }));\n    return options.shutdown ? map$1(effect, ensuring(shutdown$1(pubsub))) : effect;\n  }\n  const stream = flatMap(scoped(subscribe(pubsub)), queue => fromQueue(queue, {\n    maxChunkSize\n  }));\n  return options?.shutdown ? ensuring(stream, shutdown$1(pubsub)) : stream;\n};\n\n/** @internal */\nconst fromIterable = iterable => suspend(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));\n\n/** @internal */\nconst fromIterableEffect = effect => pipe(effect, map$1(fromIterable), unwrap);\n\n/** @internal */\nconst fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {\n  return pipe(sync$1(() => {\n    let builder = [];\n    const loop = iterator => pipe(sync$1(() => {\n      let next = iterator.next();\n      if (maxChunkSize === 1) {\n        if (next.done) {\n          return unit$1;\n        }\n        return pipe(write(of(next.value)), flatMap$1(() => loop(iterator)));\n      }\n      builder = [];\n      let count = 0;\n      while (count < maxChunkSize && !next.done) {\n        builder.push(next.value);\n        next = iterator.next();\n        count = count + 1;\n      }\n      if (count > 0) {\n        return pipe(write(unsafeFromArray(builder)), flatMap$1(() => loop(iterator)));\n      }\n      return unit$1;\n    }), unwrap$1);\n    return new StreamImpl(loop(iterator));\n  }), unwrap);\n};\n\n/** @internal */\nconst fromPull = effect => pipe(effect, map$1(repeatEffectChunkOption), unwrapScoped);\n\n/** @internal */\nconst fromQueue = (queue, options) => pipe(takeBetween(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause$2(cause => pipe(isShutdown(queue), flatMap$2(isShutdown => isShutdown && isInterrupted(cause) ? end$1() : failCause$5(cause)))), repeatEffectChunkOption, options?.shutdown ? ensuring(shutdown(queue)) : identity);\n\n/** @internal */\nconst fromSchedule = schedule => pipe(driver(schedule), map$1(driver => repeatEffectOption(driver.next(void 0))), unwrap);\n\n/** @internal */\nconst fromReadableStream = (evaluate, onError) => unwrapScoped(map$1(acquireRelease$1(sync$1(() => evaluate().getReader()), reader => promise(() => reader.cancel())), reader => repeatEffectOption(flatMap$2(tryPromise({\n  try: () => reader.read(),\n  catch: reason => some$1(onError(reason))\n}), ({\n  done,\n  value\n}) => done ? fail$3(none()) : succeed$1(value)))));\n\n/** @internal */\nconst fromReadableStreamByob = (evaluate, onError, allocSize = 4096) => unwrapScoped(map$1(acquireRelease$1(sync$1(() => evaluate().getReader({\n  mode: \"byob\"\n})), reader => promise(() => reader.cancel())), reader => catchAll(forever(readChunkStreamByobReader(reader, onError, allocSize)), error => typeof error === \"object\" && error !== null && \"_tag\" in error && error._tag === \"EOF\" ? empty : fail(error))));\nconst readChunkStreamByobReader = (reader, onError, size) => {\n  const buffer = new ArrayBuffer(size);\n  return paginateEffect(0, offset => flatMap$2(tryPromise({\n    try: () => reader.read(new Uint8Array(buffer, offset, buffer.byteLength - offset)),\n    catch: reason => onError(reason)\n  }), ({\n    done,\n    value\n  }) => {\n    if (done) {\n      return fail$3({\n        _tag: \"EOF\"\n      });\n    }\n    const newOffset = offset + value.byteLength;\n    return succeed$1([value, newOffset >= buffer.byteLength ? none() : some$1(newOffset)]);\n  }));\n};\n\n/** @internal */\nconst groupAdjacentBy = /*#__PURE__*/dual(2, (self, f) => {\n  const groupAdjacentByChunk = (state, chunk) => {\n    if (isEmpty(chunk)) {\n      return [state, empty$1()];\n    }\n    const builder = [];\n    let from = 0;\n    let until = 0;\n    let key = undefined;\n    let previousChunk = empty$1();\n    switch (state._tag) {\n      case \"Some\":\n        {\n          const tuple = state.value;\n          key = tuple[0];\n          let loop = true;\n          while (loop && until < chunk.length) {\n            const input = unsafeGet$1(chunk, until);\n            const updatedKey = f(input);\n            if (!equals(key, updatedKey)) {\n              const previousChunk = tuple[1];\n              const additionalChunk = unsafeFromArray(Array.from(chunk).slice(from, until));\n              const group = appendAllNonEmpty(previousChunk, additionalChunk);\n              builder.push([key, group]);\n              key = updatedKey;\n              from = until;\n              loop = false;\n            }\n            until = until + 1;\n          }\n          if (loop) {\n            previousChunk = tuple[1];\n          }\n          break;\n        }\n      case \"None\":\n        {\n          key = f(unsafeGet$1(chunk, until));\n          until = until + 1;\n          break;\n        }\n    }\n    while (until < chunk.length) {\n      const input = unsafeGet$1(chunk, until);\n      const updatedKey = f(input);\n      if (!equals(key, updatedKey)) {\n        builder.push([key, unsafeFromArray(Array.from(chunk).slice(from, until))]);\n        key = updatedKey;\n        from = until;\n      }\n      until = until + 1;\n    }\n    const nonEmptyChunk = appendAll(previousChunk, unsafeFromArray(Array.from(chunk).slice(from, until)));\n    const output = unsafeFromArray(builder);\n    return [some$1([key, nonEmptyChunk]), output];\n  };\n  const groupAdjacent = state => readWithCause({\n    onInput: input => {\n      const [updatedState, output] = groupAdjacentByChunk(state, input);\n      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap$1(write(output), () => groupAdjacent(updatedState));\n    },\n    onFailure: cause => match$2(state, {\n      onNone: () => failCause$1(cause),\n      onSome: output => flatMap$1(write(of(output)), () => failCause$1(cause))\n    }),\n    onDone: done => match$2(state, {\n      onNone: () => succeedNow(done),\n      onSome: output => flatMap$1(write(of(output)), () => succeedNow(done))\n    })\n  });\n  return new StreamImpl(pipeToOrFail(toChannel(self), groupAdjacent(none())));\n});\n\n/** @internal */\nconst grouped = /*#__PURE__*/dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));\n\n/** @internal */\nconst groupedWithin = /*#__PURE__*/dual(3, (self, chunkSize, duration) => aggregateWithin(self, collectAllN(chunkSize), spaced(duration)));\n\n/** @internal */\nconst haltWhen = /*#__PURE__*/dual(2, (self, effect) => {\n  const writer = fiber => pipe(poll$1(fiber), map$1(match$2({\n    onNone: () => readWith({\n      onInput: input => flatMap$1(write(input), () => writer(fiber)),\n      onFailure: fail$1,\n      onDone: () => unit$1\n    }),\n    onSome: match$3({\n      onFailure: failCause$1,\n      onSuccess: () => unit$1\n    })\n  })), unwrap$1);\n  return new StreamImpl(pipe(forkScoped(effect), map$1(fiber => pipe(toChannel(self), pipeTo(writer(fiber)))), unwrapScoped$1));\n});\n\n/** @internal */\nconst haltAfter = /*#__PURE__*/dual(2, (self, duration) => pipe(self, haltWhen(sleep(duration))));\n\n/** @internal */\nconst haltWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => {\n  const writer = pipe(poll(deferred), map$1(match$2({\n    onNone: () => readWith({\n      onInput: input => pipe(write(input), flatMap$1(() => writer)),\n      onFailure: fail$1,\n      onDone: () => unit$1\n    }),\n    onSome: effect => unwrap$1(match$1(effect, {\n      onFailure: fail$1,\n      onSuccess: () => unit$1\n    }))\n  })), unwrap$1);\n  return new StreamImpl(pipe(toChannel(self), pipeTo(writer)));\n});\n\n/** @internal */\nconst identityStream = () => new StreamImpl(identityChannel());\n\n/** @internal */\nconst interleave = /*#__PURE__*/dual(2, (self, that) => pipe(self, interleaveWith(that, forever(make(true, false)))));\n\n/** @internal */\nconst interleaveWith = /*#__PURE__*/dual(3, (self, that, decider) => {\n  const producer = handoff => readWithCause({\n    onInput: value => flatMap$1(fromEffect$1(offer(handoff, of$1(value))), () => producer(handoff)),\n    onFailure: cause => fromEffect$1(offer(handoff, failCause$6(cause))),\n    onDone: () => fromEffect$1(offer(handoff, end$2))\n  });\n  return new StreamImpl(unwrapScoped$1(pipe(make$1(), zip$1(make$1()), tap$1(([left]) => pipe(toChannel(self), concatMap(writeChunk), pipeTo(producer(left)), runScoped$1, forkScoped)), tap$1(([_, right]) => pipe(toChannel(that), concatMap(writeChunk), pipeTo(producer(right)), runScoped$1, forkScoped)), map$1(([left, right]) => {\n    const process = (leftDone, rightDone) => readWithCause({\n      onInput: bool => {\n        if (bool && !leftDone) {\n          return pipe(fromEffect$1(take$1(left)), flatMap$1(match$4({\n            onEnd: () => rightDone ? unit$1 : process(true, rightDone),\n            onFailure: failCause$1,\n            onSuccess: chunk => pipe(write(chunk), flatMap$1(() => process(leftDone, rightDone)))\n          })));\n        }\n        if (!bool && !rightDone) {\n          return pipe(fromEffect$1(take$1(right)), flatMap$1(match$4({\n            onEnd: () => leftDone ? unit$1 : process(leftDone, true),\n            onFailure: failCause$1,\n            onSuccess: chunk => pipe(write(chunk), flatMap$1(() => process(leftDone, rightDone)))\n          })));\n        }\n        return process(leftDone, rightDone);\n      },\n      onFailure: failCause$1,\n      onDone: () => unit$1\n    });\n    return pipe(toChannel(decider), concatMap(writeChunk), pipeTo(process(false, false)));\n  }))));\n});\n\n/** @internal */\nconst intersperse = /*#__PURE__*/dual(2, (self, element) => new StreamImpl(pipe(toChannel(self), pipeToOrFail(suspend$2(() => {\n  const writer = isFirst => readWithCause({\n    onInput: chunk => {\n      const builder = [];\n      let flagResult = isFirst;\n      for (const output of chunk) {\n        if (flagResult) {\n          flagResult = false;\n          builder.push(output);\n        } else {\n          builder.push(element);\n          builder.push(output);\n        }\n      }\n      return pipe(write(unsafeFromArray(builder)), flatMap$1(() => writer(flagResult)));\n    },\n    onFailure: failCause$1,\n    onDone: () => unit$1\n  });\n  return writer(true);\n})))));\n\n/** @internal */\nconst intersperseAffixes = /*#__PURE__*/dual(2, (self, {\n  end,\n  middle,\n  start\n}) => pipe(make(start), concat(pipe(self, intersperse(middle))), concat(make(end))));\n\n/** @internal */\nconst interruptAfter = /*#__PURE__*/dual(2, (self, duration) => pipe(self, interruptWhen(sleep(duration))));\n\n/** @internal */\nconst interruptWhen = /*#__PURE__*/dual(2, (self, effect) => new StreamImpl(pipe(toChannel(self), interruptWhen$1(effect))));\n\n/** @internal */\nconst interruptWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => new StreamImpl(pipe(toChannel(self), interruptWhenDeferred$1(deferred))));\n\n/** @internal */\nconst iterate = (value, next) => unfold(value, a => some$1([a, next(a)]));\n\n/** @internal */\nconst make = (...as) => fromIterable(as);\n\n/** @internal */\nconst map = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), mapOut(map$2(f)))));\n\n/** @internal */\nconst mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  const accumulator = s => readWith({\n    onInput: input => {\n      const [nextS, chunk] = mapAccum$1(input, s, f);\n      return flatMap$1(write(chunk), () => accumulator(nextS));\n    },\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(accumulator(s))));\n});\n\n/** @internal */\nconst mapAccumEffect = /*#__PURE__*/dual(3, (self, s, f) => suspend(() => {\n  const accumulator = s => readWith({\n    onInput: input => pipe(suspend$1(() => {\n      const outputs = [];\n      const emit = output => sync$1(() => {\n        outputs.push(output);\n      });\n      return pipe(input, reduce$1(s, (s, a) => pipe(f(s, a), flatMap$2(([s, a]) => pipe(emit(a), as$1(s))))), match$1({\n        onFailure: error => {\n          if (outputs.length !== 0) {\n            return zipRight$2(write(unsafeFromArray(outputs)), fail$1(error));\n          }\n          return fail$1(error);\n        },\n        onSuccess: s => flatMap$1(write(unsafeFromArray(outputs)), () => accumulator(s))\n      }));\n    }), unwrap$1),\n    onFailure: fail$1,\n    onDone: () => unit$1\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(accumulator(s))));\n}));\n\n/** @internal */\nconst mapBoth = /*#__PURE__*/dual(2, (self, options) => pipe(self, mapError(options.onFailure), map(options.onSuccess)));\n\n/** @internal */\nconst mapChunks = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), mapOut(f))));\n\n/** @internal */\nconst mapChunksEffect = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), mapOutEffect(f))));\n\n/** @internal */\nconst mapConcat = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapConcatChunk(a => fromIterable$1(f(a)))));\n\n/** @internal */\nconst mapConcatChunk = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapChunks(flatMap$3(f))));\n\n/** @internal */\nconst mapConcatChunkEffect = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));\n\n/** @internal */\nconst mapConcatEffect = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapEffectSequential(a => pipe(f(a), map$1(fromIterable$1))), mapConcatChunk(identity)));\n\n/** @internal */\nconst mapEffectSequential = /*#__PURE__*/dual(2, (self, f) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return readWithCause({\n        onInput: elem => loop(elem[Symbol.iterator]()),\n        onFailure: failCause$1,\n        onDone: succeed$3\n      });\n    } else {\n      const value = next.value;\n      return unwrap$1(map$1(f(value), a2 => flatMap$1(write(of(a2)), () => loop(iterator))));\n    }\n  };\n  return new StreamImpl(pipe(toChannel(self), pipeTo(suspend$2(() => loop(empty$1()[Symbol.iterator]())))));\n});\n\n/** @internal */\nconst mapEffectPar = /*#__PURE__*/dual(3, (self, n, f) => new StreamImpl(pipe(toChannel(self), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of))));\n\n/** @internal */\nconst mapError = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), mapError$2(f))));\n\n/** @internal */\nconst mapErrorCause = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), mapErrorCause$1(f))));\n\n/** @internal */\nconst merge = /*#__PURE__*/dual(args => isStream(args[1]), (self, that, options) => mergeWith(self, that, {\n  onSelf: identity,\n  onOther: identity,\n  haltStrategy: options?.haltStrategy\n}));\n\n/** @internal */\nconst mergeAll = /*#__PURE__*/dual(args => Symbol.iterator in args[0], (streams, options) => flatten(fromIterable(streams), options));\n\n/** @internal */\nconst mergeEither = /*#__PURE__*/dual(2, (self, that) => mergeWith(self, that, {\n  onSelf: left,\n  onOther: right\n}));\n\n/** @internal */\nconst mergeLeft = /*#__PURE__*/dual(2, (self, that) => pipe(self, merge(drain(that))));\n\n/** @internal */\nconst mergeRight = /*#__PURE__*/dual(2, (self, that) => pipe(drain(self), merge(that)));\n\n/** @internal */\nconst mergeWith = /*#__PURE__*/dual(3, (self, other, options) => {\n  const strategy = options.haltStrategy ? fromInput(options.haltStrategy) : Both;\n  const handler = terminate => exit => terminate || !isSuccess(exit) ?\n  // TODO: remove\n  Done(suspend$1(() => exit)) : Await(exit => suspend$1(() => exit));\n  return new StreamImpl(mergeWith$1(toChannel(map(self, options.onSelf)), {\n    other: toChannel(map(other, options.onOther)),\n    onSelfDone: handler(strategy._tag === \"Either\" || strategy._tag === \"Left\"),\n    onOtherDone: handler(strategy._tag === \"Either\" || strategy._tag === \"Right\")\n  }));\n});\n\n/** @internal */\nconst mkString = self => run(self, mkString$1);\n\n/** @internal */\nconst never = /*#__PURE__*/fromEffect(never$1);\n\n/** @internal */\nconst onError = /*#__PURE__*/dual(2, (self, cleanup) => pipe(self, catchAllCause(cause => fromEffect(pipe(cleanup(cause), zipRight$1(failCause$4(cause)))))));\n\n/** @internal */\nconst onDone = /*#__PURE__*/dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel(self), ensuringWith$1(exit => isSuccess(exit) ? cleanup() : unit$2))));\n\n/** @internal */\nconst orDie = self => pipe(self, orDieWith(identity));\n\n/** @internal */\nconst orDieWith = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), orDieWith$1(f))));\n\n/** @internal */\nconst orElse = /*#__PURE__*/dual(2, (self, that) => new StreamImpl(pipe(toChannel(self), orElse$1(() => toChannel(that())))));\n\n/** @internal */\nconst orElseEither = /*#__PURE__*/dual(2, (self, that) => pipe(self, map(left), orElse(() => pipe(that(), map(right)))));\n\n/** @internal */\nconst orElseFail = /*#__PURE__*/dual(2, (self, error) => pipe(self, orElse(() => failSync(error))));\n\n/** @internal */\nconst orElseIfEmpty = /*#__PURE__*/dual(2, (self, element) => pipe(self, orElseIfEmptyChunk(() => of(element()))));\n\n/** @internal */\nconst orElseIfEmptyChunk = /*#__PURE__*/dual(2, (self, chunk) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk())))));\n\n/** @internal */\nconst orElseIfEmptyStream = /*#__PURE__*/dual(2, (self, stream) => {\n  const writer = readWith({\n    onInput: input => {\n      if (isEmpty(input)) {\n        return suspend$2(() => writer);\n      }\n      return pipe(write(input), zipRight$2(identityChannel()));\n    },\n    onFailure: fail$1,\n    onDone: () => suspend$2(() => toChannel(stream()))\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(writer)));\n});\n\n/** @internal */\nconst orElseSucceed = /*#__PURE__*/dual(2, (self, value) => pipe(self, orElse(() => sync(value))));\n\n/** @internal */\nconst paginate = (s, f) => paginateChunk(s, s => {\n  const page = f(s);\n  return [of(page[0]), page[1]];\n});\n\n/** @internal */\nconst paginateChunk = (s, f) => {\n  const loop = s => {\n    const page = f(s);\n    return match$2(page[1], {\n      onNone: () => zipRight$2(write(page[0]), unit$1),\n      onSome: s => flatMap$1(write(page[0]), () => loop(s))\n    });\n  };\n  return new StreamImpl(suspend$2(() => loop(s)));\n};\n\n/** @internal */\nconst paginateChunkEffect = (s, f) => {\n  const loop = s => unwrap$1(map$1(f(s), ([chunk, option]) => match$2(option, {\n    onNone: () => zipRight$2(write(chunk), unit$1),\n    onSome: s => flatMap$1(write(chunk), () => loop(s))\n  })));\n  return new StreamImpl(suspend$2(() => loop(s)));\n};\n\n/** @internal */\nconst paginateEffect = (s, f) => paginateChunkEffect(s, s => pipe(f(s), map$1(([a, s]) => [of(a), s])));\n\n/** @internal */\nconst peel = /*#__PURE__*/dual(2, (self, sink) => {\n  const OP_EMIT = \"Emit\";\n  const OP_HALT = \"Halt\";\n  const OP_END = \"End\";\n  return pipe(make$4(), flatMap$2(deferred => pipe(make$1(), map$1(handoff => {\n    const consumer = foldSink(collectLeftover(sink), {\n      onFailure: error => zipRight$3(fromEffect$2(fail$4(deferred, error)), fail$5(error)),\n      onSuccess: ([z, leftovers]) => {\n        const loop = readWithCause({\n          onInput: elements => flatMap$1(fromEffect$1(offer(handoff, {\n            _tag: OP_EMIT,\n            elements\n          })), () => loop),\n          onFailure: cause => zipRight$2(fromEffect$1(offer(handoff, {\n            _tag: OP_HALT,\n            cause\n          })), failCause$1(cause)),\n          onDone: _ => zipRight$2(fromEffect$1(offer(handoff, {\n            _tag: OP_END\n          })), unit$1)\n        });\n        return fromChannel$1(pipe(fromEffect$1(succeed$2(deferred, z)), zipRight$2(fromEffect$1(pipe(handoff, offer({\n          _tag: OP_EMIT,\n          elements: leftovers\n        })))), zipRight$2(loop)));\n      }\n    });\n    const producer = pipe(take$1(handoff), map$1(signal => {\n      switch (signal._tag) {\n        case OP_EMIT:\n          {\n            return pipe(write(signal.elements), flatMap$1(() => producer));\n          }\n        case OP_HALT:\n          {\n            return failCause$1(signal.cause);\n          }\n        case OP_END:\n          {\n            return unit$1;\n          }\n      }\n    }), unwrap$1);\n    return pipe(self, tapErrorCause(cause => failCause$3(deferred, cause)), run(consumer), forkScoped, zipRight$1(_await(deferred)), map$1(z => [z, new StreamImpl(producer)]));\n  }))), flatten$1);\n});\n\n/** @internal */\nconst partition = /*#__PURE__*/dual(args => typeof args[1] === \"function\", (self, predicate, options) => partitionEither(self, a => succeed$1(predicate(a) ? left(a) : right(a)), options));\n\n/** @internal */\nconst partitionEither = /*#__PURE__*/dual(args => typeof args[1] === \"function\", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({\n  size: 2,\n  maximumLag: options?.bufferSize ?? 16,\n  decide: match({\n    onLeft: () => succeed$1(n => n === 0),\n    onRight: () => succeed$1(n => n === 1)\n  })\n}), flatMap$2(([queue1, queue2]) => succeed$1([filterMap(flattenExitOption(fromQueue(queue1, {\n  shutdown: true\n})), _ => match(_, {\n  onLeft: some$1,\n  onRight: none\n})), filterMap(flattenExitOption(fromQueue(queue2, {\n  shutdown: true\n})), _ => match(_, {\n  onLeft: none,\n  onRight: some$1\n}))]))));\n\n/** @internal */\nconst pipeThrough = /*#__PURE__*/dual(2, (self, sink) => new StreamImpl(pipe(toChannel(self), pipeToOrFail(toChannel$1(sink)))));\n\n/** @internal */\nconst pipeThroughChannel = /*#__PURE__*/dual(2, (self, channel) => new StreamImpl(pipe(toChannel(self), pipeTo(channel))));\n\n/** @internal */\nconst pipeThroughChannelOrFail = /*#__PURE__*/dual(2, (self, chan) => new StreamImpl(pipe(toChannel(self), pipeToOrFail(chan))));\n\n/** @internal */\nconst prepend = /*#__PURE__*/dual(2, (self, values) => new StreamImpl(zipRight$2(write(values), toChannel(self))));\n\n/** @internal */\nconst provideContext = /*#__PURE__*/dual(2, (self, context) => new StreamImpl(pipe(toChannel(self), provideContext$1(context))));\n\n/** @internal */\nconst provideLayer = /*#__PURE__*/dual(2, (self, layer) => new StreamImpl(unwrapScoped$1(pipe(build(layer), map$1(env => pipe(toChannel(self), provideContext$1(env)))))));\n\n/** @internal */\nconst provideService = /*#__PURE__*/dual(3, (self, tag, resource) => provideServiceEffect(self, tag, succeed$1(resource)));\n\n/** @internal */\nconst provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => provideServiceStream(self, tag, fromEffect(effect)));\n\n/** @internal */\nconst provideServiceStream = /*#__PURE__*/dual(3, (self, tag, stream) => contextWithStream(env => flatMap(stream, service => pipe(self, provideContext(add(env, tag, service))))));\n\n/** @internal */\nconst mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithStream(env => pipe(self, provideContext(f(env)))));\n\n/** @internal */\nconst provideSomeLayer = /*#__PURE__*/dual(2, (self, layer) =>\n// @ts-expect-error\npipe(self, provideLayer(pipe(context$2(), merge$1(layer)))));\n\n/** @internal */\nconst range = (min, max, chunkSize = DefaultChunkSize) => suspend(() => {\n  if (min > max) {\n    return empty;\n  }\n  const go = (min, max, chunkSize) => {\n    const remaining = max - min + 1;\n    if (remaining > chunkSize) {\n      return pipe(write(range$1(min, min + chunkSize - 1)), flatMap$1(() => go(min + chunkSize, max, chunkSize)));\n    }\n    return write(range$1(min, min + remaining - 1));\n  };\n  return new StreamImpl(go(min, max, chunkSize));\n});\n\n/** @internal */\nconst rechunk = /*#__PURE__*/dual(2, (self, n) => suspend(() => {\n  const target = Math.max(n, 1);\n  const process = rechunkProcess(new StreamRechunker(target), target);\n  return new StreamImpl(pipe(toChannel(self), pipeTo(process)));\n}));\n\n/** @internal */\nconst rechunkProcess = (rechunker, target) => readWithCause({\n  onInput: chunk => {\n    if (chunk.length === target && rechunker.isEmpty()) {\n      return flatMap$1(write(chunk), () => rechunkProcess(rechunker, target));\n    }\n    if (chunk.length > 0) {\n      const chunks = [];\n      let result = undefined;\n      let index = 0;\n      while (index < chunk.length) {\n        while (index < chunk.length && result === undefined) {\n          result = rechunker.write(pipe(chunk, unsafeGet$1(index)));\n          index = index + 1;\n        }\n        if (result !== undefined) {\n          chunks.push(result);\n          result = undefined;\n        }\n      }\n      return flatMap$1(writeAll(...chunks), () => rechunkProcess(rechunker, target));\n    }\n    return suspend$2(() => rechunkProcess(rechunker, target));\n  },\n  onFailure: cause => zipRight$2(rechunker.emitIfNotEmpty(), failCause$1(cause)),\n  onDone: () => rechunker.emitIfNotEmpty()\n});\n\n/** @internal */\nclass StreamRechunker {\n  builder = [];\n  pos = 0;\n  constructor(n) {\n    this.n = n;\n  }\n  isEmpty() {\n    return this.pos === 0;\n  }\n  write(elem) {\n    this.builder.push(elem);\n    this.pos += 1;\n    if (this.pos === this.n) {\n      const result = unsafeFromArray(this.builder);\n      this.builder = [];\n      this.pos = 0;\n      return result;\n    }\n    return undefined;\n  }\n  emitIfNotEmpty() {\n    if (this.pos !== 0) {\n      return write(unsafeFromArray(this.builder));\n    }\n    return unit$1;\n  }\n}\n\n/** @internal */\nconst refineOrDie = /*#__PURE__*/dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));\n\n/** @internal */\nconst refineOrDieWith = /*#__PURE__*/dual(3, (self, pf, f) => new StreamImpl(catchAll$1(toChannel(self), error => match$2(pf(error), {\n  onNone: () => failCause$1(die$2(f(error))),\n  onSome: fail$1\n}))));\n\n/** @internal */\nconst repeat = /*#__PURE__*/dual(2, (self, schedule) => filterMap(repeatEither(self, schedule), _ => match(_, {\n  onLeft: none,\n  onRight: some$1\n})));\n\n/** @internal */\nconst repeatEffect = effect => repeatEffectOption(pipe(effect, mapError$1(some$1)));\n\n/** @internal */\nconst repeatEffectChunk = effect => repeatEffectChunkOption(pipe(effect, mapError$1(some$1)));\n\n/** @internal */\nconst repeatEffectChunkOption = effect => unfoldChunkEffect(effect, effect => pipe(map$1(effect, chunk => some$1([chunk, effect])), catchAll$2(match$2({\n  onNone: () => succeed$1(none()),\n  onSome: fail$3\n}))));\n\n/** @internal */\nconst repeatEffectOption = effect => repeatEffectChunkOption(pipe(effect, map$1(of)));\n\n/** @internal */\nconst repeatEither = /*#__PURE__*/dual(2, (self, schedule) => repeatWith(self, schedule, {\n  onElement: a => right(a),\n  onSchedule: left\n}));\n\n/** @internal */\nconst repeatElements = /*#__PURE__*/dual(2, (self, schedule) => filterMap(repeatElementsWith(self, schedule, {\n  onElement: a => some$1(a),\n  onSchedule: none\n}), identity));\n\n/** @internal */\nconst repeatElementsWith = /*#__PURE__*/dual(3, (self, schedule, options) => {\n  const driver$1 = pipe(driver(schedule), map$1(driver => {\n    const feed = input => match$2(head$1(input), {\n      onNone: () => loop,\n      onSome: a => zipRight$2(write(of(options.onElement(a))), step(pipe(input, drop$1(1)), a))\n    });\n    const step = (input, a) => {\n      const advance = pipe(driver.next(a), as$1(pipe(write(of(options.onElement(a))), flatMap$1(() => step(input, a)))));\n      const reset = pipe(driver.last(), orDie$1, flatMap$2(b => pipe(driver.reset(), map$1(() => pipe(write(of(options.onSchedule(b))), zipRight$2(feed(input)))))));\n      return pipe(advance, orElse$2(() => reset), unwrap$1);\n    };\n    const loop = readWith({\n      onInput: feed,\n      onFailure: fail$1,\n      onDone: () => unit$1\n    });\n    return loop;\n  }), unwrap$1);\n  return new StreamImpl(pipe(toChannel(self), pipeTo(driver$1)));\n});\n\n/** @internal */\nconst repeatValue = value => new StreamImpl(repeated(write(of(value))));\n\n/** @internal */\nconst repeatWith = /*#__PURE__*/dual(3, (self, schedule, options) => {\n  return pipe(driver(schedule), map$1(driver => {\n    const scheduleOutput = pipe(driver.last(), orDie$1, map$1(options.onSchedule));\n    const process = pipe(self, map(options.onElement), toChannel);\n    const loop = unwrap$1(match$1(driver.next(void 0), {\n      onFailure: () => unit$1,\n      onSuccess: () => pipe(process, zipRight$2(pipe(scheduleOutput, map$1(c => pipe(write(of(c)), flatMap$1(() => loop))), unwrap$1)))\n    }));\n    return new StreamImpl(pipe(process, zipRight$2(loop)));\n  }), unwrap);\n});\n\n/** @internal */\nconst repeatWithSchedule = (value, schedule) => repeatEffectWithSchedule(succeed$1(value), schedule);\n\n/** @internal */\nconst repeatEffectWithSchedule = (effect, schedule) => flatMap(fromEffect(zip$1(effect, driver(schedule))), ([a, driver]) => concat(succeed(a), unfoldEffect(a, s => matchEffect(driver.next(s), {\n  onFailure: succeed$1,\n  onSuccess: () => map$1(effect, nextA => some$1([nextA, nextA]))\n}))));\n\n/** @internal */\nconst retry = /*#__PURE__*/dual(2, (self, schedule) => unwrap(map$1(driver(schedule), driver => {\n  const loop = catchAll(self, error => unwrap(matchEffect(driver.next(error), {\n    onFailure: () => fail$3(error),\n    onSuccess: () => succeed$1(pipe(loop, tap(() => driver.reset())))\n  })));\n  return loop;\n})));\n\n/** @internal */\nconst run = /*#__PURE__*/dual(2, (self, sink) => pipe(toChannel(self), pipeToOrFail(toChannel$1(sink)), runDrain$1));\n\n/** @internal */\nconst runCollect = self => pipe(self, run(collectAll()));\n\n/** @internal */\nconst runCount = self => pipe(self, run(count));\n\n/** @internal */\nconst runDrain = self => pipe(self, run(drain$2));\n\n/** @internal */\nconst runFold = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f), scoped$1));\n\n/** @internal */\nconst runFoldEffect = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f), scoped$1));\n\n/** @internal */\nconst runFoldScoped = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));\n\n/** @internal */\nconst runFoldScopedEffect = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));\n\n/** @internal */\nconst runFoldWhile = /*#__PURE__*/dual(4, (self, s, cont, f) => pipe(self, runFoldWhileScoped(s, cont, f), scoped$1));\n\n/** @internal */\nconst runFoldWhileEffect = /*#__PURE__*/dual(4, (self, s, cont, f) => pipe(self, runFoldWhileScopedEffect(s, cont, f), scoped$1));\n\n/** @internal */\nconst runFoldWhileScoped = /*#__PURE__*/dual(4, (self, s, cont, f) => pipe(self, runScoped(fold(s, cont, f))));\n\n/** @internal */\nconst runFoldWhileScopedEffect = /*#__PURE__*/dual(4, (self, s, cont, f) => pipe(self, runScoped(foldEffect(s, cont, f))));\n\n/** @internal */\nconst runForEach = /*#__PURE__*/dual(2, (self, f) => pipe(self, run(forEach$1(f))));\n\n/** @internal */\nconst runForEachChunk = /*#__PURE__*/dual(2, (self, f) => pipe(self, run(forEachChunk(f))));\n\n/** @internal */\nconst runForEachChunkScoped = /*#__PURE__*/dual(2, (self, f) => pipe(self, runScoped(forEachChunk(f))));\n\n/** @internal */\nconst runForEachScoped = /*#__PURE__*/dual(2, (self, f) => pipe(self, runScoped(forEach$1(f))));\n\n/** @internal */\nconst runForEachWhile = /*#__PURE__*/dual(2, (self, f) => pipe(self, run(forEachWhile(f))));\n\n/** @internal */\nconst runForEachWhileScoped = /*#__PURE__*/dual(2, (self, f) => pipe(self, runScoped(forEachWhile(f))));\n\n/** @internal */\nconst runHead = self => pipe(self, run(head()));\n\n/** @internal */\nconst runIntoPubSub = /*#__PURE__*/dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));\n\n/** @internal */\nconst runIntoPubSubScoped = /*#__PURE__*/dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));\n\n/** @internal */\nconst runIntoQueue = /*#__PURE__*/dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped$1));\n\n/** @internal */\nconst runIntoQueueElementsScoped = /*#__PURE__*/dual(2, (self, queue) => {\n  const writer = readWithCause({\n    onInput: input => flatMap$1(fromEffect$1(offerAll(queue, map$2(input, succeed$4))), () => writer),\n    onFailure: cause => fromEffect$1(offer$1(queue, failCause$2(map$3(cause, some$1)))),\n    onDone: () => fromEffect$1(offer$1(queue, fail$2(none())))\n  });\n  return pipe(pipeTo(toChannel(self), writer), drain$1, runScoped$1, asUnit);\n});\n\n/** @internal */\nconst runIntoQueueScoped = /*#__PURE__*/dual(2, (self, queue) => {\n  const writer = readWithCause({\n    onInput: input => flatMap$1(write(chunk(input)), () => writer),\n    onFailure: cause => write(failCause$6(cause)),\n    onDone: () => write(end$2)\n  });\n  return pipe(pipeTo(toChannel(self), writer), mapOutEffect(take => offer$1(queue, take)), drain$1, runScoped$1, asUnit);\n});\n\n/** @internal */\nconst runLast = self => pipe(self, run(last()));\n\n/** @internal */\nconst runScoped = /*#__PURE__*/dual(2, (self, sink) => pipe(toChannel(self), pipeToOrFail(toChannel$1(sink)), drain$1, runScoped$1));\n\n/** @internal */\nconst runSum = self => pipe(self, run(sum));\n\n/** @internal */\nconst scan = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, scanEffect(s, (s, a) => succeed$1(f(s, a)))));\n\n/** @internal */\nconst scanReduce = /*#__PURE__*/dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => succeed$1(f(a2, a)))));\n\n/** @internal */\nconst scanReduceEffect = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapAccumEffect(none(), (option, a) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return succeed$1([some$1(a), a]);\n      }\n    case \"Some\":\n      {\n        return pipe(f(option.value, a), map$1(b => [some$1(b), b]));\n      }\n  }\n})));\n\n/** @internal */\nconst schedule = /*#__PURE__*/dual(2, (self, schedule) => filterMap(scheduleWith(self, schedule, {\n  onElement: some$1,\n  onSchedule: none\n}), identity));\n\n/** @internal */\nconst scheduleWith = /*#__PURE__*/dual(3, (self, schedule, options) => {\n  const loop = (driver, iterator) => {\n    const next = iterator.next();\n    if (next.done) {\n      return readWithCause({\n        onInput: chunk => loop(driver, chunk[Symbol.iterator]()),\n        onFailure: failCause$1,\n        onDone: succeedNow\n      });\n    }\n    return unwrap$1(matchEffect(driver.next(next.value), {\n      onFailure: () => pipe(driver.last(), orDie$1, map$1(b => pipe(write(make$7(options.onElement(next.value), options.onSchedule(b))), flatMap$1(() => loop(driver, iterator)))), zipLeft$1(driver.reset())),\n      onSuccess: () => succeed$1(pipe(write(of(options.onElement(next.value))), flatMap$1(() => loop(driver, iterator))))\n    }));\n  };\n  return new StreamImpl(pipe(fromEffect$1(driver(schedule)), flatMap$1(driver => pipe(toChannel(self), pipeTo(loop(driver, empty$1()[Symbol.iterator]()))))));\n});\n\n/** @internal */\nconst scanEffect = /*#__PURE__*/dual(3, (self, s, f) => new StreamImpl(pipe(write(of(s)), flatMap$1(() => toChannel(pipe(self, mapAccumEffect(s, (s, a) => pipe(f(s, a), map$1(s => [s, s])))))))));\n\n/** @internal */\nconst scoped = effect => new StreamImpl(ensuring$1(scoped$2(pipe(effect, map$1(of))), unit$2));\n\n/** @internal */\nconst some = self => pipe(self, mapError(some$1), someOrFail(() => none()));\n\n/** @internal */\nconst someOrElse = /*#__PURE__*/dual(2, (self, fallback) => pipe(self, map(getOrElse(fallback))));\n\n/** @internal */\nconst someOrFail = /*#__PURE__*/dual(2, (self, error) => mapEffectSequential(self, match$2({\n  onNone: () => failSync$1(error),\n  onSome: succeed$1\n})));\n\n/** @internal */\nconst sliding = /*#__PURE__*/dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));\n\n/** @internal */\nconst slidingSize = /*#__PURE__*/dual(3, (self, chunkSize, stepSize) => {\n  if (chunkSize <= 0 || stepSize <= 0) {\n    return die(IllegalArgumentException(\"Invalid bounds - `chunkSize` and `stepSize` must be greater than zero\"));\n  }\n  return new StreamImpl(suspend$2(() => {\n    const queue = new RingBuffer(chunkSize);\n    const emitOnStreamEnd = (queueSize, channelEnd) => {\n      if (queueSize < chunkSize) {\n        const items = queue.toChunk();\n        const result = isEmpty(items) ? empty$1() : of(items);\n        return pipe(write(result), flatMap$1(() => channelEnd));\n      }\n      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;\n      if (lastEmitIndex === queueSize) {\n        return channelEnd;\n      }\n      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);\n      const lastItems = pipe(queue.toChunk(), takeRight$1(leftovers));\n      const result = isEmpty(lastItems) ? empty$1() : of(lastItems);\n      return pipe(write(result), flatMap$1(() => channelEnd));\n    };\n    const reader = queueSize => readWithCause({\n      onInput: input => flatMap$1(write(filterMap$1(input, (element, index) => {\n        queue.put(element);\n        const currentIndex = queueSize + index + 1;\n        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {\n          return none();\n        }\n        return some$1(queue.toChunk());\n      })), () => reader(queueSize + input.length)),\n      onFailure: cause => emitOnStreamEnd(queueSize, failCause$1(cause)),\n      onDone: () => emitOnStreamEnd(queueSize, unit$1)\n    });\n    return pipe(toChannel(self), pipeTo(reader(0)));\n  }));\n});\n\n/** @internal */\nconst split = /*#__PURE__*/dual(2, (self, predicate) => {\n  const split = (leftovers, input) => {\n    const [chunk, remaining] = pipe(leftovers, appendAll(input), splitWhere(predicate));\n    if (isEmpty(chunk) || isEmpty(remaining)) {\n      return loop(pipe(chunk, appendAll(pipe(remaining, drop$1(1)))));\n    }\n    return pipe(write(of(chunk)), flatMap$1(() => split(empty$1(), pipe(remaining, drop$1(1)))));\n  };\n  const loop = leftovers => readWith({\n    onInput: input => split(leftovers, input),\n    onFailure: fail$1,\n    onDone: () => {\n      if (isEmpty(leftovers)) {\n        return unit$1;\n      }\n      if (isNone(pipe(leftovers, findFirst(predicate)))) {\n        return zipRight$2(write(of(leftovers)), unit$1);\n      }\n      return zipRight$2(split(empty$1(), leftovers), unit$1);\n    }\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(loop(empty$1()))));\n});\n\n/** @internal */\nconst splitOnChunk = /*#__PURE__*/dual(2, (self, delimiter) => {\n  const next = (leftover, delimiterIndex) => readWithCause({\n    onInput: inputChunk => {\n      let buffer;\n      const [carry, delimiterCursor] = pipe(inputChunk, reduce([pipe(leftover, getOrElse(() => empty$1())), delimiterIndex], ([carry, delimiterCursor], a) => {\n        const concatenated = pipe(carry, append(a));\n        if (delimiterCursor < delimiter.length && equals(a, pipe(delimiter, unsafeGet$1(delimiterCursor)))) {\n          if (delimiterCursor + 1 === delimiter.length) {\n            if (buffer === undefined) {\n              buffer = [];\n            }\n            buffer.push(pipe(concatenated, take$3(concatenated.length - delimiter.length)));\n            return [empty$1(), 0];\n          }\n          return [concatenated, delimiterCursor + 1];\n        }\n        return [concatenated, equals(a, pipe(delimiter, unsafeGet$1(0))) ? 1 : 0];\n      }));\n      const output = buffer === undefined ? empty$1() : unsafeFromArray(buffer);\n      return flatMap$1(write(output), () => next(isNonEmpty(carry) ? some$1(carry) : none(), delimiterCursor));\n    },\n    onFailure: cause => match$2(leftover, {\n      onNone: () => failCause$1(cause),\n      onSome: chunk => zipRight$2(write(of(chunk)), failCause$1(cause))\n    }),\n    onDone: done => match$2(leftover, {\n      onNone: () => succeed$3(done),\n      onSome: chunk => zipRight$2(write(of(chunk)), succeed$3(done))\n    })\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(next(none(), 0))));\n});\n\n/** @internal */\nconst splitLines = self => suspend(() => {\n  let stringBuilder = \"\";\n  let midCRLF = false;\n  const splitLinesChunk = chunk => {\n    const chunkBuilder = [];\n    map$2(chunk, str => {\n      if (str.length !== 0) {\n        let from = 0;\n        let indexOfCR = str.indexOf(\"\\r\");\n        let indexOfLF = str.indexOf(\"\\n\");\n        if (midCRLF) {\n          if (indexOfLF === 0) {\n            chunkBuilder.push(stringBuilder);\n            stringBuilder = \"\";\n            from = 1;\n            indexOfLF = str.indexOf(\"\\n\", from);\n          } else {\n            stringBuilder = stringBuilder + \"\\r\";\n          }\n          midCRLF = false;\n        }\n        while (indexOfCR !== -1 || indexOfLF !== -1) {\n          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {\n            if (stringBuilder.length === 0) {\n              chunkBuilder.push(str.substring(from, indexOfLF));\n            } else {\n              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));\n              stringBuilder = \"\";\n            }\n            from = indexOfLF + 1;\n            indexOfLF = str.indexOf(\"\\n\", from);\n          } else {\n            if (str.length === indexOfCR + 1) {\n              midCRLF = true;\n              indexOfCR = -1;\n            } else {\n              if (indexOfLF === indexOfCR + 1) {\n                if (stringBuilder.length === 0) {\n                  chunkBuilder.push(str.substring(from, indexOfCR));\n                } else {\n                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);\n                  chunkBuilder.push(stringBuilder);\n                  stringBuilder = \"\";\n                }\n                from = indexOfCR + 2;\n                indexOfCR = str.indexOf(\"\\r\", from);\n                indexOfLF = str.indexOf(\"\\n\", from);\n              } else {\n                indexOfCR = str.indexOf(\"\\r\", indexOfCR + 1);\n              }\n            }\n          }\n        }\n        if (midCRLF) {\n          stringBuilder = stringBuilder + str.substring(from, str.length - 1);\n        } else {\n          stringBuilder = stringBuilder + str.substring(from, str.length);\n        }\n      }\n    });\n    return unsafeFromArray(chunkBuilder);\n  };\n  const loop = readWithCause({\n    onInput: input => {\n      const out = splitLinesChunk(input);\n      return isEmpty(out) ? loop : flatMap$1(write(out), () => loop);\n    },\n    onFailure: cause => stringBuilder.length === 0 ? failCause$1(cause) : flatMap$1(write(of(stringBuilder)), () => failCause$1(cause)),\n    onDone: done => stringBuilder.length === 0 ? succeed$3(done) : flatMap$1(write(of(stringBuilder)), () => succeed$3(done))\n  });\n  return new StreamImpl(pipeTo(toChannel(self), loop));\n});\n\n/** @internal */\nconst succeed = value => fromChunk(of(value));\n\n/** @internal */\nconst sync = evaluate => suspend(() => fromChunk(of(evaluate())));\n\n/** @internal */\nconst suspend = stream => new StreamImpl(suspend$2(() => toChannel(stream())));\n\n/** @internal */\nconst take = /*#__PURE__*/dual(2, (self, n) => {\n  if (!Number.isInteger(n)) {\n    return die(IllegalArgumentException(`${n} must be an integer`));\n  }\n  const loop = n => readWith({\n    onInput: input => {\n      const taken = pipe(input, take$3(Math.min(n, Number.POSITIVE_INFINITY)));\n      const leftover = Math.max(0, n - taken.length);\n      const more = leftover > 0;\n      if (more) {\n        return pipe(write(taken), flatMap$1(() => loop(leftover)));\n      }\n      return write(taken);\n    },\n    onFailure: fail$1,\n    onDone: succeed$3\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(0 < n ? loop(n) : unit$1)));\n});\n\n/** @internal */\nconst takeRight = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return empty;\n  }\n  return new StreamImpl(pipe(succeed$1(new RingBuffer(n)), map$1(queue => {\n    const reader = readWith({\n      onInput: input => {\n        for (const element of input) {\n          queue.put(element);\n        }\n        return reader;\n      },\n      onFailure: fail$1,\n      onDone: () => pipe(write(queue.toChunk()), zipRight$2(unit$1))\n    });\n    return pipe(toChannel(self), pipeTo(reader));\n  }), unwrap$1));\n});\n\n/** @internal */\nconst takeUntil = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => {\n      const taken = pipe(input, takeWhile$1(a => !predicate(a)));\n      const last = pipe(input, drop$1(taken.length), take$3(1));\n      if (isEmpty(last)) {\n        return pipe(write(taken), flatMap$1(() => loop));\n      }\n      return write(pipe(taken, appendAll(last)));\n    },\n    onFailure: fail$1,\n    onDone: succeed$3\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(loop)));\n});\n\n/** @internal */\nconst takeUntilEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return readWithCause({\n        onInput: elem => loop(elem[Symbol.iterator]()),\n        onFailure: failCause$1,\n        onDone: succeed$3\n      });\n    }\n    return pipe(predicate(next.value), map$1(bool => bool ? write(of(next.value)) : pipe(write(of(next.value)), flatMap$1(() => loop(iterator)))), unwrap$1);\n  };\n  return new StreamImpl(pipe(toChannel(self), pipeTo(loop(empty$1()[Symbol.iterator]()))));\n});\n\n/** @internal */\nconst takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = readWith({\n    onInput: input => {\n      const taken = pipe(input, takeWhile$1(predicate));\n      const more = taken.length === input.length;\n      if (more) {\n        return pipe(write(taken), flatMap$1(() => loop));\n      }\n      return write(taken);\n    },\n    onFailure: fail$1,\n    onDone: succeed$3\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(loop)));\n});\n\n/** @internal */\nconst tap = /*#__PURE__*/dual(2, (self, f) => mapEffectSequential(self, a => as$1(f(a), a)));\n\n/** @internal */\nconst tapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => pipe(self, tapError(onFailure), tap(onSuccess)));\n\n/** @internal */\nconst tapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, error => fromEffect(zipRight$1(f(error), fail$3(error)))));\n\n/** @internal */\nconst tapErrorCause = /*#__PURE__*/dual(2, (self, f) => {\n  const loop = readWithCause({\n    onInput: chunk => flatMap$1(write(chunk), () => loop),\n    onFailure: cause => fromEffect$1(zipRight$1(f(cause), failCause$4(cause))),\n    onDone: succeedNow\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeTo(loop)));\n});\n\n/** @internal */\nconst tapSink = /*#__PURE__*/dual(2, (self, sink) => pipe(fromEffect(all([bounded(1), make$4()])), flatMap(([queue, deferred]) => {\n  const right = flattenTake(fromQueue(queue, {\n    maxChunkSize: 1\n  }));\n  const loop = readWithCause({\n    onInput: chunk$1 => pipe(fromEffect$1(offer$1(queue, chunk(chunk$1))), foldCauseChannel({\n      onFailure: () => flatMap$1(write(chunk$1), () => identityChannel()),\n      onSuccess: () => flatMap$1(write(chunk$1), () => loop)\n    })),\n    onFailure: cause => pipe(fromEffect$1(offer$1(queue, failCause$6(cause))), foldCauseChannel({\n      onFailure: () => failCause$1(cause),\n      onSuccess: () => failCause$1(cause)\n    })),\n    onDone: () => pipe(fromEffect$1(offer$1(queue, end$2)), foldCauseChannel({\n      onFailure: () => unit$1,\n      onSuccess: () => unit$1\n    }))\n  });\n  return pipe(new StreamImpl(pipe(pipeTo(toChannel(self), loop), ensuring$1(zipRight$1(forkDaemon(offer$1(queue, end$2)), _await(deferred))))), merge(execute(pipe(run(right, sink), ensuring$2(zipRight$1(shutdown(queue), succeed$2(deferred, void 0)))))));\n})));\n\n/** @internal */\nconst throttle = /*#__PURE__*/dual(2, (self, options) => throttleEffect(self, {\n  ...options,\n  cost: chunk => succeed$1(options.cost(chunk))\n}));\n\n/** @internal */\nconst throttleEffect = /*#__PURE__*/dual(2, (self, options) => {\n  if (options.strategy === \"enforce\") {\n    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);\n  }\n  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);\n});\nconst throttleEnforceEffect = (self, cost, units, duration, burst) => {\n  const loop = (tokens, timestampMillis) => readWithCause({\n    onInput: input => pipe(cost(input), zip$1(currentTimeMillis), map$1(([weight, currentTimeMillis]) => {\n      const elapsed = currentTimeMillis - timestampMillis;\n      const cycles = elapsed / toMillis(duration);\n      const sum = tokens + cycles * units;\n      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;\n      const available = sum < 0 ? max : Math.min(sum, max);\n      if (weight <= available) {\n        return pipe(write(input), flatMap$1(() => loop(available - weight, currentTimeMillis)));\n      }\n      return loop(tokens, timestampMillis);\n    }), unwrap$1),\n    onFailure: failCause$1,\n    onDone: () => unit$1\n  });\n  const throttled = pipe(currentTimeMillis, map$1(currentTimeMillis => loop(units, currentTimeMillis)), unwrap$1);\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(throttled)));\n};\nconst throttleShapeEffect = (self, costFn, units, duration, burst) => {\n  const loop = (tokens, timestampMillis) => readWithCause({\n    onInput: input => pipe(costFn(input), zip$1(currentTimeMillis), map$1(([weight, currentTimeMillis]) => {\n      const elapsed = currentTimeMillis - timestampMillis;\n      const cycles = elapsed / toMillis(duration);\n      const sum = tokens + cycles * units;\n      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;\n      const available = sum < 0 ? max : Math.min(sum, max);\n      const remaining = available - weight;\n      const waitCycles = remaining >= 0 ? 0 : -remaining / units;\n      const delay = millis(Math.max(0, waitCycles * toMillis(duration)));\n      if (greaterThan(delay, zero)) {\n        return pipe(fromEffect$1(sleep(delay)), zipRight$2(write(input)), flatMap$1(() => loop(remaining, currentTimeMillis)));\n      }\n      return flatMap$1(write(input), () => loop(remaining, currentTimeMillis));\n    }), unwrap$1),\n    onFailure: failCause$1,\n    onDone: () => unit$1\n  });\n  const throttled = pipe(currentTimeMillis, map$1(currentTimeMillis => loop(units, currentTimeMillis)), unwrap$1);\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(throttled)));\n};\n\n/** @internal */\nconst tick = interval => repeatWithSchedule(void 0, spaced(interval));\n\n/** @internal */\nconst timeout = /*#__PURE__*/dual(2, (self, duration) => pipe(toPull(self), map$1(timeoutFail$1({\n  onTimeout: () => none(),\n  duration\n})), fromPull));\n\n/** @internal */\nconst timeoutFail = /*#__PURE__*/dual(3, (self, error, duration) => pipe(self, timeoutTo(duration, failSync(error))));\n\n/** @internal */\nconst timeoutFailCause = /*#__PURE__*/dual(3, (self, cause, duration) => pipe(toPull(self), map$1(timeoutFailCause$1({\n  onTimeout: () => map$3(cause(), some$1),\n  duration\n})), fromPull));\n\n/** @internal */\nconst timeoutTo = /*#__PURE__*/dual(3, (self, duration, that) => {\n  const StreamTimeout = RuntimeException(\"Stream Timeout\");\n  return pipe(self, timeoutFailCause(() => die$2(StreamTimeout), duration), catchSomeCause(cause => isDieType(cause) && isRuntimeException(cause.defect) && cause.defect.message !== undefined && cause.defect.message === \"Stream Timeout\" ? some$1(that) : none()));\n});\n\n/** @internal */\nconst toPubSub = /*#__PURE__*/dual(2, (self, capacity) => pipe(acquireRelease$1(bounded$1(capacity), pubsub => shutdown$1(pubsub)), tap$1(pubsub => pipe(self, runIntoPubSubScoped(pubsub), forkScoped))));\n\n/** @internal */\nconst toPull = self => map$1(toPull$1(toChannel(self)), pull => pipe(pull, mapError$1(some$1), flatMap$2(match({\n  onLeft: () => fail$3(none()),\n  onRight: succeed$1\n}))));\n\n/** @internal */\nconst toQueue = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => tap$1(acquireRelease$1(options?.strategy === \"unbounded\" ? unbounded() : options?.strategy === \"dropping\" ? dropping(options.capacity ?? 2) : options?.strategy === \"sliding\" ? sliding$1(options.capacity ?? 2) : bounded(options?.capacity ?? 2), queue => shutdown(queue)), queue => forkScoped(runIntoQueueScoped(self, queue))));\n\n/** @internal */\nconst toQueueOfElements = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => tap$1(acquireRelease$1(bounded(options?.capacity ?? 2), queue => shutdown(queue)), queue => forkScoped(runIntoQueueElementsScoped(self, queue))));\n\n/** @internal */\nconst toReadableStream = source => {\n  let pull;\n  let scope;\n  return new ReadableStream({\n    start(controller) {\n      scope = runSync(make$6());\n      pull = pipe(toPull(source), use(scope), runSync, tap$1(chunk => sync$1(() => {\n        map$2(chunk, a => {\n          controller.enqueue(a);\n        });\n      })), tapErrorCause$1(() => close(scope, unit$3)), catchTags$1({\n        \"None\": () => sync$1(() => {\n          controller.close();\n        }),\n        \"Some\": error => sync$1(() => {\n          controller.error(error.value);\n        })\n      }), asUnit);\n    },\n    pull() {\n      return runPromise(pull);\n    },\n    cancel() {\n      return runPromise(close(scope, unit$3));\n    }\n  });\n};\n\n/** @internal */\nconst transduce = /*#__PURE__*/dual(2, (self, sink) => {\n  const newChannel = suspend$2(() => {\n    const leftovers = {\n      ref: empty$1()\n    };\n    const upstreamDone = {\n      ref: false\n    };\n    const buffer = suspend$2(() => {\n      const leftover = leftovers.ref;\n      if (isEmpty(leftover)) {\n        return readWith({\n          onInput: input => pipe(write(input), flatMap$1(() => buffer)),\n          onFailure: fail$1,\n          onDone: succeedNow\n        });\n      }\n      leftovers.ref = empty$1();\n      return pipe(writeChunk(leftover), flatMap$1(() => buffer));\n    });\n    const concatAndGet = chunk => {\n      const leftover = leftovers.ref;\n      const concatenated = appendAll(leftover, filter$1(chunk, chunk => chunk.length !== 0));\n      leftovers.ref = concatenated;\n      return concatenated;\n    };\n    const upstreamMarker = readWith({\n      onInput: input => flatMap$1(write(input), () => upstreamMarker),\n      onFailure: fail$1,\n      onDone: done => zipRight$2(sync$2(() => {\n        upstreamDone.ref = true;\n      }), succeedNow(done))\n    });\n    const transducer = pipe(sink, toChannel$1, collectElements, flatMap$1(([leftover, z]) => pipe(succeed$3([upstreamDone.ref, concatAndGet(leftover)]), flatMap$1(([done, newLeftovers]) => {\n      const nextChannel = done && isEmpty(newLeftovers) ? unit$1 : transducer;\n      return pipe(write(of(z)), flatMap$1(() => nextChannel));\n    }))));\n    return pipe(toChannel(self), pipeTo(upstreamMarker), pipeTo(buffer), pipeToOrFail(transducer));\n  });\n  return new StreamImpl(newChannel);\n});\n\n/** @internal */\nconst unfold = (s, f) => unfoldChunk(s, s => pipe(f(s), map$4(([a, s]) => [of(a), s])));\n\n/** @internal */\nconst unfoldChunk = (s, f) => {\n  const loop = s => match$2(f(s), {\n    onNone: () => unit$1,\n    onSome: ([chunk, s]) => flatMap$1(write(chunk), () => loop(s))\n  });\n  return new StreamImpl(suspend$2(() => loop(s)));\n};\n\n/** @internal */\nconst unfoldChunkEffect = (s, f) => suspend(() => {\n  const loop = s => unwrap$1(map$1(f(s), match$2({\n    onNone: () => unit$1,\n    onSome: ([chunk, s]) => flatMap$1(write(chunk), () => loop(s))\n  })));\n  return new StreamImpl(loop(s));\n});\n\n/** @internal */\nconst unfoldEffect = (s, f) => unfoldChunkEffect(s, s => pipe(f(s), map$1(map$4(([a, s]) => [of(a), s]))));\n\n/** @internal */\nconst unit = /*#__PURE__*/succeed(void 0);\n\n/** @internal */\nconst unwrap = effect => flatten(fromEffect(effect));\n\n/** @internal */\nconst unwrapScoped = effect => flatten(scoped(effect));\n\n/** @internal */\nconst updateService = /*#__PURE__*/dual(3, (self, tag, f) => pipe(self, mapInputContext(context => pipe(context, add(tag, f(pipe(context, unsafeGet(tag))))))));\n\n/** @internal */\nconst when = /*#__PURE__*/dual(2, (self, predicate) => pipe(self, whenEffect(sync$1(predicate))));\n\n/** @internal */\nconst whenCase = (evaluate, pf) => whenCaseEffect(pf)(sync$1(evaluate));\n\n/** @internal */\nconst whenCaseEffect = /*#__PURE__*/dual(2, (self, pf) => pipe(fromEffect(self), flatMap(a => pipe(pf(a), getOrElse(() => empty)))));\n\n/** @internal */\nconst whenEffect = /*#__PURE__*/dual(2, (self, effect) => pipe(fromEffect(effect), flatMap(bool => bool ? self : empty)));\n\n/** @internal */\nconst withSpan = /*#__PURE__*/dual(3, (self, name, options) => unwrapScoped(as$1(setSpan(name, options), self)));\n\n/** @internal */\nconst zip = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWith(that, (a, a2) => [a, a2])));\n\n/** @internal */\nconst zipFlatten = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWith(that, (a, a2) => [...a, a2])));\n\n/** @internal */\nconst zipAll = /*#__PURE__*/dual(2, (self, options) => zipAllWith(self, {\n  other: options.other,\n  onSelf: a => [a, options.defaultOther],\n  onOther: a2 => [options.defaultSelf, a2],\n  onBoth: (a, a2) => [a, a2]\n}));\n\n/** @internal */\nconst zipAllLeft = /*#__PURE__*/dual(3, (self, other, defaultSelf) => zipAllWith(self, {\n  other,\n  onSelf: identity,\n  onOther: () => defaultSelf,\n  onBoth: a => a\n}));\n\n/** @internal */\nconst zipAllRight = /*#__PURE__*/dual(3, (self, other, defaultRight) => zipAllWith(self, {\n  other,\n  onSelf: () => defaultRight,\n  onOther: identity,\n  onBoth: (_, a2) => a2\n}));\n\n/** @internal */\nconst zipAllSortedByKey = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {\n  other: options.other,\n  onSelf: a => [a, options.defaultOther],\n  onOther: a2 => [options.defaultSelf, a2],\n  onBoth: (a, a2) => [a, a2],\n  order: options.order\n}));\n\n/** @internal */\nconst zipAllSortedByKeyLeft = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {\n  other: options.other,\n  onSelf: identity,\n  onOther: () => options.defaultSelf,\n  onBoth: a => a,\n  order: options.order\n}));\n\n/** @internal */\nconst zipAllSortedByKeyRight = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {\n  other: options.other,\n  onSelf: () => options.defaultOther,\n  onOther: identity,\n  onBoth: (_, a2) => a2,\n  order: options.order\n}));\n\n/** @internal */\nconst zipAllSortedByKeyWith = /*#__PURE__*/dual(2, (self, options) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case OP_DRAIN_LEFT:\n        {\n          return pipe(pullLeft, match$1({\n            onFailure: fail$2,\n            onSuccess: leftChunk => succeed$4([map$2(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])\n          }));\n        }\n      case OP_DRAIN_RIGHT:\n        {\n          return pipe(pullRight, match$1({\n            onFailure: fail$2,\n            onSuccess: rightChunk => succeed$4([map$2(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])\n          }));\n        }\n      case OP_PULL_BOTH:\n        {\n          return pipe(unsome(pullLeft), zip$1(unsome(pullRight), {\n            concurrent: true\n          }), matchEffect({\n            onFailure: error => succeed$1(fail$2(some$1(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (isSome(leftOption) && isSome(rightOption)) {\n                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {\n                  return pull(PullBoth, pullLeft, pullRight);\n                }\n                if (isEmpty(leftOption.value)) {\n                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);\n                }\n                if (isEmpty(rightOption.value)) {\n                  return pull(PullRight(leftOption.value), pullLeft, pullRight);\n                }\n                return succeed$1(succeed$4(merge(leftOption.value, rightOption.value)));\n              }\n              if (isSome(leftOption) && isNone(rightOption)) {\n                if (isEmpty(leftOption.value)) {\n                  return pull(DrainLeft, pullLeft, pullRight);\n                }\n                return succeed$1(succeed$4([pipe(leftOption.value, map$2(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));\n              }\n              if (isNone(leftOption) && isSome(rightOption)) {\n                if (isEmpty(rightOption.value)) {\n                  return pull(DrainRight, pullLeft, pullRight);\n                }\n                return succeed$1(succeed$4([pipe(rightOption.value, map$2(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));\n              }\n              return succeed$1(fail$2(none()));\n            }\n          }));\n        }\n      case OP_PULL_LEFT:\n        {\n          return matchEffect(pullLeft, {\n            onFailure: match$2({\n              onNone: () => succeed$1(succeed$4([pipe(state.rightChunk, map$2(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),\n              onSome: error => succeed$1(fail$2(some$1(error)))\n            }),\n            onSuccess: leftChunk => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed$1(succeed$4(merge(leftChunk, state.rightChunk)))\n          });\n        }\n      case OP_PULL_RIGHT:\n        {\n          return matchEffect(pullRight, {\n            onFailure: match$2({\n              onNone: () => succeed$1(succeed$4([map$2(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),\n              onSome: error => succeed$1(fail$2(some$1(error)))\n            }),\n            onSuccess: rightChunk => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed$1(succeed$4(merge(state.leftChunk, rightChunk)))\n          });\n        }\n    }\n  };\n  const merge = (leftChunk, rightChunk) => {\n    const hasNext = (chunk, index) => index < chunk.length - 1;\n    const builder = [];\n    let state = undefined;\n    let leftIndex = 0;\n    let rightIndex = 0;\n    let leftTuple = pipe(leftChunk, unsafeGet$1(leftIndex));\n    let rightTuple = pipe(rightChunk, unsafeGet$1(rightIndex));\n    let k1 = leftTuple[0];\n    let a = leftTuple[1];\n    let k2 = rightTuple[0];\n    let a2 = rightTuple[1];\n    let loop = true;\n    while (loop) {\n      const compare = options.order(k1, k2);\n      if (compare === 0) {\n        builder.push([k1, options.onBoth(a, a2)]);\n        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {\n          leftIndex = leftIndex + 1;\n          rightIndex = rightIndex + 1;\n          leftTuple = pipe(leftChunk, unsafeGet$1(leftIndex));\n          rightTuple = pipe(rightChunk, unsafeGet$1(rightIndex));\n          k1 = leftTuple[0];\n          a = leftTuple[1];\n          k2 = rightTuple[0];\n          a2 = rightTuple[1];\n        } else if (hasNext(leftChunk, leftIndex)) {\n          state = PullRight(pipe(leftChunk, drop$1(leftIndex + 1)));\n          loop = false;\n        } else if (hasNext(rightChunk, rightIndex)) {\n          state = PullLeft(pipe(rightChunk, drop$1(rightIndex + 1)));\n          loop = false;\n        } else {\n          state = PullBoth;\n          loop = false;\n        }\n      } else if (compare < 0) {\n        builder.push([k1, options.onSelf(a)]);\n        if (hasNext(leftChunk, leftIndex)) {\n          leftIndex = leftIndex + 1;\n          leftTuple = pipe(leftChunk, unsafeGet$1(leftIndex));\n          k1 = leftTuple[0];\n          a = leftTuple[1];\n        } else {\n          const rightBuilder = [];\n          rightBuilder.push(rightTuple);\n          while (hasNext(rightChunk, rightIndex)) {\n            rightIndex = rightIndex + 1;\n            rightTuple = pipe(rightChunk, unsafeGet$1(rightIndex));\n            rightBuilder.push(rightTuple);\n          }\n          state = PullLeft(unsafeFromArray(rightBuilder));\n          loop = false;\n        }\n      } else {\n        builder.push([k2, options.onOther(a2)]);\n        if (hasNext(rightChunk, rightIndex)) {\n          rightIndex = rightIndex + 1;\n          rightTuple = pipe(rightChunk, unsafeGet$1(rightIndex));\n          k2 = rightTuple[0];\n          a2 = rightTuple[1];\n        } else {\n          const leftBuilder = [];\n          leftBuilder.push(leftTuple);\n          while (hasNext(leftChunk, leftIndex)) {\n            leftIndex = leftIndex + 1;\n            leftTuple = pipe(leftChunk, unsafeGet$1(leftIndex));\n            leftBuilder.push(leftTuple);\n          }\n          state = PullRight(unsafeFromArray(leftBuilder));\n          loop = false;\n        }\n      }\n    }\n    return [unsafeFromArray(builder), state];\n  };\n  return combineChunks(self, options.other, PullBoth, pull);\n});\n\n/** @internal */\nconst zipAllWith = /*#__PURE__*/dual(2, (self, options) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case OP_DRAIN_LEFT:\n        {\n          return matchEffect(pullLeft, {\n            onFailure: error => succeed$1(fail$2(error)),\n            onSuccess: leftChunk => succeed$1(succeed$4([map$2(leftChunk, options.onSelf), DrainLeft]))\n          });\n        }\n      case OP_DRAIN_RIGHT:\n        {\n          return matchEffect(pullRight, {\n            onFailure: error => succeed$1(fail$2(error)),\n            onSuccess: rightChunk => succeed$1(succeed$4([map$2(rightChunk, options.onOther), DrainRight]))\n          });\n        }\n      case OP_PULL_BOTH:\n        {\n          return pipe(unsome(pullLeft), zip$1(unsome(pullRight), {\n            concurrent: true\n          }), matchEffect({\n            onFailure: error => succeed$1(fail$2(some$1(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (isSome(leftOption) && isSome(rightOption)) {\n                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {\n                  return pull(PullBoth, pullLeft, pullRight);\n                }\n                if (isEmpty(leftOption.value)) {\n                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);\n                }\n                if (isEmpty(rightOption.value)) {\n                  return pull(PullRight(leftOption.value), pullLeft, pullRight);\n                }\n                return succeed$1(succeed$4(zip(leftOption.value, rightOption.value, options.onBoth)));\n              }\n              if (isSome(leftOption) && isNone(rightOption)) {\n                return succeed$1(succeed$4([map$2(leftOption.value, options.onSelf), DrainLeft]));\n              }\n              if (isNone(leftOption) && isSome(rightOption)) {\n                return succeed$1(succeed$4([map$2(rightOption.value, options.onOther), DrainRight]));\n              }\n              return succeed$1(fail$2(none()));\n            }\n          }));\n        }\n      case OP_PULL_LEFT:\n        {\n          return matchEffect(pullLeft, {\n            onFailure: match$2({\n              onNone: () => succeed$1(succeed$4([map$2(state.rightChunk, options.onOther), DrainRight])),\n              onSome: error => succeed$1(fail$2(some$1(error)))\n            }),\n            onSuccess: leftChunk => {\n              if (isEmpty(leftChunk)) {\n                return pull(PullLeft(state.rightChunk), pullLeft, pullRight);\n              }\n              if (isEmpty(state.rightChunk)) {\n                return pull(PullRight(leftChunk), pullLeft, pullRight);\n              }\n              return succeed$1(succeed$4(zip(leftChunk, state.rightChunk, options.onBoth)));\n            }\n          });\n        }\n      case OP_PULL_RIGHT:\n        {\n          return matchEffect(pullRight, {\n            onFailure: match$2({\n              onNone: () => succeed$1(succeed$4([map$2(state.leftChunk, options.onSelf), DrainLeft])),\n              onSome: error => succeed$1(fail$2(some$1(error)))\n            }),\n            onSuccess: rightChunk => {\n              if (isEmpty(rightChunk)) {\n                return pull(PullRight(state.leftChunk), pullLeft, pullRight);\n              }\n              if (isEmpty(state.leftChunk)) {\n                return pull(PullLeft(rightChunk), pullLeft, pullRight);\n              }\n              return succeed$1(succeed$4(zip(state.leftChunk, rightChunk, options.onBoth)));\n            }\n          });\n        }\n    }\n  };\n  const zip = (leftChunk, rightChunk, f) => {\n    const [output, either] = zipChunks(leftChunk, rightChunk, f);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          if (isEmpty(either.left)) {\n            return [output, PullBoth];\n          }\n          return [output, PullRight(either.left)];\n        }\n      case \"Right\":\n        {\n          if (isEmpty(either.right)) {\n            return [output, PullBoth];\n          }\n          return [output, PullLeft(either.right)];\n        }\n    }\n  };\n  return combineChunks(self, options.other, PullBoth, pull);\n});\n\n/** @internal */\nconst zipLatest = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipLatestWith(that, (a, a2) => [a, a2])));\n\n/** @internal */\nconst zipLatestWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const pullNonEmpty = pull => pipe(pull, flatMap$2(chunk => isEmpty(chunk) ? pullNonEmpty(pull) : succeed$1(chunk)));\n  return pipe(toPull(self), map$1(pullNonEmpty), zip$1(pipe(toPull(that), map$1(pullNonEmpty))), flatMap$2(([left, right]) => pipe(fromEffectOption(raceWith(left, right, {\n    onSelfDone: (leftDone, rightFiber) => pipe(suspend$1(() => leftDone), zipWith$1(join(rightFiber), (l, r) => [l, r, true])),\n    onOtherDone: (rightDone, leftFiber) => pipe(suspend$1(() => rightDone), zipWith$1(join(leftFiber), (l, r) => [r, l, false]))\n  })), flatMap(([l, r, leftFirst]) => pipe(fromEffect(make$2([unsafeLast(l), unsafeLast(r)])), flatMap(latest => pipe(fromChunk(leftFirst ? pipe(r, map$2(a2 => f(unsafeLast(l), a2))) : pipe(l, map$2(a => f(a, unsafeLast(r))))), concat(pipe(repeatEffectOption(left), mergeEither(repeatEffectOption(right)), mapEffectSequential(match({\n    onLeft: leftChunk => pipe(modify(latest, ([_, rightLatest]) => [pipe(leftChunk, map$2(a => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),\n    onRight: rightChunk => pipe(modify(latest, ([leftLatest, _]) => [pipe(rightChunk, map$2(a2 => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))\n  })), flatMap(fromChunk))))))), toPull)), fromPull);\n});\n\n/** @internal */\nconst zipLeft = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWithChunks(that, (left$1, right$1) => {\n  if (left$1.length > right$1.length) {\n    return [pipe(left$1, take$3(right$1.length)), left(pipe(left$1, take$3(right$1.length)))];\n  }\n  return [left$1, right(pipe(right$1, drop$1(left$1.length)))];\n})));\n\n/** @internal */\nconst zipRight = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWithChunks(that, (left$1, right$1) => {\n  if (left$1.length > right$1.length) {\n    return [right$1, left(pipe(left$1, take$3(right$1.length)))];\n  }\n  return [pipe(right$1, take$3(left$1.length)), right(pipe(right$1, drop$1(left$1.length)))];\n})));\n\n/** @internal */\nconst zipWith = /*#__PURE__*/dual(3, (self, that, f) => pipe(self, zipWithChunks(that, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));\n\n/** @internal */\nconst zipWithChunks = /*#__PURE__*/dual(3, (self, that, f) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case OP_PULL_BOTH$1:\n        {\n          return pipe(unsome(pullLeft), zip$1(unsome(pullRight), {\n            concurrent: true\n          }), matchEffect({\n            onFailure: error => succeed$1(fail$2(some$1(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (isSome(leftOption) && isSome(rightOption)) {\n                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {\n                  return pull(PullBoth$1, pullLeft, pullRight);\n                }\n                if (isEmpty(leftOption.value)) {\n                  return pull(PullLeft$1(rightOption.value), pullLeft, pullRight);\n                }\n                if (isEmpty(rightOption.value)) {\n                  return pull(PullRight$1(leftOption.value), pullLeft, pullRight);\n                }\n                return succeed$1(succeed$4(zip(leftOption.value, rightOption.value)));\n              }\n              return succeed$1(fail$2(none()));\n            }\n          }));\n        }\n      case OP_PULL_LEFT$1:\n        {\n          return matchEffect(pullLeft, {\n            onFailure: error => succeed$1(fail$2(error)),\n            onSuccess: leftChunk => {\n              if (isEmpty(leftChunk)) {\n                return pull(PullLeft$1(state.rightChunk), pullLeft, pullRight);\n              }\n              if (isEmpty(state.rightChunk)) {\n                return pull(PullRight$1(leftChunk), pullLeft, pullRight);\n              }\n              return succeed$1(succeed$4(zip(leftChunk, state.rightChunk)));\n            }\n          });\n        }\n      case OP_PULL_RIGHT$1:\n        {\n          return matchEffect(pullRight, {\n            onFailure: error => succeed$1(fail$2(error)),\n            onSuccess: rightChunk => {\n              if (isEmpty(rightChunk)) {\n                return pull(PullRight$1(state.leftChunk), pullLeft, pullRight);\n              }\n              if (isEmpty(state.leftChunk)) {\n                return pull(PullLeft$1(rightChunk), pullLeft, pullRight);\n              }\n              return succeed$1(succeed$4(zip(state.leftChunk, rightChunk)));\n            }\n          });\n        }\n    }\n  };\n  const zip = (leftChunk, rightChunk) => {\n    const [output, either] = f(leftChunk, rightChunk);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          if (isEmpty(either.left)) {\n            return [output, PullBoth$1];\n          }\n          return [output, PullRight$1(either.left)];\n        }\n      case \"Right\":\n        {\n          if (isEmpty(either.right)) {\n            return [output, PullBoth$1];\n          }\n          return [output, PullLeft$1(either.right)];\n        }\n    }\n  };\n  return pipe(self, combineChunks(that, PullBoth$1, pull));\n});\n\n/** @internal */\nconst zipWithIndex = self => pipe(self, mapAccum(0, (index, a) => [index + 1, [a, index]]));\n\n/** @internal */\nconst zipWithNext = self => {\n  const process = last => readWithCause({\n    onInput: input => {\n      const [newLast, chunk] = mapAccum$1(input, last, (prev, curr) => [some$1(curr), pipe(prev, map$4(a => [a, curr]))]);\n      const output = filterMap$1(chunk, option => isSome(option) ? some$1([option.value[0], some$1(option.value[1])]) : none());\n      return flatMap$1(write(output), () => process(newLast));\n    },\n    onFailure: failCause$1,\n    onDone: () => match$2(last, {\n      onNone: () => unit$1,\n      onSome: value => zipRight$2(write(of([value, none()])), unit$1)\n    })\n  });\n  return new StreamImpl(pipe(toChannel(self), pipeToOrFail(process(none()))));\n};\n\n/** @internal */\nconst zipWithPrevious = self => pipe(self, mapAccum(none(), (prev, curr) => [some$1(curr), [prev, curr]]));\n\n/** @internal */\nconst zipWithPreviousAndNext = self => pipe(zipWithNext(zipWithPrevious(self)), map(([[prev, curr], next]) => [prev, curr, pipe(next, map$4(tuple => tuple[1]))]));\n\n/** @internal */\nconst zipChunks = (left$1, right$1, f) => {\n  if (left$1.length > right$1.length) {\n    return [pipe(left$1, take$3(right$1.length), zipWith$2(right$1, f)), left(pipe(left$1, drop$1(right$1.length)))];\n  }\n  return [pipe(left$1, zipWith$2(pipe(right$1, take$3(left$1.length)), f)), right(pipe(right$1, drop$1(left$1.length)))];\n};\n\n// Do notation\n\n/** @internal */\nconst Do = /*#__PURE__*/succeed({});\n\n/** @internal */\nconst bind = /*#__PURE__*/dual(args => typeof args[0] !== \"string\", (self, tag, f, options) => flatMap(self, k => map(f(k), a => ({\n  ...k,\n  [tag]: a\n})), options));\n\n/* @internal */\nconst bindTo = /*#__PURE__*/dual(2, (self, tag) => map(self, a => ({\n  [tag]: a\n})));\n\n/* @internal */\nconst let_ = /*#__PURE__*/dual(3, (self, tag, f) => map(self, k => ({\n  ...k,\n  [tag]: f(k)\n})));\n\n// Circular with Channel\n\n/** @internal */\nconst channelToStream = self => {\n  return new StreamImpl(self);\n};\n\n// =============================================================================\n// encoding\n// =============================================================================\n\n/** @internal */\nconst decodeText = /*#__PURE__*/dual(args => isStream(args[0]), (self, encoding = \"utf-8\") => suspend(() => {\n  const decoder = new TextDecoder(encoding);\n  return map(self, s => decoder.decode(s));\n}));\n\n/** @internal */\nconst encodeText = self => suspend(() => {\n  const encoder = new TextEncoder();\n  return map(self, s => encoder.encode(s));\n});\n\nexport { DefaultChunkSize, Do, StreamImpl, StreamTypeId, _async, acquireRelease, aggregate, aggregateWithin, aggregateWithinEither, as, asyncEffect, asyncInterrupt, asyncOption, asyncScoped, bind, bindTo, branchAfter, broadcast, broadcastDynamic, broadcastedQueues, broadcastedQueuesDynamic, buffer, bufferChunks, catchAll, catchAllCause, catchSome, catchSomeCause, catchTag, catchTags, changes, changesWith, changesWithEffect, channelToStream, chunks, chunksWith, combine, combineChunks, concat, concatAll, context, contextWith, contextWithEffect, contextWithStream, cross, crossLeft, crossRight, crossWith, debounce, decodeText, die, dieMessage, dieSync, distributedWith, distributedWithDynamic, distributedWithDynamicCallback, drain, drainFork, drop, dropRight, dropUntil, dropUntilEffect, dropWhile, dropWhileEffect, either, empty, encodeText, ensuring, ensuringWith, execute, fail, failCause, failCauseSync, failSync, filter, filterEffect, filterMap, filterMapEffect, filterMapWhile, filterMapWhileEffect, finalizer, find, findEffect, flatMap, flatten, flattenChunks, flattenEffect, flattenExitOption, flattenIterables, flattenTake, forever, fromAsyncIterable, fromChannel, fromChunk, fromChunkPubSub, fromChunkQueue, fromChunks, fromEffect, fromEffectOption, fromIterable, fromIterableEffect, fromIteratorSucceed, fromPubSub, fromPull, fromQueue, fromReadableStream, fromReadableStreamByob, fromSchedule, groupAdjacentBy, grouped, groupedWithin, haltAfter, haltWhen, haltWhenDeferred, identityStream, interleave, interleaveWith, interruptAfter, interruptWhen, interruptWhenDeferred, intersperse, intersperseAffixes, isStream, iterate, let_, make, map, mapAccum, mapAccumEffect, mapBoth, mapChunks, mapChunksEffect, mapConcat, mapConcatChunk, mapConcatChunkEffect, mapConcatEffect, mapEffectPar, mapEffectSequential, mapError, mapErrorCause, mapInputContext, matchConcurrency, merge, mergeAll, mergeEither, mergeLeft, mergeRight, mergeWith, mkString, never, onDone, onError, orDie, orDieWith, orElse, orElseEither, orElseFail, orElseIfEmpty, orElseIfEmptyChunk, orElseIfEmptyStream, orElseSucceed, paginate, paginateChunk, paginateChunkEffect, paginateEffect, partition, partitionEither, peel, pipeThrough, pipeThroughChannel, pipeThroughChannelOrFail, prepend, provideContext, provideLayer, provideService, provideServiceEffect, provideServiceStream, provideSomeLayer, range, rechunk, refineOrDie, refineOrDieWith, repeat, repeatEffect, repeatEffectChunk, repeatEffectChunkOption, repeatEffectOption, repeatEffectWithSchedule, repeatEither, repeatElements, repeatElementsWith, repeatValue, repeatWith, repeatWithSchedule, retry, run, runCollect, runCount, runDrain, runFold, runFoldEffect, runFoldScoped, runFoldScopedEffect, runFoldWhile, runFoldWhileEffect, runFoldWhileScoped, runFoldWhileScopedEffect, runForEach, runForEachChunk, runForEachChunkScoped, runForEachScoped, runForEachWhile, runForEachWhileScoped, runHead, runIntoPubSub, runIntoPubSubScoped, runIntoQueue, runIntoQueueElementsScoped, runIntoQueueScoped, runLast, runScoped, runSum, scan, scanEffect, scanReduce, scanReduceEffect, schedule, scheduleWith, scoped, sliding, slidingSize, some, someOrElse, someOrFail, split, splitLines, splitOnChunk, succeed, suspend, sync, take, takeRight, takeUntil, takeUntilEffect, takeWhile, tap, tapBoth, tapError, tapErrorCause, tapSink, throttle, throttleEffect, tick, timeout, timeoutFail, timeoutFailCause, timeoutTo, toChannel, toPubSub, toPull, toQueue, toQueueOfElements, toReadableStream, transduce, unfold, unfoldChunk, unfoldChunkEffect, unfoldEffect, unit, unwrap, unwrapScoped, updateService, when, whenCase, whenCaseEffect, whenEffect, withSpan, zip, zipAll, zipAllLeft, zipAllRight, zipAllSortedByKey, zipAllSortedByKeyLeft, zipAllSortedByKeyRight, zipAllSortedByKeyWith, zipAllWith, zipFlatten, zipLatest, zipLatestWith, zipLeft, zipRight, zipWith, zipWithChunks, zipWithIndex, zipWithNext, zipWithPrevious, zipWithPreviousAndNext };\n","import { groupBy as groupBy$1, groupByKey as groupByKey$1, mapEffectOptions, bindEffect as bindEffect$1 } from '../../internal/groupBy.esm.js';\nimport { StreamTypeId as StreamTypeId$1, DefaultChunkSize as DefaultChunkSize$1, acquireRelease as acquireRelease$1, aggregate as aggregate$1, aggregateWithin as aggregateWithin$1, aggregateWithinEither as aggregateWithinEither$1, as as as$1, _async as _async$1, asyncEffect as asyncEffect$1, asyncInterrupt as asyncInterrupt$1, asyncOption as asyncOption$1, asyncScoped as asyncScoped$1, branchAfter as branchAfter$1, broadcast as broadcast$1, broadcastDynamic as broadcastDynamic$1, broadcastedQueues as broadcastedQueues$1, broadcastedQueuesDynamic as broadcastedQueuesDynamic$1, buffer as buffer$1, bufferChunks as bufferChunks$1, catchAll as catchAll$1, catchAllCause as catchAllCause$1, catchSome as catchSome$1, catchTag as catchTag$1, catchTags as catchTags$1, catchSomeCause as catchSomeCause$1, changes as changes$1, changesWith as changesWith$1, changesWithEffect as changesWithEffect$1, chunks as chunks$1, chunksWith as chunksWith$1, combine as combine$1, combineChunks as combineChunks$1, concat as concat$1, concatAll as concatAll$1, cross as cross$1, crossLeft as crossLeft$1, crossRight as crossRight$1, crossWith as crossWith$1, debounce as debounce$1, die as die$1, dieSync as dieSync$1, dieMessage as dieMessage$1, distributedWith as distributedWith$1, distributedWithDynamic as distributedWithDynamic$1, drain as drain$1, drainFork as drainFork$1, drop as drop$1, dropRight as dropRight$1, dropUntil as dropUntil$1, dropUntilEffect as dropUntilEffect$1, dropWhile as dropWhile$1, dropWhileEffect as dropWhileEffect$1, either as either$1, empty as empty$1, ensuring as ensuring$1, ensuringWith as ensuringWith$1, context as context$1, contextWith as contextWith$1, contextWithEffect as contextWithEffect$1, contextWithStream as contextWithStream$1, execute as execute$1, fail as fail$1, failSync as failSync$1, failCause as failCause$1, failCauseSync as failCauseSync$1, filter as filter$1, filterEffect as filterEffect$1, filterMap as filterMap$1, filterMapEffect as filterMapEffect$1, filterMapWhile as filterMapWhile$1, filterMapWhileEffect as filterMapWhileEffect$1, finalizer as finalizer$1, find as find$1, findEffect as findEffect$1, flatMap as flatMap$1, flatten as flatten$1, flattenChunks as flattenChunks$1, flattenEffect as flattenEffect$1, flattenExitOption as flattenExitOption$1, flattenIterables as flattenIterables$1, flattenTake as flattenTake$1, forever as forever$1, fromAsyncIterable as fromAsyncIterable$1, fromChannel as fromChannel$1, toChannel as toChannel$1, fromChunk as fromChunk$1, fromChunkPubSub as fromChunkPubSub$1, fromChunkQueue as fromChunkQueue$1, fromChunks as fromChunks$1, fromEffect as fromEffect$1, fromEffectOption as fromEffectOption$1, fromPubSub as fromPubSub$1, fromIterable as fromIterable$1, fromIterableEffect as fromIterableEffect$1, fromIteratorSucceed as fromIteratorSucceed$1, fromPull as fromPull$1, fromQueue as fromQueue$1, fromReadableStream as fromReadableStream$1, fromReadableStreamByob as fromReadableStreamByob$1, fromSchedule as fromSchedule$1, groupAdjacentBy as groupAdjacentBy$1, grouped as grouped$1, groupedWithin as groupedWithin$1, haltAfter as haltAfter$1, haltWhen as haltWhen$1, haltWhenDeferred as haltWhenDeferred$1, identityStream, interleave as interleave$1, interleaveWith as interleaveWith$1, intersperse as intersperse$1, intersperseAffixes as intersperseAffixes$1, interruptAfter as interruptAfter$1, interruptWhen as interruptWhen$1, interruptWhenDeferred as interruptWhenDeferred$1, iterate as iterate$1, make as make$1, map as map$1, mapAccum as mapAccum$1, mapAccumEffect as mapAccumEffect$1, mapBoth as mapBoth$1, mapChunks as mapChunks$1, mapChunksEffect as mapChunksEffect$1, mapConcat as mapConcat$1, mapConcatChunk as mapConcatChunk$1, mapConcatChunkEffect as mapConcatChunkEffect$1, mapConcatEffect as mapConcatEffect$1, mapError as mapError$1, mapErrorCause as mapErrorCause$1, merge as merge$1, mergeAll as mergeAll$1, mergeWith as mergeWith$1, mergeEither as mergeEither$1, mergeLeft as mergeLeft$1, mergeRight as mergeRight$1, mkString as mkString$1, never as never$1, onError as onError$1, onDone as onDone$1, orDie as orDie$1, orDieWith as orDieWith$1, orElse as orElse$1, orElseEither as orElseEither$1, orElseFail as orElseFail$1, orElseIfEmpty as orElseIfEmpty$1, orElseIfEmptyChunk as orElseIfEmptyChunk$1, orElseIfEmptyStream as orElseIfEmptyStream$1, orElseSucceed as orElseSucceed$1, paginate as paginate$1, paginateChunk as paginateChunk$1, paginateChunkEffect as paginateChunkEffect$1, paginateEffect as paginateEffect$1, partition as partition$1, partitionEither as partitionEither$1, peel as peel$1, pipeThrough as pipeThrough$1, pipeThroughChannel as pipeThroughChannel$1, pipeThroughChannelOrFail as pipeThroughChannelOrFail$1, prepend as prepend$1, provideContext as provideContext$1, provideLayer as provideLayer$1, provideService as provideService$1, provideServiceEffect as provideServiceEffect$1, provideServiceStream as provideServiceStream$1, mapInputContext as mapInputContext$1, provideSomeLayer as provideSomeLayer$1, range as range$1, rechunk as rechunk$1, refineOrDie as refineOrDie$1, refineOrDieWith as refineOrDieWith$1, repeat as repeat$1, repeatEffect as repeatEffect$1, repeatEffectChunk as repeatEffectChunk$1, repeatEffectChunkOption as repeatEffectChunkOption$1, repeatEffectOption as repeatEffectOption$1, repeatEffectWithSchedule as repeatEffectWithSchedule$1, repeatEither as repeatEither$1, repeatElements as repeatElements$1, repeatElementsWith as repeatElementsWith$1, repeatValue as repeatValue$1, repeatWith as repeatWith$1, retry as retry$1, run as run$1, runCollect as runCollect$1, runCount as runCount$1, runDrain as runDrain$1, runFold as runFold$1, runFoldEffect as runFoldEffect$1, runFoldScoped as runFoldScoped$1, runFoldScopedEffect as runFoldScopedEffect$1, runFoldWhile as runFoldWhile$1, runFoldWhileEffect as runFoldWhileEffect$1, runFoldWhileScoped as runFoldWhileScoped$1, runFoldWhileScopedEffect as runFoldWhileScopedEffect$1, runForEach as runForEach$1, runForEachChunk as runForEachChunk$1, runForEachChunkScoped as runForEachChunkScoped$1, runForEachScoped as runForEachScoped$1, runForEachWhile as runForEachWhile$1, runForEachWhileScoped as runForEachWhileScoped$1, runHead as runHead$1, runIntoPubSub as runIntoPubSub$1, runIntoPubSubScoped as runIntoPubSubScoped$1, runIntoQueue as runIntoQueue$1, runIntoQueueElementsScoped as runIntoQueueElementsScoped$1, runIntoQueueScoped as runIntoQueueScoped$1, runLast as runLast$1, runScoped as runScoped$1, runSum as runSum$1, scan as scan$1, scanEffect as scanEffect$1, scanReduce as scanReduce$1, scanReduceEffect as scanReduceEffect$1, schedule as schedule$1, scheduleWith as scheduleWith$1, scoped as scoped$1, sliding as sliding$1, slidingSize as slidingSize$1, some as some$1, someOrElse as someOrElse$1, someOrFail as someOrFail$1, split as split$1, splitOnChunk as splitOnChunk$1, splitLines as splitLines$1, succeed as succeed$1, sync as sync$1, suspend as suspend$1, take as take$1, takeRight as takeRight$1, takeUntil as takeUntil$1, takeUntilEffect as takeUntilEffect$1, takeWhile as takeWhile$1, tap as tap$1, tapBoth as tapBoth$1, tapError as tapError$1, tapErrorCause as tapErrorCause$1, tapSink as tapSink$1, throttle as throttle$1, throttleEffect as throttleEffect$1, tick as tick$1, timeout as timeout$1, timeoutFail as timeoutFail$1, timeoutFailCause as timeoutFailCause$1, timeoutTo as timeoutTo$1, toPubSub as toPubSub$1, toPull as toPull$1, toQueue as toQueue$1, toQueueOfElements as toQueueOfElements$1, toReadableStream as toReadableStream$1, transduce as transduce$1, unfold as unfold$1, unfoldChunk as unfoldChunk$1, unfoldChunkEffect as unfoldChunkEffect$1, unfoldEffect as unfoldEffect$1, unit as unit$1, unwrap as unwrap$1, unwrapScoped as unwrapScoped$1, updateService as updateService$1, when as when$1, whenCase as whenCase$1, whenCaseEffect as whenCaseEffect$1, whenEffect as whenEffect$1, withSpan as withSpan$1, zip as zip$1, zipFlatten as zipFlatten$1, zipAll as zipAll$1, zipAllLeft as zipAllLeft$1, zipAllRight as zipAllRight$1, zipAllSortedByKey as zipAllSortedByKey$1, zipAllSortedByKeyLeft as zipAllSortedByKeyLeft$1, zipAllSortedByKeyRight as zipAllSortedByKeyRight$1, zipAllSortedByKeyWith as zipAllSortedByKeyWith$1, zipAllWith as zipAllWith$1, zipLatest as zipLatest$1, zipLatestWith as zipLatestWith$1, zipLeft as zipLeft$1, zipRight as zipRight$1, zipWith as zipWith$1, zipWithChunks as zipWithChunks$1, zipWithNext as zipWithNext$1, zipWithPrevious as zipWithPrevious$1, zipWithPreviousAndNext as zipWithPreviousAndNext$1, zipWithIndex as zipWithIndex$1, Do as Do$1, bind as bind$1, bindTo as bindTo$1, let_ as let_$1, decodeText as decodeText$1, encodeText as encodeText$1 } from '../../internal/stream.esm.js';\n\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst StreamTypeId = StreamTypeId$1;\n\n/**\n * @since 2.0.0\n * @category symbols\n */\n\n/**\n * A `Stream<R, E, A>` is a description of a program that, when evaluated, may\n * emit zero or more values of type `A`, may fail with errors of type `E`, and\n * uses an context of type `R`. One way to think of `Stream` is as a\n * `Effect` program that could emit multiple values.\n *\n * `Stream` is a purely functional *pull* based stream. Pull based streams offer\n * inherent laziness and backpressure, relieving users of the need to manage\n * buffers between operators. As an optimization, `Stream` does not emit\n * single values, but rather an array of values. This allows the cost of effect\n * evaluation to be amortized.\n *\n * `Stream` forms a monad on its `A` type parameter, and has error management\n * facilities for its `E` type parameter, modeled similarly to `Effect` (with\n * some adjustments for the multiple-valued nature of `Stream`). These aspects\n * allow for rich and expressive composition of streams.\n *\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @category models\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category models\n */\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n */\n\n/**\n * The default chunk size used by the various combinators and constructors of\n * `Stream`.\n *\n * @since 2.0.0\n * @category constants\n */\nconst DefaultChunkSize = DefaultChunkSize$1;\n\n/**\n * Creates a stream from a single value that will get cleaned up after the\n * stream is consumed.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst acquireRelease = acquireRelease$1;\n\n/**\n * Aggregates elements of this stream using the provided sink for as long as\n * the downstream operators on the stream are busy.\n *\n * This operator divides the stream into two asynchronous \"islands\". Operators\n * upstream of this operator run on one fiber, while downstream operators run\n * on another. Whenever the downstream fiber is busy processing elements, the\n * upstream fiber will feed elements into the sink until it signals\n * completion.\n *\n * Any sink can be used here, but see `Sink.foldWeightedEffect` and\n * `Sink.foldUntilEffect` for sinks that cover the common usecases.\n *\n * @since 2.0.0\n * @category utils\n */\nconst aggregate = aggregate$1;\n\n/**\n * Like `aggregateWithinEither`, but only returns the `Right` results.\n *\n * @param sink A `Sink` used to perform the aggregation.\n * @param schedule A `Schedule` used to signal when to stop the aggregation.\n * @since 2.0.0\n * @category utils\n */\nconst aggregateWithin = aggregateWithin$1;\n\n/**\n * Aggregates elements using the provided sink until it completes, or until\n * the delay signalled by the schedule has passed.\n *\n * This operator divides the stream into two asynchronous islands. Operators\n * upstream of this operator run on one fiber, while downstream operators run\n * on another. Elements will be aggregated by the sink until the downstream\n * fiber pulls the aggregated value, or until the schedule's delay has passed.\n *\n * Aggregated elements will be fed into the schedule to determine the delays\n * between pulls.\n *\n * @param sink A `Sink` used to perform the aggregation.\n * @param schedule A `Schedule` used to signal when to stop the aggregation.\n * @since 2.0.0\n * @category utils\n */\nconst aggregateWithinEither = aggregateWithinEither$1;\n\n/**\n * Maps the success values of this stream to the specified constant value.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst as = as$1;\nconst _async = _async$1;\n\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times The registration of the callback itself returns an effect. The\n * optionality of the error type `E` can be used to signal the end of the\n * stream, by setting it to `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncEffect = asyncEffect$1;\n\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times. The registration of the callback returns either a canceler or\n * synchronously returns a stream. The optionality of the error type `E` can\n * be used to signal the end of the stream, by setting it to `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncInterrupt = asyncInterrupt$1;\n\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times. The registration of the callback can possibly return the stream\n * synchronously. The optionality of the error type `E` can be used to signal\n * the end of the stream, by setting it to `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncOption = asyncOption$1;\n\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times. The registration of the callback itself returns an a scoped\n * resource. The optionality of the error type `E` can be used to signal the\n * end of the stream, by setting it to `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst asyncScoped = asyncScoped$1;\n\n/**\n * Returns a `Stream` that first collects `n` elements from the input `Stream`,\n * and then creates a new `Stream` using the specified function, and sends all\n * the following elements through that.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst branchAfter = branchAfter$1;\n\n/**\n * Fan out the stream, producing a list of streams that have the same elements\n * as this stream. The driver stream will only ever advance the `maximumLag`\n * chunks before the slowest downstream stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst broadcast = broadcast$1;\n\n/**\n * Fan out the stream, producing a dynamic number of streams that have the\n * same elements as this stream. The driver stream will only ever advance the\n * `maximumLag` chunks before the slowest downstream stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst broadcastDynamic = broadcastDynamic$1;\n\n/**\n * Converts the stream to a scoped list of queues. Every value will be\n * replicated to every queue with the slowest queue being allowed to buffer\n * `maximumLag` chunks before the driver is back pressured.\n *\n * Queues can unsubscribe from upstream by shutting down.\n *\n * @since 2.0.0\n * @category utils\n */\nconst broadcastedQueues = broadcastedQueues$1;\n\n/**\n * Converts the stream to a scoped dynamic amount of queues. Every chunk will\n * be replicated to every queue with the slowest queue being allowed to buffer\n * `maximumLag` chunks before the driver is back pressured.\n *\n * Queues can unsubscribe from upstream by shutting down.\n *\n * @since 2.0.0\n * @category utils\n */\nconst broadcastedQueuesDynamic = broadcastedQueuesDynamic$1;\n\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` elements in a queue.\n *\n * @note This combinator destroys the chunking structure. It's recommended to\n *       use rechunk afterwards. Additionally, prefer capacities that are powers\n *       of 2 for better performance.\n * @since 2.0.0\n * @category utils\n */\nconst buffer = buffer$1;\n\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` chunks in a queue.\n *\n * @note Prefer capacities that are powers of 2 for better performance.\n * @since 2.0.0\n * @category utils\n */\nconst bufferChunks = bufferChunks$1;\n\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with a typed error.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAll = catchAll$1;\n\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails. Allows recovery from all causes of failure, including\n * interruption if the stream is uninterruptible.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchAllCause = catchAllCause$1;\n\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with some typed error.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchSome = catchSome$1;\n\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with an error matching the given `_tag`.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchTag = catchTag$1;\n\n/**\n * Switches over to the stream produced by one of the provided functions, in\n * case this one fails with an error matching one of the given `_tag`'s.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchTags = catchTags$1;\n\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with some errors. Allows recovery from all causes of failure,\n * including interruption if the stream is uninterruptible.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst catchSomeCause = catchSomeCause$1;\n\n/**\n * Returns a new stream that only emits elements that are not equal to the\n * previous element emitted, using natural equality to determine whether two\n * elements are equal.\n *\n * @since 2.0.0\n * @category utils\n */\nconst changes = changes$1;\n\n/**\n * Returns a new stream that only emits elements that are not equal to the\n * previous element emitted, using the specified function to determine whether\n * two elements are equal.\n *\n * @since 2.0.0\n * @category utils\n */\nconst changesWith = changesWith$1;\n\n/**\n * Returns a new stream that only emits elements that are not equal to the\n * previous element emitted, using the specified effectual function to\n * determine whether two elements are equal.\n *\n * @since 2.0.0\n * @category utils\n */\nconst changesWithEffect = changesWithEffect$1;\n\n/**\n * Exposes the underlying chunks of the stream as a stream of chunks of\n * elements.\n *\n * @since 2.0.0\n * @category utils\n */\nconst chunks = chunks$1;\n\n/**\n * Performs the specified stream transformation with the chunk structure of\n * the stream exposed.\n *\n * @since 2.0.0\n * @category utils\n */\nconst chunksWith = chunksWith$1;\n\n/**\n * Combines the elements from this stream and the specified stream by\n * repeatedly applying the function `f` to extract an element using both sides\n * and conceptually \"offer\" it to the destination stream. `f` can maintain\n * some internal state to control the combining process, with the initial\n * state being specified by `s`.\n *\n * Where possible, prefer `Stream.combineChunks` for a more efficient\n * implementation.\n *\n * @since 2.0.0\n * @category utils\n */\nconst combine = combine$1;\n\n/**\n * Combines the chunks from this stream and the specified stream by repeatedly\n * applying the function `f` to extract a chunk using both sides and\n * conceptually \"offer\" it to the destination stream. `f` can maintain some\n * internal state to control the combining process, with the initial state\n * being specified by `s`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst combineChunks = combineChunks$1;\n\n/**\n * Concatenates the specified stream with this stream, resulting in a stream\n * that emits the elements from this stream and then the elements from the\n * specified stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst concat = concat$1;\n\n/**\n * Concatenates all of the streams in the chunk to one stream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst concatAll = concatAll$1;\n\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements. The `that` stream would be run multiple times, for\n * every element in the `this` stream.\n *\n * See also `Stream.zip` for the more common point-wise variant.\n *\n * @since 2.0.0\n * @category utils\n */\nconst cross = cross$1;\n\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements, but keeps only elements from this stream. The `that`\n * stream would be run multiple times, for every element in the `this` stream.\n *\n * See also `Stream.zipLeft` for the more common point-wise variant.\n *\n * @since 2.0.0\n * @category utils\n */\nconst crossLeft = crossLeft$1;\n\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements, but keeps only elements from the other stream. The\n * `that` stream would be run multiple times, for every element in the `this`\n * stream.\n *\n * See also `Stream.zipRight` for the more common point-wise variant.\n *\n * @since 2.0.0\n * @category utils\n */\nconst crossRight = crossRight$1;\n\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements with a specified function. The `that` stream would be\n * run multiple times, for every element in the `this` stream.\n *\n * See also `Stream.zipWith` for the more common point-wise variant.\n *\n * @since 2.0.0\n * @category utils\n */\nconst crossWith = crossWith$1;\n\n/**\n * Delays the emission of values by holding new values for a set duration. If\n * no new values arrive during that time the value is emitted, however if a\n * new value is received during the holding period the previous value is\n * discarded and the process is repeated with the new value.\n *\n * This operator is useful if you have a stream of \"bursty\" events which\n * eventually settle down and you only need the final event of the burst. For\n * example, a search engine may only want to initiate a search after a user\n * has paused typing so as to not prematurely recommend results.\n *\n * @since 2.0.0\n * @category utils\n */\nconst debounce = debounce$1;\n\n/**\n * The stream that dies with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst die = die$1;\n\n/**\n * The stream that dies with the specified lazily evaluated defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst dieSync = dieSync$1;\n\n/**\n * The stream that dies with an exception described by `message`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst dieMessage = dieMessage$1;\n\n/**\n * More powerful version of `Stream.broadcast`. Allows to provide a function\n * that determines what queues should receive which elements. The decide\n * function will receive the indices of the queues in the resulting list.\n *\n * @since 2.0.0\n * @category utils\n */\nconst distributedWith = distributedWith$1;\n\n/**\n * More powerful version of `Stream.distributedWith`. This returns a function\n * that will produce new queues and corresponding indices. You can also\n * provide a function that will be executed after the final events are\n * enqueued in all queues. Shutdown of the queues is handled by the driver.\n * Downstream users can also shutdown queues manually. In this case the driver\n * will continue but no longer backpressure on them.\n *\n * @since 2.0.0\n * @category utils\n */\nconst distributedWithDynamic = distributedWithDynamic$1;\n\n/**\n * Converts this stream to a stream that executes its effects but emits no\n * elements. Useful for sequencing effects using streams:\n *\n * @since 2.0.0\n * @category utils\n */\nconst drain = drain$1;\n\n/**\n * Drains the provided stream in the background for as long as this stream is\n * running. If this stream ends before `other`, `other` will be interrupted.\n * If `other` fails, this stream will fail with that error.\n *\n * @since 2.0.0\n * @category utils\n */\nconst drainFork = drainFork$1;\n\n/**\n * Drops the specified number of elements from this stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst drop = drop$1;\n\n/**\n * Drops the last specified number of elements from this stream.\n *\n * @note This combinator keeps `n` elements in memory. Be careful with big\n *       numbers.\n * @since 2.0.0\n * @category utils\n */\nconst dropRight = dropRight$1;\n\n/**\n * Drops all elements of the stream until the specified predicate evaluates to\n * `true`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst dropUntil = dropUntil$1;\n\n/**\n * Drops all elements of the stream until the specified effectful predicate\n * evaluates to `true`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst dropUntilEffect = dropUntilEffect$1;\n\n/**\n * Drops all elements of the stream for as long as the specified predicate\n * evaluates to `true`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst dropWhile = dropWhile$1;\n\n/**\n * Drops all elements of the stream for as long as the specified predicate\n * produces an effect that evalutates to `true`\n *\n * @since 2.0.0\n * @category utils\n */\nconst dropWhileEffect = dropWhileEffect$1;\n\n/**\n * Returns a stream whose failures and successes have been lifted into an\n * `Either`. The resulting stream cannot fail, because the failures have been\n * exposed as part of the `Either` success case.\n *\n * @note The stream will end as soon as the first error occurs.\n *\n * @since 2.0.0\n * @category utils\n */\nconst either = either$1;\n\n/**\n * The empty stream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = empty$1;\n\n/**\n * Executes the provided finalizer after this stream's finalizers run.\n *\n * @since 2.0.0\n * @category utils\n */\nconst ensuring = ensuring$1;\n\n/**\n * Executes the provided finalizer after this stream's finalizers run.\n *\n * @since 2.0.0\n * @category utils\n */\nconst ensuringWith = ensuringWith$1;\n\n/**\n * Accesses the whole context of the stream.\n *\n * @since 2.0.0\n * @category context\n */\nconst context = context$1;\n\n/**\n * Accesses the context of the stream.\n *\n * @since 2.0.0\n * @category context\n */\nconst contextWith = contextWith$1;\n\n/**\n * Accesses the context of the stream in the context of an effect.\n *\n * @since 2.0.0\n * @category context\n */\nconst contextWithEffect = contextWithEffect$1;\n\n/**\n * Accesses the context of the stream in the context of a stream.\n *\n * @since 2.0.0\n * @category context\n */\nconst contextWithStream = contextWithStream$1;\n\n/**\n * Creates a stream that executes the specified effect but emits no elements.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst execute = execute$1;\n\n/**\n * Terminates with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fail = fail$1;\n\n/**\n * Terminates with the specified lazily evaluated error.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failSync = failSync$1;\n\n/**\n * The stream that always fails with the specified `Cause`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failCause = failCause$1;\n\n/**\n * The stream that always fails with the specified lazily evaluated `Cause`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst failCauseSync = failCauseSync$1;\n\n/**\n * Filters the elements emitted by this stream using the provided function.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filter = filter$1;\n\n/**\n * Effectfully filters the elements emitted by this stream.\n *\n * @since 2.0.0\n * @category filtering\n */\nconst filterEffect = filterEffect$1;\n\n/**\n * Performs a filter and map in a single step.\n *\n * @since 2.0.0\n * @category utils\n */\nconst filterMap = filterMap$1;\n\n/**\n * Performs an effectful filter and map in a single step.\n *\n * @since 2.0.0\n * @category utils\n */\nconst filterMapEffect = filterMapEffect$1;\n\n/**\n * Transforms all elements of the stream for as long as the specified partial\n * function is defined.\n *\n * @since 2.0.0\n * @category utils\n */\nconst filterMapWhile = filterMapWhile$1;\n\n/**\n * Effectfully transforms all elements of the stream for as long as the\n * specified partial function is defined.\n *\n * @since 2.0.0\n * @category utils\n */\nconst filterMapWhileEffect = filterMapWhileEffect$1;\n\n/**\n * Creates a one-element stream that never fails and executes the finalizer\n * when it ends.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst finalizer = finalizer$1;\n\n/**\n * Finds the first element emitted by this stream that satisfies the provided\n * predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nconst find = find$1;\n\n/**\n * Finds the first element emitted by this stream that satisfies the provided\n * effectful predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nconst findEffect = findEffect$1;\n\n/**\n * Returns a stream made of the concatenation in strict order of all the\n * streams produced by passing each element of this stream to `f0`\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatMap = flatMap$1;\n\n/**\n * Flattens this stream-of-streams into a stream made of the concatenation in\n * strict order of all the streams.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flatten = flatten$1;\n\n/**\n * Submerges the chunks carried by this stream into the stream's structure,\n * while still preserving them.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flattenChunks = flattenChunks$1;\n\n/**\n * Flattens `Effect` values into the stream's structure, preserving all\n * information about the effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flattenEffect = flattenEffect$1;\n\n/**\n * Unwraps `Exit` values that also signify end-of-stream by failing with `None`.\n *\n * For `Exit` values that do not signal end-of-stream, prefer:\n *\n * ```ts\n * stream.mapZIO(ZIO.done(_))\n * ```\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flattenExitOption = flattenExitOption$1;\n\n/**\n * Submerges the iterables carried by this stream into the stream's structure,\n * while still preserving them.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flattenIterables = flattenIterables$1;\n\n/**\n * Unwraps `Exit` values and flatten chunks that also signify end-of-stream\n * by failing with `None`.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst flattenTake = flattenTake$1;\n\n/**\n * Repeats this stream forever.\n *\n * @since 2.0.0\n * @category utils\n */\nconst forever = forever$1;\n\n/**\n * Creates a stream from an `AsyncIterable`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromAsyncIterable = fromAsyncIterable$1;\n\n/**\n * Creates a stream from a `Channel`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromChannel = fromChannel$1;\n\n/**\n * Creates a channel from a `Stream`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst toChannel = toChannel$1;\n\n/**\n * Creates a stream from a `Chunk` of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromChunk = fromChunk$1;\n\n/**\n * Creates a stream from a subscription to a `PubSub`.\n *\n * @param shutdown If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)\n * @since 2.0.0\n * @category constructors\n */\nconst fromChunkPubSub = fromChunkPubSub$1;\n\n/**\n * Creates a stream from a `Queue` of values.\n *\n * @param shutdown If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)\n * @since 2.0.0\n * @category constructors\n */\nconst fromChunkQueue = fromChunkQueue$1;\n\n/**\n * Creates a stream from an arbitrary number of chunks.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromChunks = fromChunks$1;\n\n/**\n * Either emits the success value of this effect or terminates the stream\n * with the failure value of this effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromEffect = fromEffect$1;\n\n/**\n * Creates a stream from an effect producing a value of type `A` or an empty\n * `Stream`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromEffectOption = fromEffectOption$1;\n\n/**\n * Creates a stream from a subscription to a `PubSub`.\n *\n * @param shutdown If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)\n * @since 2.0.0\n * @category constructors\n */\nconst fromPubSub = fromPubSub$1;\n\n/**\n * Creates a stream from an `Iterable` collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterable = fromIterable$1;\n\n/**\n * Creates a stream from an effect producing a value of type `Iterable<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIterableEffect = fromIterableEffect$1;\n\n/**\n * Creates a stream from an iterator\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromIteratorSucceed = fromIteratorSucceed$1;\n\n/**\n * Creates a stream from an effect that pulls elements from another stream.\n *\n * See `Stream.toPull` for reference.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromPull = fromPull$1;\n\n/**\n * Creates a stream from a queue of values\n *\n * @param maxChunkSize The maximum number of queued elements to put in one chunk in the stream\n * @param shutdown If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)\n * @since 2.0.0\n * @category constructors\n */\nconst fromQueue = fromQueue$1;\n\n/**\n * Creates a stream from a `ReadableStream`.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromReadableStream = fromReadableStream$1;\n\n/**\n * Creates a stream from a `ReadableStreamBYOBReader`.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.\n *\n * @param allocSize Controls the size of the underlying `ArrayBuffer` (defaults to `4096`).\n * @since 2.0.0\n * @category constructors\n */\nconst fromReadableStreamByob = fromReadableStreamByob$1;\n\n/**\n * Creates a stream from a `Schedule` that does not require any further\n * input. The stream will emit an element for each value output from the\n * schedule, continuing for as long as the schedule continues.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst fromSchedule = fromSchedule$1;\n\n/**\n * Creates a pipeline that groups on adjacent keys, calculated by the\n * specified function.\n *\n * @since 2.0.0\n * @category grouping\n */\nconst groupAdjacentBy = groupAdjacentBy$1;\n\n/**\n * More powerful version of `Stream.groupByKey`.\n *\n * @since 2.0.0\n * @category grouping\n */\nconst groupBy = groupBy$1;\n\n/**\n * Partition a stream using a function and process each stream individually.\n * This returns a data structure that can be used to further filter down which\n * groups shall be processed.\n *\n * After calling apply on the GroupBy object, the remaining groups will be\n * processed in parallel and the resulting streams merged in a\n * nondeterministic fashion.\n *\n * Up to `buffer` elements may be buffered in any group stream before the\n * producer is backpressured. Take care to consume from all streams in order\n * to prevent deadlocks.\n *\n * For example, to collect the first 2 words for every starting letter from a\n * stream of words:\n *\n * ```ts\n * import * as GroupBy from \"./GroupBy\"\n * import * as Stream from \"./Stream\"\n * import { pipe } from \"./Function\"\n *\n * pipe(\n *   Stream.fromIterable([\"hello\", \"world\", \"hi\", \"holla\"]),\n *   Stream.groupByKey((word) => word[0]),\n *   GroupBy.evaluate((key, stream) =>\n *     pipe(\n *       stream,\n *       Stream.take(2),\n *       Stream.map((words) => [key, words] as const)\n *     )\n *   )\n * )\n * ```\n *\n * @since 2.0.0\n * @category utils\n */\nconst groupByKey = groupByKey$1;\n\n/**\n * Partitions the stream with specified `chunkSize`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst grouped = grouped$1;\n\n/**\n * Partitions the stream with the specified `chunkSize` or until the specified\n * `duration` has passed, whichever is satisfied first.\n *\n * @since 2.0.0\n * @category utils\n */\nconst groupedWithin = groupedWithin$1;\n\n/**\n * Specialized version of haltWhen which halts the evaluation of this stream\n * after the given duration.\n *\n * An element in the process of being pulled will not be interrupted when the\n * given duration completes. See `interruptAfter` for this behavior.\n *\n * @since 2.0.0\n * @category utils\n */\nconst haltAfter = haltAfter$1;\n\n/**\n * Halts the evaluation of this stream when the provided effect completes. The\n * given effect will be forked as part of the returned stream, and its success\n * will be discarded.\n *\n * An element in the process of being pulled will not be interrupted when the\n * effect completes. See `interruptWhen` for this behavior.\n *\n * If the effect completes with a failure, the stream will emit that failure.\n *\n * @since 2.0.0\n * @category utils\n */\nconst haltWhen = haltWhen$1;\n\n/**\n * Halts the evaluation of this stream when the provided promise resolves.\n *\n * If the promise completes with a failure, the stream will emit that failure.\n *\n * @since 2.0.0\n * @category utils\n */\nconst haltWhenDeferred = haltWhenDeferred$1;\n\n/**\n * The identity pipeline, which does not modify streams in any way.\n *\n * @since 2.0.0\n * @category utils\n */\nconst identity = identityStream;\n\n/**\n * Interleaves this stream and the specified stream deterministically by\n * alternating pulling values from this stream and the specified stream. When\n * one stream is exhausted all remaining values in the other stream will be\n * pulled.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interleave = interleave$1;\n\n/**\n * Combines this stream and the specified stream deterministically using the\n * stream of boolean values `pull` to control which stream to pull from next.\n * A value of `true` indicates to pull from this stream and a value of `false`\n * indicates to pull from the specified stream. Only consumes as many elements\n * as requested by the `pull` stream. If either this stream or the specified\n * stream are exhausted further requests for values from that stream will be\n * ignored.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interleaveWith = interleaveWith$1;\n\n/**\n * Intersperse stream with provided `element`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst intersperse = intersperse$1;\n\n/**\n * Intersperse the specified element, also adding a prefix and a suffix.\n *\n * @since 2.0.0\n * @category utils\n */\nconst intersperseAffixes = intersperseAffixes$1;\n\n/**\n * Specialized version of `Stream.interruptWhen` which interrupts the\n * evaluation of this stream after the given `Duration`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interruptAfter = interruptAfter$1;\n\n/**\n * Interrupts the evaluation of this stream when the provided effect\n * completes. The given effect will be forked as part of this stream, and its\n * success will be discarded. This combinator will also interrupt any\n * in-progress element being pulled from upstream.\n *\n * If the effect completes with a failure before the stream completes, the\n * returned stream will emit that failure.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interruptWhen = interruptWhen$1;\n\n/**\n * Interrupts the evaluation of this stream when the provided promise\n * resolves. This combinator will also interrupt any in-progress element being\n * pulled from upstream.\n *\n * If the promise completes with a failure, the stream will emit that failure.\n *\n * @since 2.0.0\n * @category utils\n */\nconst interruptWhenDeferred = interruptWhenDeferred$1;\n\n/**\n * The infinite stream of iterative function application: a, f(a), f(f(a)),\n * f(f(f(a))), ...\n *\n * @since 2.0.0\n * @category constructors\n */\nconst iterate = iterate$1;\n\n/**\n * Creates a stream from an sequence of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * Transforms the elements of this stream using the supplied function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst map = map$1;\n\n/**\n * Statefully maps over the elements of this stream to produce new elements.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapAccum = mapAccum$1;\n\n/**\n * Statefully and effectfully maps over the elements of this stream to produce\n * new elements.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapAccumEffect = mapAccumEffect$1;\n\n/**\n * Returns a stream whose failure and success channels have been mapped by the\n * specified `onFailure` and `onSuccess` functions.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mapBoth = mapBoth$1;\n\n/**\n * Transforms the chunks emitted by this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapChunks = mapChunks$1;\n\n/**\n * Effectfully transforms the chunks emitted by this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapChunksEffect = mapChunksEffect$1;\n\n/**\n * Maps each element to an iterable, and flattens the iterables into the\n * output of this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapConcat = mapConcat$1;\n\n/**\n * Maps each element to a chunk, and flattens the chunks into the output of\n * this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapConcatChunk = mapConcatChunk$1;\n\n/**\n * Effectfully maps each element to a chunk, and flattens the chunks into the\n * output of this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapConcatChunkEffect = mapConcatChunkEffect$1;\n\n/**\n * Effectfully maps each element to an iterable, and flattens the iterables\n * into the output of this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapConcatEffect = mapConcatEffect$1;\n\n/**\n * Maps over elements of the stream with the specified effectful function.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapEffect = mapEffectOptions;\n\n/**\n * Transforms the errors emitted by this stream using `f`.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapError = mapError$1;\n\n/**\n * Transforms the full causes of failures emitted by this stream.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst mapErrorCause = mapErrorCause$1;\n\n/**\n * Merges this stream and the specified stream together.\n *\n * New produced stream will terminate when both specified stream terminate if\n * no termination strategy is specified.\n *\n * @since 2.0.0\n * @category utils\n */\nconst merge = merge$1;\n\n/**\n * Merges a variable list of streams in a non-deterministic fashion. Up to `n`\n * streams may be consumed in parallel and up to `outputBuffer` chunks may be\n * buffered by this operator.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mergeAll = mergeAll$1;\n\n/**\n * Merges this stream and the specified stream together to a common element\n * type with the specified mapping functions.\n *\n * New produced stream will terminate when both specified stream terminate if\n * no termination strategy is specified.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mergeWith = mergeWith$1;\n\n/**\n * Merges this stream and the specified stream together to produce a stream of\n * eithers.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mergeEither = mergeEither$1;\n\n/**\n * Merges this stream and the specified stream together, discarding the values\n * from the right stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mergeLeft = mergeLeft$1;\n\n/**\n * Merges this stream and the specified stream together, discarding the values\n * from the left stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mergeRight = mergeRight$1;\n\n/**\n * Returns a combined string resulting from concatenating each of the values\n * from the stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst mkString = mkString$1;\n\n/**\n * The stream that never produces any value or fails with any error.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst never = never$1;\n\n/**\n * Runs the specified effect if this stream fails, providing the error to the\n * effect if it exists.\n *\n * Note: Unlike `Effect.onError` there is no guarantee that the provided\n * effect will not be interrupted.\n *\n * @since 2.0.0\n * @category utils\n */\nconst onError = onError$1;\n\n/**\n * Runs the specified effect if this stream ends.\n *\n * @since 2.0.0\n * @category utils\n */\nconst onDone = onDone$1;\n\n/**\n * Translates any failure into a stream termination, making the stream\n * infallible and all failures unchecked.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orDie = orDie$1;\n\n/**\n * Keeps none of the errors, and terminates the stream with them, using the\n * specified function to convert the `E` into a defect.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orDieWith = orDieWith$1;\n\n/**\n * Switches to the provided stream in case this one fails with a typed error.\n *\n * See also `Stream.catchAll`.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElse = orElse$1;\n\n/**\n * Switches to the provided stream in case this one fails with a typed error.\n *\n * See also `Stream.catchAll`.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElseEither = orElseEither$1;\n\n/**\n * Fails with given error in case this one fails with a typed error.\n *\n * See also `Stream.catchAll`.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElseFail = orElseFail$1;\n\n/**\n * Produces the specified element if this stream is empty.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElseIfEmpty = orElseIfEmpty$1;\n\n/**\n * Produces the specified chunk if this stream is empty.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElseIfEmptyChunk = orElseIfEmptyChunk$1;\n\n/**\n * Switches to the provided stream in case this one is empty.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElseIfEmptyStream = orElseIfEmptyStream$1;\n\n/**\n * Succeeds with the specified value if this one fails with a typed error.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst orElseSucceed = orElseSucceed$1;\n\n/**\n * Like `Stream.unfold`, but allows the emission of values to end one step further\n * than the unfolding of the state. This is useful for embedding paginated\n * APIs, hence the name.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst paginate = paginate$1;\n\n/**\n * Like `Stream.unfoldChunk`, but allows the emission of values to end one step\n * further than the unfolding of the state. This is useful for embedding\n * paginated APIs, hence the name.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst paginateChunk = paginateChunk$1;\n\n/**\n * Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step\n * further than the unfolding of the state. This is useful for embedding\n * paginated APIs, hence the name.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst paginateChunkEffect = paginateChunkEffect$1;\n\n/**\n * Like `Stream.unfoldEffect` but allows the emission of values to end one step\n * further than the unfolding of the state. This is useful for embedding\n * paginated APIs, hence the name.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst paginateEffect = paginateEffect$1;\n\n/**\n * Partition a stream using a predicate. The first stream will contain all\n * element evaluated to true and the second one will contain all element\n * evaluated to false. The faster stream may advance by up to buffer elements\n * further than the slower one.\n *\n * @since 2.0.0\n * @category utils\n */\nconst partition = partition$1;\n\n/**\n * Split a stream by an effectful predicate. The faster stream may advance by\n * up to buffer elements further than the slower one.\n *\n * @since 2.0.0\n * @category utils\n */\nconst partitionEither = partitionEither$1;\n\n/**\n * Peels off enough material from the stream to construct a `Z` using the\n * provided `Sink` and then returns both the `Z` and the rest of the\n * `Stream` in a scope. Like all scoped values, the provided stream is\n * valid only within the scope.\n *\n * @since 2.0.0\n * @category utils\n */\nconst peel = peel$1;\n\n/**\n * Pipes all of the values from this stream through the provided sink.\n *\n * See also `Stream.transduce`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst pipeThrough = pipeThrough$1;\n\n/**\n * Pipes all the values from this stream through the provided channel.\n *\n * @since 2.0.0\n * @category utils\n */\nconst pipeThroughChannel = pipeThroughChannel$1;\n\n/**\n * Pipes all values from this stream through the provided channel, passing\n * through any error emitted by this stream unchanged.\n *\n * @since 2.0.0\n * @category utils\n */\nconst pipeThroughChannelOrFail = pipeThroughChannelOrFail$1;\n\n/**\n * Emits the provided chunk before emitting any other value.\n *\n * @since 2.0.0\n * @category utils\n */\nconst prepend = prepend$1;\n\n/**\n * Provides the stream with its required context, which eliminates its\n * dependency on `R`.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideContext = provideContext$1;\n\n/**\n * Provides a `Layer` to the stream, which translates it to another level.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideLayer = provideLayer$1;\n\n/**\n * Provides the stream with the single service it requires. If the stream\n * requires more than one service use `Stream.provideContext` instead.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideService = provideService$1;\n\n/**\n * Provides the stream with the single service it requires. If the stream\n * requires more than one service use `Stream.provideContext` instead.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideServiceEffect = provideServiceEffect$1;\n\n/**\n * Provides the stream with the single service it requires. If the stream\n * requires more than one service use `Stream.provideContext` instead.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideServiceStream = provideServiceStream$1;\n\n/**\n * Transforms the context being provided to the stream with the specified\n * function.\n *\n * @since 2.0.0\n * @category context\n */\nconst mapInputContext = mapInputContext$1;\n\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer and leaving the remainder `R0`.\n *\n * @since 2.0.0\n * @category context\n */\nconst provideSomeLayer = provideSomeLayer$1;\n\n/**\n * Constructs a stream from a range of integers, including both endpoints.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst range = range$1;\n\n/**\n * Re-chunks the elements of the stream into chunks of `n` elements each. The\n * last chunk might contain less than `n` elements.\n *\n * @since 2.0.0\n * @category utils\n */\nconst rechunk = rechunk$1;\n\n/**\n * Keeps some of the errors, and terminates the fiber with the rest\n *\n * @since 2.0.0\n * @category error handling\n */\nconst refineOrDie = refineOrDie$1;\n\n/**\n * Keeps some of the errors, and terminates the fiber with the rest, using the\n * specified function to convert the `E` into a defect.\n *\n * @since 2.0.0\n * @category error handling\n */\nconst refineOrDieWith = refineOrDieWith$1;\n\n/**\n * Repeats the entire stream using the specified schedule. The stream will\n * execute normally, and then repeat again according to the provided schedule.\n *\n * @since 2.0.0\n * @category utils\n */\nconst repeat = repeat$1;\n\n/**\n * Creates a stream from an effect producing a value of type `A` which repeats\n * forever.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst repeatEffect = repeatEffect$1;\n\n/**\n * Creates a stream from an effect producing chunks of `A` values which\n * repeats forever.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst repeatEffectChunk = repeatEffectChunk$1;\n\n/**\n * Creates a stream from an effect producing chunks of `A` values until it\n * fails with `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst repeatEffectChunkOption = repeatEffectChunkOption$1;\n\n/**\n * Creates a stream from an effect producing values of type `A` until it fails\n * with `None`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst repeatEffectOption = repeatEffectOption$1;\n\n/**\n * Creates a stream from an effect producing a value of type `A`, which is\n * repeated using the specified schedule.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst repeatEffectWithSchedule = repeatEffectWithSchedule$1;\n\n/**\n * Repeats the entire stream using the specified schedule. The stream will\n * execute normally, and then repeat again according to the provided schedule.\n * The schedule output will be emitted at the end of each repetition.\n *\n * @since 2.0.0\n * @category utils\n */\nconst repeatEither = repeatEither$1;\n\n/**\n * Repeats each element of the stream using the provided schedule. Repetitions\n * are done in addition to the first execution, which means using\n * `Schedule.recurs(1)` actually results in the original effect, plus an\n * additional recurrence, for a total of two repetitions of each value in the\n * stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst repeatElements = repeatElements$1;\n\n/**\n * Repeats each element of the stream using the provided schedule. When the\n * schedule is finished, then the output of the schedule will be emitted into\n * the stream. Repetitions are done in addition to the first execution, which\n * means using `Schedule.recurs(1)` actually results in the original effect,\n * plus an additional recurrence, for a total of two repetitions of each value\n * in the stream.\n *\n * This function accepts two conversion functions, which allow the output of\n * this stream and the output of the provided schedule to be unified into a\n * single type. For example, `Either` or similar data type.\n *\n * @since 2.0.0\n * @category utils\n */\nconst repeatElementsWith = repeatElementsWith$1;\n\n/**\n * Repeats the provided value infinitely.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst repeatValue = repeatValue$1;\n\n/**\n * Repeats the entire stream using the specified schedule. The stream will\n * execute normally, and then repeat again according to the provided schedule.\n * The schedule output will be emitted at the end of each repetition and can\n * be unified with the stream elements using the provided functions.\n *\n * @since 2.0.0\n * @category utils\n */\nconst repeatWith = repeatWith$1;\n\n/**\n * When the stream fails, retry it according to the given schedule\n *\n * This retries the entire stream, so will re-execute all of the stream's\n * acquire operations.\n *\n * The schedule is reset as soon as the first element passes through the\n * stream again.\n *\n * @param schedule A `Schedule` receiving as input the errors of the stream.\n * @since 2.0.0\n * @category utils\n */\nconst retry = retry$1;\n\n/**\n * Runs the sink on the stream to produce either the sink's result or an error.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst run = run$1;\n\n/**\n * Runs the stream and collects all of its elements to a chunk.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runCollect = runCollect$1;\n\n/**\n * Runs the stream and emits the number of elements processed\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runCount = runCount$1;\n\n/**\n * Runs the stream only for its effects. The emitted elements are discarded.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runDrain = runDrain$1;\n\n/**\n * Executes a pure fold over the stream of values - reduces all elements in\n * the stream to a value of type `S`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFold = runFold$1;\n\n/**\n * Executes an effectful fold over the stream of values.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldEffect = runFoldEffect$1;\n\n/**\n * Executes a pure fold over the stream of values. Returns a scoped value that\n * represents the scope of the stream.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldScoped = runFoldScoped$1;\n\n/**\n * Executes an effectful fold over the stream of values. Returns a scoped\n * value that represents the scope of the stream.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldScopedEffect = runFoldScopedEffect$1;\n\n/**\n * Reduces the elements in the stream to a value of type `S`. Stops the fold\n * early when the condition is not fulfilled. Example:\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldWhile = runFoldWhile$1;\n\n/**\n * Executes an effectful fold over the stream of values. Stops the fold early\n * when the condition is not fulfilled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldWhileEffect = runFoldWhileEffect$1;\n\n/**\n * Executes a pure fold over the stream of values. Returns a scoped value that\n * represents the scope of the stream. Stops the fold early when the condition\n * is not fulfilled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldWhileScoped = runFoldWhileScoped$1;\n\n/**\n * Executes an effectful fold over the stream of values. Returns a scoped\n * value that represents the scope of the stream. Stops the fold early when\n * the condition is not fulfilled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runFoldWhileScopedEffect = runFoldWhileScopedEffect$1;\n\n/**\n * Consumes all elements of the stream, passing them to the specified\n * callback.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runForEach = runForEach$1;\n\n/**\n * Consumes all elements of the stream, passing them to the specified\n * callback.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runForEachChunk = runForEachChunk$1;\n\n/**\n * Like `Stream.runForEachChunk`, but returns a scoped effect so the\n * finalization order can be controlled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runForEachChunkScoped = runForEachChunkScoped$1;\n\n/**\n * Like `Stream.forEach`, but returns a scoped effect so the finalization\n * order can be controlled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runForEachScoped = runForEachScoped$1;\n\n/**\n * Consumes elements of the stream, passing them to the specified callback,\n * and terminating consumption when the callback returns `false`.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runForEachWhile = runForEachWhile$1;\n\n/**\n * Like `Stream.runForEachWhile`, but returns a scoped effect so the\n * finalization order can be controlled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runForEachWhileScoped = runForEachWhileScoped$1;\n\n/**\n * Runs the stream to completion and yields the first value emitted by it,\n * discarding the rest of the elements.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runHead = runHead$1;\n\n/**\n * Publishes elements of this stream to a `PubSub`. Stream failure and ending will\n * also be signalled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runIntoPubSub = runIntoPubSub$1;\n\n/**\n * Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to\n * allow for scope composition.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runIntoPubSubScoped = runIntoPubSubScoped$1;\n\n/**\n * Enqueues elements of this stream into a queue. Stream failure and ending\n * will also be signalled.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runIntoQueue = runIntoQueue$1;\n\n/**\n * Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]\n * to allow for scope composition.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runIntoQueueElementsScoped = runIntoQueueElementsScoped$1;\n\n/**\n * Like `Stream.runIntoQueue`, but provides the result as a scoped effect\n * to allow for scope composition.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runIntoQueueScoped = runIntoQueueScoped$1;\n\n/**\n * Runs the stream to completion and yields the last value emitted by it,\n * discarding the rest of the elements.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runLast = runLast$1;\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nconst runScoped = runScoped$1;\n\n/**\n * Runs the stream to a sink which sums elements, provided they are Numeric.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst runSum = runSum$1;\n\n/**\n * Statefully maps over the elements of this stream to produce all\n * intermediate results of type `S` given an initial S.\n *\n * @since 2.0.0\n * @category utils\n */\nconst scan = scan$1;\n\n/**\n * Statefully and effectfully maps over the elements of this stream to produce\n * all intermediate results of type `S` given an initial S.\n *\n * @since 2.0.0\n * @category utils\n */\nconst scanEffect = scanEffect$1;\n\n/**\n * Statefully maps over the elements of this stream to produce all\n * intermediate results.\n *\n * See also `Stream.scan`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst scanReduce = scanReduce$1;\n\n/**\n * Statefully and effectfully maps over the elements of this stream to produce\n * all intermediate results.\n *\n * See also `Stream.scanEffect`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst scanReduceEffect = scanReduceEffect$1;\n\n/**\n * Schedules the output of the stream using the provided `schedule`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst schedule = schedule$1;\n\n/**\n * Schedules the output of the stream using the provided `schedule` and emits\n * its output at the end (if `schedule` is finite). Uses the provided function\n * to align the stream and schedule outputs on the same type.\n *\n * @since 2.0.0\n * @category utils\n */\nconst scheduleWith = scheduleWith$1;\n\n/**\n * Creates a single-valued stream from a scoped resource.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst scoped = scoped$1;\n\n/**\n * Emits a sliding window of `n` elements.\n *\n * ```ts\n * import * as Stream from \"./Stream\"\n * import { pipe } from \"./Function\"\n *\n * pipe(\n *   Stream.make(1, 2, 3, 4),\n *   Stream.sliding(2),\n *   Stream.runCollect\n * )\n * // => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))\n * ```\n *\n * @since 2.0.0\n * @category utils\n */\nconst sliding = sliding$1;\n\n/**\n * Like `sliding`, but with a configurable `stepSize` parameter.\n *\n * @since 2.0.0\n * @category utils\n */\nconst slidingSize = slidingSize$1;\n\n/**\n * Converts an option on values into an option on errors.\n *\n * @since 2.0.0\n * @category utils\n */\nconst some = some$1;\n\n/**\n * Extracts the optional value, or returns the given 'default'.\n *\n * @since 2.0.0\n * @category utils\n */\nconst someOrElse = someOrElse$1;\n\n/**\n * Extracts the optional value, or fails with the given error 'e'.\n *\n * @since 2.0.0\n * @category utils\n */\nconst someOrFail = someOrFail$1;\n\n/**\n * Splits elements based on a predicate.\n *\n * ```ts\n * import * as Stream from \"./Stream\"\n * import { pipe } from \"./Function\"\n *\n * pipe(\n *   Stream.range(1, 10),\n *   Stream.split((n) => n % 4 === 0),\n *   Stream.runCollect\n * )\n * // => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))\n * ```\n *\n * @since 2.0.0\n * @category utils\n */\nconst split = split$1;\n\n/**\n * Splits elements on a delimiter and transforms the splits into desired output.\n *\n * @since 2.0.0\n * @category utils\n */\nconst splitOnChunk = splitOnChunk$1;\n\n/**\n * Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\n * newlines (`\\n`).\n *\n * @since 2.0.0\n * @category combinators\n */\nconst splitLines = splitLines$1;\n\n/**\n * Creates a single-valued pure stream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst succeed = succeed$1;\n\n/**\n * Creates a single-valued pure stream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst sync = sync$1;\n\n/**\n * Returns a lazily constructed stream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst suspend = suspend$1;\n\n/**\n * Takes the specified number of elements from this stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst take = take$1;\n\n/**\n * Takes the last specified number of elements from this stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeRight = takeRight$1;\n\n/**\n * Takes all elements of the stream until the specified predicate evaluates to\n * `true`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeUntil = takeUntil$1;\n\n/**\n * Takes all elements of the stream until the specified effectual predicate\n * evaluates to `true`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeUntilEffect = takeUntilEffect$1;\n\n/**\n * Takes all elements of the stream for as long as the specified predicate\n * evaluates to `true`.\n *\n * @since 2.0.0\n * @category utils\n */\nconst takeWhile = takeWhile$1;\n\n/**\n * Adds an effect to consumption of every element of the stream.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tap = tap$1;\n\n/**\n * Returns a stream that effectfully \"peeks\" at the failure or success of\n * the stream.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapBoth = tapBoth$1;\n\n/**\n * Returns a stream that effectfully \"peeks\" at the failure of the stream.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapError = tapError$1;\n\n/**\n * Returns a stream that effectfully \"peeks\" at the cause of failure of the\n * stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst tapErrorCause = tapErrorCause$1;\n\n/**\n * Sends all elements emitted by this stream to the specified sink in addition\n * to emitting them.\n *\n * @since 2.0.0\n * @category sequencing\n */\nconst tapSink = tapSink$1;\n\n/**\n * Delays the chunks of this stream according to the given bandwidth\n * parameters using the token bucket algorithm. Allows for burst in the\n * processing of elements by allowing the token bucket to accumulate tokens up\n * to a `units + burst` threshold. The weight of each chunk is determined by\n * the `costFn` function.\n *\n * If using the \"enforce\" strategy, chunks that do not meet the bandwidth\n * constraints are dropped. If using the \"shape\" strategy, chunks are delayed\n * until they can be emitted without exceeding the bandwidth constraints.\n *\n * Defaults to the \"shape\" strategy.\n *\n * @since 2.0.0\n * @category utils\n */\nconst throttle = throttle$1;\n\n/**\n * Delays the chunks of this stream according to the given bandwidth\n * parameters using the token bucket algorithm. Allows for burst in the\n * processing of elements by allowing the token bucket to accumulate tokens up\n * to a `units + burst` threshold. The weight of each chunk is determined by\n * the effectful `costFn` function.\n *\n * If using the \"enforce\" strategy, chunks that do not meet the bandwidth\n * constraints are dropped. If using the \"shape\" strategy, chunks are delayed\n * until they can be emitted without exceeding the bandwidth constraints.\n *\n * Defaults to the \"shape\" strategy.\n *\n * @since 2.0.0\n * @category utils\n */\nconst throttleEffect = throttleEffect$1;\n\n/**\n * A stream that emits Unit values spaced by the specified duration.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst tick = tick$1;\n\n/**\n * Ends the stream if it does not produce a value after the specified duration.\n *\n * @since 2.0.0\n * @category utils\n */\nconst timeout = timeout$1;\n\n/**\n * Fails the stream with given error if it does not produce a value after d\n * duration.\n *\n * @since 2.0.0\n * @category utils\n */\nconst timeoutFail = timeoutFail$1;\n\n/**\n * Fails the stream with given cause if it does not produce a value after d\n * duration.\n *\n * @since 2.0.0\n * @category utils\n */\nconst timeoutFailCause = timeoutFailCause$1;\n\n/**\n * Switches the stream if it does not produce a value after the specified\n * duration.\n *\n * @since 2.0.0\n * @category utils\n */\nconst timeoutTo = timeoutTo$1;\n\n/**\n * Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,\n * the `PubSub` will never again produce values and should be discarded.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toPubSub = toPubSub$1;\n\n/**\n * Returns in a scope a ZIO effect that can be used to repeatedly pull chunks\n * from the stream. The pull effect fails with None when the stream is\n * finished, or with Some error if it fails, otherwise it returns a chunk of\n * the stream's output.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toPull = toPull$1;\n\n/**\n * Converts the stream to a scoped queue of chunks. After the scope is closed,\n * the queue will never again produce values and should be discarded.\n *\n * Defaults to the \"suspend\" back pressure strategy with a capacity of 2.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toQueue = toQueue$1;\n\n/**\n * Converts the stream to a scoped queue of elements. After the scope is\n * closed, the queue will never again produce values and should be discarded.\n *\n * Defaults to a capacity of 2.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toQueueOfElements = toQueueOfElements$1;\n\n/**\n * Converts the stream to a `ReadableStream`.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.\n *\n * @since 2.0.0\n * @category destructors\n */\nconst toReadableStream = toReadableStream$1;\n\n/**\n * Applies the transducer to the stream and emits its outputs.\n *\n * @since 2.0.0\n * @category utils\n */\nconst transduce = transduce$1;\n\n/**\n * Creates a stream by peeling off the \"layers\" of a value of type `S`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unfold = unfold$1;\n\n/**\n * Creates a stream by peeling off the \"layers\" of a value of type `S`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unfoldChunk = unfoldChunk$1;\n\n/**\n * Creates a stream by effectfully peeling off the \"layers\" of a value of type\n * `S`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unfoldChunkEffect = unfoldChunkEffect$1;\n\n/**\n * Creates a stream by effectfully peeling off the \"layers\" of a value of type\n * `S`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unfoldEffect = unfoldEffect$1;\n\n/**\n * A stream that contains a single `Unit` value.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unit = unit$1;\n\n/**\n * Creates a stream produced from an `Effect`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unwrap = unwrap$1;\n\n/**\n * Creates a stream produced from a scoped `Effect`.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst unwrapScoped = unwrapScoped$1;\n\n/**\n * Updates the specified service within the context of the `Stream`.\n *\n * @since 2.0.0\n * @category context\n */\nconst updateService = updateService$1;\n\n/**\n * Returns the specified stream if the given condition is satisfied, otherwise\n * returns an empty stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst when = when$1;\n\n/**\n * Returns the resulting stream when the given `PartialFunction` is defined\n * for the given value, otherwise returns an empty stream.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst whenCase = whenCase$1;\n\n/**\n * Returns the stream when the given partial function is defined for the given\n * effectful value, otherwise returns an empty stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst whenCaseEffect = whenCaseEffect$1;\n\n/**\n * Returns the stream if the given effectful condition is satisfied, otherwise\n * returns an empty stream.\n *\n * @since 2.0.0\n * @category utils\n */\nconst whenEffect = whenEffect$1;\n\n/**\n * Wraps the stream with a new span for tracing.\n *\n * @since 2.0.0\n * @category tracing\n */\nconst withSpan = withSpan$1;\n\n/**\n * Zips this stream with another point-wise and emits tuples of elements from\n * both streams.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zip = zip$1;\n\n/**\n * Zips this stream with another point-wise and emits tuples of elements from\n * both streams.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipFlatten = zipFlatten$1;\n\n/**\n * Zips this stream with another point-wise, creating a new stream of pairs of\n * elements from both sides.\n *\n * The defaults `defaultLeft` and `defaultRight` will be used if the streams\n * have different lengths and one of the streams has ended before the other.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAll = zipAll$1;\n\n/**\n * Zips this stream with another point-wise, and keeps only elements from this\n * stream.\n *\n * The provided default value will be used if the other stream ends before\n * this one.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllLeft = zipAllLeft$1;\n\n/**\n * Zips this stream with another point-wise, and keeps only elements from the\n * other stream.\n *\n * The provided default value will be used if this stream ends before the\n * other one.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllRight = zipAllRight$1;\n\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Combines values associated with each key into a tuple,\n * using the specified values `defaultLeft` and `defaultRight` to fill in\n * missing values.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllSortedByKey = zipAllSortedByKey$1;\n\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Keeps only values from this stream, using the specified\n * value `default` to fill in missing values.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllSortedByKeyLeft = zipAllSortedByKeyLeft$1;\n\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Keeps only values from that stream, using the specified\n * value `default` to fill in missing values.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllSortedByKeyRight = zipAllSortedByKeyRight$1;\n\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Uses the functions `left`, `right`, and `both` to handle\n * the cases where a key and value exist in this stream, that stream, or\n * both streams.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllSortedByKeyWith = zipAllSortedByKeyWith$1;\n\n/**\n * Zips this stream with another point-wise. The provided functions will be\n * used to create elements for the composed stream.\n *\n * The functions `left` and `right` will be used if the streams have different\n * lengths and one of the streams has ended before the other.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipAllWith = zipAllWith$1;\n\n/**\n * Zips the two streams so that when a value is emitted by either of the two\n * streams, it is combined with the latest value from the other stream to\n * produce a result.\n *\n * Note: tracking the latest value is done on a per-chunk basis. That means\n * that emitted elements that are not the last value in chunks will never be\n * used for zipping.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipLatest = zipLatest$1;\n\n/**\n * Zips the two streams so that when a value is emitted by either of the two\n * streams, it is combined with the latest value from the other stream to\n * produce a result.\n *\n * Note: tracking the latest value is done on a per-chunk basis. That means\n * that emitted elements that are not the last value in chunks will never be\n * used for zipping.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipLatestWith = zipLatestWith$1;\n\n/**\n * Zips this stream with another point-wise, but keeps only the outputs of\n * this stream.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipLeft = zipLeft$1;\n\n/**\n * Zips this stream with another point-wise, but keeps only the outputs of the\n * other stream.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipRight = zipRight$1;\n\n/**\n * Zips this stream with another point-wise and applies the function to the\n * paired elements.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWith = zipWith$1;\n\n/**\n * Zips this stream with another point-wise and applies the function to the\n * paired elements.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWithChunks = zipWithChunks$1;\n\n/**\n * Zips each element with the next element if present.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWithNext = zipWithNext$1;\n\n/**\n * Zips each element with the previous element. Initially accompanied by\n * `None`.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWithPrevious = zipWithPrevious$1;\n\n/**\n * Zips each element with both the previous and next element.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWithPreviousAndNext = zipWithPreviousAndNext$1;\n\n/**\n * Zips this stream together with the index of elements.\n *\n * @since 2.0.0\n * @category zipping\n */\nconst zipWithIndex = zipWithIndex$1;\n\n// -------------------------------------------------------------------------------------\n// Do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.0.0\n * @category do notation\n */\nconst Do = Do$1;\n\n/**\n * Binds a value from a stream in a `do` scope\n *\n * @since 2.0.0\n * @category do notation\n */\nconst bind = bind$1;\n\n/**\n * Binds an effectful value in a `do` scope\n *\n * @since 2.0.0\n * @category do notation\n */\nconst bindEffect = bindEffect$1;\n\n/**\n * @since 2.0.0\n * @category do notation\n */\nconst bindTo = bindTo$1;\nconst let_ = let_$1;\n\n// -------------------------------------------------------------------------------------\n// encoding\n// -------------------------------------------------------------------------------------\n\n/**\n * Decode Uint8Array chunks into a stream of strings using the specified encoding.\n *\n * @since 2.0.0\n * @category encoding\n */\nconst decodeText = decodeText$1;\n\n/**\n * Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.\n *\n * @since 2.0.0\n * @category encoding\n */\nconst encodeText = encodeText$1;\n\nexport { DefaultChunkSize, Do, StreamTypeId, acquireRelease, aggregate, aggregateWithin, aggregateWithinEither, as, _async as async, asyncEffect, asyncInterrupt, asyncOption, asyncScoped, bind, bindEffect, bindTo, branchAfter, broadcast, broadcastDynamic, broadcastedQueues, broadcastedQueuesDynamic, buffer, bufferChunks, catchAll, catchAllCause, catchSome, catchSomeCause, catchTag, catchTags, changes, changesWith, changesWithEffect, chunks, chunksWith, combine, combineChunks, concat, concatAll, context, contextWith, contextWithEffect, contextWithStream, cross, crossLeft, crossRight, crossWith, debounce, decodeText, die, dieMessage, dieSync, distributedWith, distributedWithDynamic, drain, drainFork, drop, dropRight, dropUntil, dropUntilEffect, dropWhile, dropWhileEffect, either, empty, encodeText, ensuring, ensuringWith, execute, fail, failCause, failCauseSync, failSync, filter, filterEffect, filterMap, filterMapEffect, filterMapWhile, filterMapWhileEffect, finalizer, find, findEffect, flatMap, flatten, flattenChunks, flattenEffect, flattenExitOption, flattenIterables, flattenTake, forever, fromAsyncIterable, fromChannel, fromChunk, fromChunkPubSub, fromChunkQueue, fromChunks, fromEffect, fromEffectOption, fromIterable, fromIterableEffect, fromIteratorSucceed, fromPubSub, fromPull, fromQueue, fromReadableStream, fromReadableStreamByob, fromSchedule, groupAdjacentBy, groupBy, groupByKey, grouped, groupedWithin, haltAfter, haltWhen, haltWhenDeferred, identity, interleave, interleaveWith, interruptAfter, interruptWhen, interruptWhenDeferred, intersperse, intersperseAffixes, iterate, let_ as let, make, map, mapAccum, mapAccumEffect, mapBoth, mapChunks, mapChunksEffect, mapConcat, mapConcatChunk, mapConcatChunkEffect, mapConcatEffect, mapEffect, mapError, mapErrorCause, mapInputContext, merge, mergeAll, mergeEither, mergeLeft, mergeRight, mergeWith, mkString, never, onDone, onError, orDie, orDieWith, orElse, orElseEither, orElseFail, orElseIfEmpty, orElseIfEmptyChunk, orElseIfEmptyStream, orElseSucceed, paginate, paginateChunk, paginateChunkEffect, paginateEffect, partition, partitionEither, peel, pipeThrough, pipeThroughChannel, pipeThroughChannelOrFail, prepend, provideContext, provideLayer, provideService, provideServiceEffect, provideServiceStream, provideSomeLayer, range, rechunk, refineOrDie, refineOrDieWith, repeat, repeatEffect, repeatEffectChunk, repeatEffectChunkOption, repeatEffectOption, repeatEffectWithSchedule, repeatEither, repeatElements, repeatElementsWith, repeatValue, repeatWith, retry, run, runCollect, runCount, runDrain, runFold, runFoldEffect, runFoldScoped, runFoldScopedEffect, runFoldWhile, runFoldWhileEffect, runFoldWhileScoped, runFoldWhileScopedEffect, runForEach, runForEachChunk, runForEachChunkScoped, runForEachScoped, runForEachWhile, runForEachWhileScoped, runHead, runIntoPubSub, runIntoPubSubScoped, runIntoQueue, runIntoQueueElementsScoped, runIntoQueueScoped, runLast, runScoped, runSum, scan, scanEffect, scanReduce, scanReduceEffect, schedule, scheduleWith, scoped, sliding, slidingSize, some, someOrElse, someOrFail, split, splitLines, splitOnChunk, succeed, suspend, sync, take, takeRight, takeUntil, takeUntilEffect, takeWhile, tap, tapBoth, tapError, tapErrorCause, tapSink, throttle, throttleEffect, tick, timeout, timeoutFail, timeoutFailCause, timeoutTo, toChannel, toPubSub, toPull, toQueue, toQueueOfElements, toReadableStream, transduce, unfold, unfoldChunk, unfoldChunkEffect, unfoldEffect, unit, unwrap, unwrapScoped, updateService, when, whenCase, whenCaseEffect, whenEffect, withSpan, zip, zipAll, zipAllLeft, zipAllRight, zipAllSortedByKey, zipAllSortedByKeyLeft, zipAllSortedByKeyRight, zipAllSortedByKeyWith, zipAllWith, zipFlatten, zipLatest, zipLatestWith, zipLeft, zipRight, zipWith, zipWithChunks, zipWithIndex, zipWithNext, zipWithPrevious, zipWithPreviousAndNext };\n","import * as Brand from 'effect/Brand';\nimport { Tag } from 'effect/Context';\nimport * as Effect from 'effect/Effect';\nimport { pipe, identity } from 'effect/Function';\nimport * as Option from 'effect/Option';\nimport * as Sink from 'effect/Sink';\nimport * as Stream from 'effect/Stream';\nimport { BadArgument } from '../../Error/dist/effect-platform-Error.esm.js';\nimport 'effect/Data';\n\n/** @internal */\nconst tag = /*#__PURE__*/Tag(\"@effect/platform/FileSystem\");\n\n/** @internal */\nconst Size$1 = bytes => typeof bytes === \"bigint\" ? bytes : BigInt(bytes);\n\n/** @internal */\nconst KiB$1 = n => Size$1(n * 1024);\n\n/** @internal */\nconst MiB$1 = n => Size$1(n * 1024 * 1024);\n\n/** @internal */\nconst GiB$1 = n => Size$1(n * 1024 * 1024 * 1024);\n\n/** @internal */\nconst TiB$1 = n => Size$1(n * 1024 * 1024 * 1024 * 1024);\nconst bigint1024 = /*#__PURE__*/BigInt(1024);\nconst bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;\n\n/** @internal */\nconst PiB$1 = n => Size$1(BigInt(n) * bigintPiB);\n\n/** @internal */\nconst make$1 = impl => {\n  return tag.of({\n    ...impl,\n    exists: path => pipe(impl.access(path), Effect.as(true), Effect.catchTag(\"SystemError\", e => e.reason === \"NotFound\" ? Effect.succeed(false) : Effect.fail(e))),\n    readFileString: (path, encoding) => Effect.tryMap(impl.readFile(path), {\n      try: _ => new TextDecoder(encoding).decode(_),\n      catch: () => BadArgument({\n        module: \"FileSystem\",\n        method: \"readFileString\",\n        message: \"invalid encoding\"\n      })\n    }),\n    stream: (path, options) => pipe(impl.open(path, {\n      flag: \"r\"\n    }), options?.offset ? Effect.tap(file => file.seek(options.offset, \"start\")) : identity, Effect.map(file => stream(file, options)), Stream.unwrapScoped),\n    sink: (path, options) => pipe(impl.open(path, {\n      flag: \"w\",\n      ...options\n    }), Effect.map(file => Sink.forEach(_ => file.writeAll(_))), Sink.unwrapScoped),\n    writeFileString: (path, data, options) => Effect.flatMap(Effect.try({\n      try: () => new TextEncoder().encode(data),\n      catch: () => BadArgument({\n        module: \"FileSystem\",\n        method: \"writeFileString\",\n        message: \"could not encode string\"\n      })\n    }), _ => impl.writeFile(path, _, options))\n  });\n};\n\n/** @internal */\nconst stream = (file, {\n  bufferSize = 4,\n  bytesToRead: bytesToRead_,\n  chunkSize: chunkSize_ = Size$1(64 * 1024)\n} = {}) => {\n  const bytesToRead = bytesToRead_ !== undefined ? Size$1(bytesToRead_) : undefined;\n  const chunkSize = Size$1(chunkSize_);\n  return Stream.bufferChunks(Stream.unfoldEffect(BigInt(0), totalBytesRead => {\n    if (bytesToRead !== undefined && bytesToRead <= totalBytesRead) {\n      return Effect.succeed(Option.none());\n    }\n    const toRead = bytesToRead !== undefined && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;\n    return Effect.map(file.readAlloc(toRead), Option.map(buf => [buf, Size$1(totalBytesRead + BigInt(buf.length))]));\n  }), {\n    capacity: bufferSize\n  });\n};\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category model\n */\n\n/**\n * Represents a size in bytes.\n *\n * @since 1.0.0\n * @category sizes\n */\n\n/**\n * Represents a size in bytes.\n *\n * @since 1.0.0\n * @category sizes\n */\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nconst Size = Size$1;\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nconst KiB = KiB$1;\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nconst MiB = MiB$1;\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nconst GiB = GiB$1;\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nconst TiB = TiB$1;\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nconst PiB = PiB$1;\n\n/**\n * @since 1.0.0\n * @category model\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category options\n */\n\n/**\n * @since 1.0.0\n * @category tag\n */\nconst FileSystem = tag;\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nconst make = make$1;\n\n/**\n * @since 1.0.0\n * @category type id\n */\nconst FileTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/FileSystem/File\");\n\n/**\n * @since 1.0.0\n * @category type id\n */\n\n/**\n * @since 1.0.0\n * @category guard\n */\nconst isFile = u => typeof u === \"object\" && u !== null && FileTypeId in u;\n\n/**\n * @since 1.0.0\n * @category model\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nconst FileDescriptor = /*#__PURE__*/Brand.nominal();\n\n/**\n * @since 1.0.0\n * @category model\n */\n\nexport { FileDescriptor, FileSystem, FileTypeId, GiB, KiB, MiB, PiB, Size, TiB, isFile, make };\n","import * as Schema from '@effect/schema/Schema';\nimport * as Data from 'effect/Data';\nimport * as Effect from 'effect/Effect';\nimport { identity } from 'effect/Function';\nimport * as Stream from 'effect/Stream';\nimport { FileSystem } from '../FileSystem/dist/effect-platform-FileSystem.esm.js';\n\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/Body\");\n\n/** @internal */\nconst ErrorTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/Body/BodyError\");\nconst bodyError = /*#__PURE__*/Data.tagged(\"BodyError\");\n\n/** @internal */\nconst BodyError = reason => bodyError({\n  [ErrorTypeId]: ErrorTypeId,\n  reason\n});\nclass EmptyImpl {\n  _tag = \"Empty\";\n  constructor() {\n    this[TypeId] = TypeId;\n  }\n}\n\n/** @internal */\nconst empty = /*#__PURE__*/new EmptyImpl();\nclass RawImpl {\n  _tag = \"Raw\";\n  constructor(body, contentType, contentLength) {\n    this.body = body;\n    this.contentType = contentType;\n    this.contentLength = contentLength;\n    this[TypeId] = TypeId;\n  }\n}\n\n/** @internal */\nconst raw = (body, contentType, contentLength) => new RawImpl(body, contentType, contentLength);\nclass Uint8ArrayImpl {\n  _tag = \"Uint8Array\";\n  constructor(body, contentType) {\n    this.body = body;\n    this.contentType = contentType;\n    this[TypeId] = TypeId;\n  }\n  get contentLength() {\n    return this.body.length;\n  }\n}\n\n/** @internal */\nconst uint8Array = (body, contentType) => new Uint8ArrayImpl(body, contentType ?? \"application/octet-stream\");\n\n/** @internal */\nconst text = (body, contentType) => uint8Array(new TextEncoder().encode(body), contentType ?? \"text/plain\");\n\n/** @internal */\nconst unsafeJson = body => uint8Array(new TextEncoder().encode(JSON.stringify(body)), \"application/json\");\n\n/** @internal */\nconst json = body => Effect.try({\n  try: () => unsafeJson(body),\n  catch: error => BodyError({\n    _tag: \"JsonError\",\n    error\n  })\n});\n\n/** @internal */\nconst jsonSchema = schema => {\n  const encode = Schema.encode(schema);\n  return body => Effect.flatMap(Effect.mapError(encode(body), error => BodyError({\n    _tag: \"SchemaError\",\n    error\n  })), json);\n};\n\n/** @internal */\nconst file = (path, options) => Effect.flatMap(FileSystem, fs => Effect.map(fs.stat(path), info => stream(fs.stream(path, options), options?.contentType, Number(info.size))));\n\n/** @internal */\nconst fileInfo = (path, info, options) => Effect.map(FileSystem, fs => stream(fs.stream(path, options), options?.contentType, Number(info.size)));\n\n/** @internal */\nconst fileWeb = file => stream(Stream.fromReadableStream(() => file.stream(), identity), file.type, file.size);\nclass FormDataImpl {\n  _tag = \"FormData\";\n  constructor(formData) {\n    this.formData = formData;\n    this[TypeId] = TypeId;\n  }\n}\n\n/** @internal */\nconst formData = body => new FormDataImpl(body);\nclass StreamImpl {\n  _tag = \"Stream\";\n  constructor(stream, contentType, contentLength) {\n    this.stream = stream;\n    this.contentType = contentType;\n    this.contentLength = contentLength;\n    this[TypeId] = TypeId;\n  }\n}\n\n/** @internal */\nconst stream = (body, contentType, contentLength) => new StreamImpl(body, contentType ?? \"application/octet-stream\", contentLength);\n\nexport { BodyError as B, ErrorTypeId as E, TypeId as T, unsafeJson as a, jsonSchema as b, file as c, fileInfo as d, empty as e, formData as f, fileWeb as g, json as j, raw as r, stream as s, text as t, uint8Array as u };\n","export { a as Client, T as TypeId, c as catchAll, d as catchTag, e as catchTags, f as fetch, b as fetchOk, g as filterOrElse, h as filterOrFail, i as filterStatus, j as filterStatusOk, l as layer, m as make, k as makeDefault, o as map, p as mapEffect, q as mapRequest, r as mapRequestEffect, s as retry, u as schemaFunction, v as tap, w as tapRequest, t as transform, n as transformResponse } from '../../../dist/Client-4f8f804b.esm.js';\nimport '@effect/schema/Schema';\nimport 'effect/Context';\nimport 'effect/Effect';\nimport 'effect/Function';\nimport 'effect/Layer';\nimport 'effect/Option';\nimport 'effect/Pipeable';\nimport 'effect/Stream';\nimport '../../Method/dist/effect-platform-Http-Method.esm.js';\nimport '../../../dist/UrlParams-1286c728.esm.js';\nimport 'effect/Chunk';\nimport '../../../dist/body-db8cfb3d.esm.js';\nimport 'effect/Data';\nimport '../../../FileSystem/dist/effect-platform-FileSystem.esm.js';\nimport 'effect/Brand';\nimport 'effect/Sink';\nimport '../../../Error/dist/effect-platform-Error.esm.js';\nimport '../../../dist/clientError-c4e1466c.esm.js';\nimport '../../../dist/clientRequest-fe7578cf.esm.js';\nimport '../../../dist/Headers-58b56a08.esm.js';\nimport 'effect/ReadonlyArray';\nimport 'effect/ReadonlyRecord';\nimport '../../../dist/clientResponse-23f1ffca.esm.js';\nimport '../../IncomingMessage/dist/effect-platform-Http-IncomingMessage.esm.js';\nimport '@effect/schema/ParseResult';\nimport 'effect/FiberRef';\nimport 'effect/GlobalValue';\nimport 'effect/Tracer';\n","/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n */\nconst hasBody = method => method !== \"GET\" && method !== \"HEAD\";\n\nexport { hasBody };\n","import * as Chunk from 'effect/Chunk';\nimport * as Effect from 'effect/Effect';\nimport { dual } from 'effect/Function';\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst fromInput = input => {\n  if (Chunk.isChunk(input)) {\n    return input;\n  } else if (Symbol.iterator in input) {\n    return Chunk.fromIterable(input);\n  }\n  return Chunk.fromIterable(Object.entries(input));\n};\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst empty = /*#__PURE__*/Chunk.empty();\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst set = /*#__PURE__*/dual(3, (self, key, value) => Chunk.append(Chunk.filter(self, ([k]) => k !== key), [key, value]));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setAll = /*#__PURE__*/dual(2, (self, input) => {\n  const toSet = fromInput(input);\n  const keys = Chunk.toReadonlyArray(toSet).map(([k]) => k);\n  return Chunk.appendAll(Chunk.filter(self, ([k]) => keys.includes(k)), toSet);\n});\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst append = /*#__PURE__*/dual(3, (self, key, value) => Chunk.append(self, [key, value]));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst appendAll = /*#__PURE__*/dual(2, (self, input) => Chunk.appendAll(self, fromInput(input)));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst remove = /*#__PURE__*/dual(2, (self, key) => Chunk.filter(self, ([k]) => k !== key));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst toString = self => new URLSearchParams(Chunk.toReadonlyArray(self)).toString();\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst makeUrl = (url, params, onError) => Effect.try({\n  try: () => {\n    const urlInstance = new URL(url, baseUrl());\n    Chunk.forEach(params, ([key, value]) => {\n      if (value !== undefined) {\n        urlInstance.searchParams.append(key, value);\n      }\n    });\n    return urlInstance;\n  },\n  catch: onError\n});\nconst baseUrl = () => {\n  if (\"location\" in globalThis) {\n    return location.origin + location.pathname;\n  }\n  return undefined;\n};\n\nvar UrlParams = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  fromInput: fromInput,\n  empty: empty,\n  set: set,\n  setAll: setAll,\n  append: append,\n  appendAll: appendAll,\n  remove: remove,\n  toString: toString,\n  makeUrl: makeUrl\n});\n\nexport { UrlParams as U, append as a, appendAll as b, setAll as c, empty as e, fromInput as f, makeUrl as m, remove as r, set as s, toString as t };\n","import * as Data from 'effect/Data';\n\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/Error\");\nconst make = tag => props => Data.struct({\n  [TypeId]: TypeId,\n  _tag: tag,\n  ...props\n});\n\n/** @internal */\nconst requestError = /*#__PURE__*/make(\"RequestError\");\n\n/** @internal */\nconst responseError = /*#__PURE__*/make(\"ResponseError\");\n\nexport { TypeId as T, responseError as a, requestError as r };\n","import { dual } from 'effect/Function';\nimport * as ReadonlyArray from 'effect/ReadonlyArray';\nimport * as ReadonlyRecord from 'effect/ReadonlyRecord';\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst empty = /*#__PURE__*/ReadonlyRecord.empty();\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst fromInput = input => {\n  if (input === undefined) {\n    return empty;\n  } else if (Symbol.iterator in input) {\n    return ReadonlyRecord.fromEntries(ReadonlyArray.map(ReadonlyArray.fromIterable(input), ([k, v]) => [k.toLowerCase(), v]));\n  }\n  return ReadonlyRecord.fromEntries(Object.entries(input).map(([k, v]) => [k.toLowerCase(), v]));\n};\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst has = /*#__PURE__*/dual(2, (self, key) => ReadonlyRecord.has(self, key.toLowerCase()));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst get = /*#__PURE__*/dual(2, (self, key) => ReadonlyRecord.get(self, key.toLowerCase()));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst set = /*#__PURE__*/dual(3, (self, key, value) => ({\n  ...self,\n  [key.toLowerCase()]: value\n}));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setAll = /*#__PURE__*/dual(2, (self, headers) => ({\n  ...self,\n  ...fromInput(headers)\n}));\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst remove = /*#__PURE__*/dual(2, (self, key) => ReadonlyRecord.remove(self, key.toLowerCase()));\n\nvar Headers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  empty: empty,\n  fromInput: fromInput,\n  has: has,\n  get: get,\n  set: set,\n  setAll: setAll,\n  remove: remove\n});\n\nexport { Headers as H, setAll as a, empty as e, fromInput as f, get as g, has as h, remove as r, set as s };\n","import * as Effect from 'effect/Effect';\nimport { dual } from 'effect/Function';\nimport { pipeArguments } from 'effect/Pipeable';\nimport { s as set, a as setAll, r as remove, e as empty$2 } from './Headers-58b56a08.esm.js';\nimport { a as append, b as appendAll, s as set$1, c as setAll$1, t as toString, f as fromInput, e as empty$1 } from './UrlParams-1286c728.esm.js';\nimport { u as uint8Array, t as text, j as json, a as unsafeJson, c as file, g as fileWeb, b as jsonSchema, f as formData, s as stream, e as empty$3 } from './body-db8cfb3d.esm.js';\n\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/ClientRequest\");\nclass ClientRequestImpl {\n  constructor(method, url, urlParams, headers, body) {\n    this.method = method;\n    this.url = url;\n    this.urlParams = urlParams;\n    this.headers = headers;\n    this.body = body;\n    this[TypeId] = TypeId;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n\n/** @internal */\nconst isClientRequest = u => typeof u === \"object\" && u !== null && TypeId in u;\n\n/** @internal */\nconst empty = /*#__PURE__*/new ClientRequestImpl(\"GET\", \"\", empty$1, empty$2, empty$3);\n\n/** @internal */\nconst make = method => (url, options) => modify(empty, {\n  method,\n  url,\n  ...(options ?? {})\n});\n\n/** @internal */\nconst get = /*#__PURE__*/make(\"GET\");\n\n/** @internal */\nconst post = /*#__PURE__*/make(\"POST\");\n\n/** @internal */\nconst put = /*#__PURE__*/make(\"PUT\");\n\n/** @internal */\nconst patch = /*#__PURE__*/make(\"PATCH\");\n\n/** @internal */\nconst del = /*#__PURE__*/make(\"DELETE\");\n\n/** @internal */\nconst head = /*#__PURE__*/make(\"HEAD\");\n\n/** @internal */\nconst options = /*#__PURE__*/make(\"OPTIONS\");\n\n/** @internal */\nconst modify = /*#__PURE__*/dual(2, (self, options) => {\n  let result = self;\n  if (options.method) {\n    result = setMethod(result, options.method);\n  }\n  if (options.url) {\n    result = setUrl(result, options.url);\n  }\n  if (options.headers) {\n    result = setHeaders(result, options.headers);\n  }\n  if (options.urlParams) {\n    result = setUrlParams(result, options.urlParams);\n  }\n  if (options.body) {\n    result = setBody(result, options.body);\n  }\n  if (options.accept) {\n    result = accept(result, options.accept);\n  }\n  if (options.acceptJson) {\n    result = acceptJson(result);\n  }\n  return result;\n});\n\n/** @internal */\nconst setHeader = /*#__PURE__*/dual(3, (self, key, value) => new ClientRequestImpl(self.method, self.url, self.urlParams, set(self.headers, key, value), self.body));\n\n/** @internal */\nconst setHeaders = /*#__PURE__*/dual(2, (self, input) => new ClientRequestImpl(self.method, self.url, self.urlParams, setAll(self.headers, input), self.body));\n\n/** @internal */\nconst basicAuth = /*#__PURE__*/dual(3, (self, username, password) => setHeader(self, \"Authorization\", `Basic ${btoa(`${username}:${password}`)}`));\n\n/** @internal */\nconst bearerToken = /*#__PURE__*/dual(2, (self, token) => setHeader(self, \"Authorization\", `Bearer ${token}`));\n\n/** @internal */\nconst accept = /*#__PURE__*/dual(2, (self, mediaType) => setHeader(self, \"Accept\", mediaType));\n\n/** @internal */\nconst acceptJson = /*#__PURE__*/accept(\"application/json\");\n\n/** @internal */\nconst setMethod = /*#__PURE__*/dual(2, (self, method) => new ClientRequestImpl(method, self.url, self.urlParams, self.headers, self.body));\n\n/** @internal */\nconst setUrl = /*#__PURE__*/dual(2, (self, url) => new ClientRequestImpl(self.method, url, self.urlParams, self.headers, self.body));\n\n/** @internal */\nconst appendUrl = /*#__PURE__*/dual(2, (self, url) => new ClientRequestImpl(self.method, self.url + url, self.urlParams, self.headers, self.body));\n\n/** @internal */\nconst prependUrl = /*#__PURE__*/dual(2, (self, url) => new ClientRequestImpl(self.method, url + self.url, self.urlParams, self.headers, self.body));\n\n/** @internal */\nconst updateUrl = /*#__PURE__*/dual(2, (self, f) => new ClientRequestImpl(self.method, f(self.url), self.urlParams, self.headers, self.body));\n\n/** @internal */\nconst appendUrlParam = /*#__PURE__*/dual(3, (self, key, value) => new ClientRequestImpl(self.method, self.url, append(self.urlParams, key, value), self.headers, self.body));\n\n/** @internal */\nconst appendUrlParams = /*#__PURE__*/dual(2, (self, input) => new ClientRequestImpl(self.method, self.url, appendAll(self.urlParams, input), self.headers, self.body));\n\n/** @internal */\nconst setUrlParam = /*#__PURE__*/dual(3, (self, key, value) => new ClientRequestImpl(self.method, self.url, set$1(self.urlParams, key, value), self.headers, self.body));\n\n/** @internal */\nconst setUrlParams = /*#__PURE__*/dual(2, (self, input) => new ClientRequestImpl(self.method, self.url, setAll$1(self.urlParams, input), self.headers, self.body));\n\n/** @internal */\nconst setBody = /*#__PURE__*/dual(2, (self, body) => {\n  let headers = self.headers;\n  if (body._tag === \"Empty\") {\n    headers = remove(remove(headers, \"Content-Type\"), \"Content-length\");\n  } else {\n    const contentType = body.contentType;\n    if (contentType) {\n      headers = set(headers, \"content-type\", contentType);\n    }\n    const contentLength = body.contentLength;\n    if (contentLength) {\n      headers = set(headers, \"content-length\", contentLength.toString());\n    }\n  }\n  return new ClientRequestImpl(self.method, self.url, self.urlParams, headers, body);\n});\n\n/** @internal */\nconst uint8ArrayBody = /*#__PURE__*/dual(args => isClientRequest(args[0]), (self, body, contentType = \"application/octet-stream\") => setBody(self, uint8Array(body, contentType)));\n\n/** @internal */\nconst textBody = /*#__PURE__*/dual(args => isClientRequest(args[0]), (self, body, contentType = \"text/plain\") => setBody(self, text(body, contentType)));\n\n/** @internal */\nconst jsonBody = /*#__PURE__*/dual(2, (self, body) => Effect.map(json(body), body => setBody(self, body)));\n\n/** @internal */\nconst unsafeJsonBody = /*#__PURE__*/dual(2, (self, body) => setBody(self, unsafeJson(body)));\n\n/** @internal */\nconst fileBody = /*#__PURE__*/dual(args => isClientRequest(args[0]), (self, path, options) => Effect.map(file(path, options), body => setBody(self, body)));\n\n/** @internal */\nconst fileWebBody = /*#__PURE__*/dual(2, (self, file) => setBody(self, fileWeb(file)));\n\n/** @internal */\nconst schemaBody = schema => {\n  const encode = jsonSchema(schema);\n  return dual(2, (self, body) => Effect.map(encode(body), body => setBody(self, body)));\n};\n\n/** @internal */\nconst urlParamsBody = /*#__PURE__*/dual(2, (self, body) => setBody(self, text(toString(fromInput(body)), \"application/x-www-form-urlencoded\")));\n\n/** @internal */\nconst formDataBody = /*#__PURE__*/dual(2, (self, body) => setBody(self, formData(body)));\n\n/** @internal */\nconst streamBody = /*#__PURE__*/dual(args => isClientRequest(args[0]), (self, body, {\n  contentLength,\n  contentType = \"application/octet-stream\"\n} = {}) => setBody(self, stream(body, contentType, contentLength)));\n\nexport { textBody as A, jsonBody as B, unsafeJsonBody as C, schemaBody as D, urlParamsBody as E, formDataBody as F, streamBody as G, fileBody as H, fileWebBody as I, setHeader as a, patch as b, put as c, del as d, modify as e, setMethod as f, get as g, head as h, setHeaders as i, basicAuth as j, bearerToken as k, accept as l, make as m, acceptJson as n, options as o, post as p, setUrl as q, prependUrl as r, setBody as s, appendUrl as t, updateUrl as u, setUrlParam as v, setUrlParams as w, appendUrlParam as x, appendUrlParams as y, uint8ArrayBody as z };\n","import * as ParseResult from '@effect/schema/ParseResult';\nimport * as Schema from '@effect/schema/Schema';\nimport * as Effect from 'effect/Effect';\nimport * as FiberRef from 'effect/FiberRef';\nimport { flow, dual } from 'effect/Function';\nimport * as Global from 'effect/GlobalValue';\nimport * as Option from 'effect/Option';\nimport * as Tracer from 'effect/Tracer';\nimport { Size } from '../../../FileSystem/dist/effect-platform-FileSystem.esm.js';\nimport 'effect/Brand';\nimport 'effect/Context';\nimport 'effect/Sink';\nimport 'effect/Stream';\nimport '../../../Error/dist/effect-platform-Error.esm.js';\nimport 'effect/Data';\n\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n * @category type ids\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/IncomingMessage\");\n\n/**\n * @since 1.0.0\n * @category type ids\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaBodyJson = schema => {\n  const parse = Schema.parse(schema);\n  return self => Effect.flatMap(self.json, parse);\n};\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaBodyUrlParams = schema => {\n  const parse = Schema.parse(schema);\n  return self => Effect.flatMap(self.urlParamsBody, _ => parse(Object.fromEntries(_)));\n};\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaHeaders = schema => {\n  const parse = Schema.parse(schema);\n  return self => parse(self.headers);\n};\nconst SpanSchema = /*#__PURE__*/Schema.struct({\n  traceId: Schema.string,\n  spanId: Schema.string,\n  parentSpanId: /*#__PURE__*/Schema.union(Schema.string, Schema.undefined),\n  sampled: Schema.boolean\n});\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaExternalSpan = /*#__PURE__*/flow( /*#__PURE__*/schemaHeaders( /*#__PURE__*/Schema.union( /*#__PURE__*/Schema.transformOrFail( /*#__PURE__*/Schema.struct({\n  b3: Schema.NonEmpty\n}), SpanSchema, _ => {\n  const parts = _.b3.split(\"-\");\n  if (parts.length >= 2) {\n    return ParseResult.success({\n      traceId: parts[0],\n      spanId: parts[1],\n      sampled: parts[2] ? parts[2] === \"1\" : true,\n      parentSpanId: parts[3]\n    });\n  }\n  return ParseResult.failure(ParseResult.missing);\n}, _ => ParseResult.success(\"\")), /*#__PURE__*/Schema.transform( /*#__PURE__*/Schema.struct({\n  \"x-b3-traceid\": Schema.NonEmpty,\n  \"x-b3-spanid\": Schema.NonEmpty,\n  \"x-b3-parentspanid\": /*#__PURE__*/Schema.optional(Schema.NonEmpty),\n  \"x-b3-sampled\": /*#__PURE__*/Schema.optional(Schema.NonEmpty).withDefault(() => \"1\")\n}), SpanSchema, _ => ({\n  traceId: _[\"x-b3-traceid\"],\n  spanId: _[\"x-b3-spanid\"],\n  parentSpanId: _[\"x-b3-parentspanid\"],\n  sampled: _[\"x-b3-sampled\"] === \"1\"\n}), _ => ({\n  \"x-b3-traceid\": _.traceId,\n  \"x-b3-spanid\": _.spanId,\n  \"x-b3-parentspanid\": _.parentSpanId,\n  \"x-b3-sampled\": _.sampled ? \"1\" : \"0\"\n})))), /*#__PURE__*/Effect.map(_ => Tracer.externalSpan({\n  traceId: _.traceId,\n  spanId: _.spanId,\n  sampled: _.sampled\n})));\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nconst maxBodySize = /*#__PURE__*/Global.globalValue(\"@effect/platform/Http/ImcomingMessage/maxBodySize\", () => FiberRef.unsafeMake(Option.none()));\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nconst withMaxBodySize = /*#__PURE__*/dual(2, (effect, size) => Effect.locally(effect, maxBodySize, Option.map(size, Size)));\n\nexport { TypeId, maxBodySize, schemaBodyJson, schemaBodyUrlParams, schemaExternalSpan, schemaHeaders, withMaxBodySize };\n","import * as Schema from '@effect/schema/Schema';\nimport * as Effect from 'effect/Effect';\nimport * as Option from 'effect/Option';\nimport * as Stream from 'effect/Stream';\nimport { f as fromInput } from './Headers-58b56a08.esm.js';\nimport { TypeId as TypeId$1 } from '../Http/IncomingMessage/dist/effect-platform-Http-IncomingMessage.esm.js';\nimport { f as fromInput$1 } from './UrlParams-1286c728.esm.js';\nimport { a as responseError } from './clientError-c4e1466c.esm.js';\n\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/ClientResponse\");\n\n/** @internal */\nconst fromWeb = (request, source) => new ClientResponseImpl(request, source);\nclass ClientResponseImpl {\n  constructor(request, source) {\n    this.request = request;\n    this.source = source;\n    this[TypeId$1] = TypeId$1;\n    this[TypeId] = TypeId;\n  }\n  get status() {\n    return this.source.status;\n  }\n  get headers() {\n    return fromInput(this.source.headers);\n  }\n  get remoteAddress() {\n    return Option.none();\n  }\n  get stream() {\n    return this.source.body ? Stream.fromReadableStream(() => this.source.body, _ => responseError({\n      request: this.request,\n      response: this,\n      reason: \"Decode\",\n      error: _\n    })) : Stream.fail(responseError({\n      request: this.request,\n      response: this,\n      reason: \"EmptyBody\",\n      error: \"can not create stream from empty body\"\n    }));\n  }\n  get json() {\n    return Effect.tryMap(this.text, {\n      try: text => text === \"\" ? null : JSON.parse(text),\n      catch: _ => responseError({\n        request: this.request,\n        response: this,\n        reason: \"Decode\",\n        error: _\n      })\n    });\n  }\n  get text() {\n    return Effect.tryPromise({\n      try: () => this.source.text(),\n      catch: _ => responseError({\n        request: this.request,\n        response: this,\n        reason: \"Decode\",\n        error: _\n      })\n    });\n  }\n  get urlParamsBody() {\n    return Effect.flatMap(this.text, _ => Effect.try({\n      try: () => fromInput$1(new URLSearchParams(_)),\n      catch: _ => responseError({\n        request: this.request,\n        response: this,\n        reason: \"Decode\",\n        error: _\n      })\n    }));\n  }\n  get formData() {\n    return Effect.tryPromise({\n      try: () => this.source.formData(),\n      catch: _ => responseError({\n        request: this.request,\n        response: this,\n        reason: \"Decode\",\n        error: _\n      })\n    });\n  }\n  get arrayBuffer() {\n    return Effect.tryPromise({\n      try: () => this.source.arrayBuffer(),\n      catch: _ => responseError({\n        request: this.request,\n        response: this,\n        reason: \"Decode\",\n        error: _\n      })\n    });\n  }\n}\n\n/** @internal */\nconst schemaJson = schema => {\n  const parse = Schema.parse(schema);\n  return self => Effect.flatMap(self.json, body => parse({\n    status: self.status,\n    headers: self.headers,\n    body\n  }));\n};\n\n/** @internal */\nconst schemaNoBody = schema => {\n  const parse = Schema.parse(schema);\n  return self => parse({\n    status: self.status,\n    headers: self.headers\n  });\n};\n\nexport { TypeId as T, schemaNoBody as a, fromWeb as f, schemaJson as s };\n","import * as Schema from '@effect/schema/Schema';\nimport * as Context from 'effect/Context';\nimport * as Effect from 'effect/Effect';\nimport { dual } from 'effect/Function';\nimport * as Layer from 'effect/Layer';\nimport * as Option from 'effect/Option';\nimport { pipeArguments } from 'effect/Pipeable';\nimport * as Stream from 'effect/Stream';\nimport { hasBody } from '../Http/Method/dist/effect-platform-Http-Method.esm.js';\nimport { m as makeUrl } from './UrlParams-1286c728.esm.js';\nimport { u as uint8Array } from './body-db8cfb3d.esm.js';\nimport { r as requestError, a as responseError } from './clientError-c4e1466c.esm.js';\nimport { s as setBody, a as setHeader } from './clientRequest-fe7578cf.esm.js';\nimport { f as fromWeb } from './clientResponse-23f1ffca.esm.js';\n\n/** @internal */\nconst TypeId$1 = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/Client\");\n\n/** @internal */\nconst tag = /*#__PURE__*/Context.Tag(TypeId$1);\nconst clientProto = {\n  [TypeId$1]: TypeId$1,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n\n/** @internal */\nconst make$1 = f => {\n  Object.setPrototypeOf(f, clientProto);\n  return f;\n};\nconst withB3Propagation = self => make$1(req => Effect.flatMap(Effect.map(Effect.currentSpan, Option.match({\n  onNone: () => req,\n  onSome: span => setHeader(req, \"b3\", `${span.traceId}-${span.spanId}-${span.sampled ? \"1\" : \"0\"}${span.parent._tag === \"Some\" ? `-${span.parent.value.spanId}` : \"\"}`)\n})), self));\n\n/** @internal */\nconst makeDefault$1 = f => withB3Propagation(make$1(f));\n\n/** @internal */\nconst fetch$1 = (options = {}) => makeDefault$1(request => Effect.flatMap(makeUrl(request.url, request.urlParams, _ => requestError({\n  request,\n  reason: \"InvalidUrl\",\n  error: _\n})), url => Effect.suspend(() => {\n  const headers = new Headers(request.headers);\n  const send = body => Effect.map(Effect.tryPromise({\n    try: signal => globalThis.fetch(url, {\n      ...options,\n      method: request.method,\n      headers,\n      body,\n      signal\n    }),\n    catch: _ => requestError({\n      request,\n      reason: \"Transport\",\n      error: _\n    })\n  }), _ => fromWeb(request, _));\n  if (hasBody(request.method)) {\n    return send(convertBody(request.body));\n  }\n  return send(undefined);\n})));\nconst convertBody = body => {\n  switch (body._tag) {\n    case \"Empty\":\n      return undefined;\n    case \"Raw\":\n      return body.body;\n    case \"Uint8Array\":\n      return body.body;\n    case \"FormData\":\n      return body.formData;\n    case \"Stream\":\n      return Stream.toReadableStream(body.stream);\n  }\n};\n\n/** @internal */\nconst fetchOk$1 = (options = {}) => filterStatusOk$1(fetch$1(options));\n\n/** @internal */\nconst layer$1 = /*#__PURE__*/Layer.succeed(tag, /*#__PURE__*/fetch$1());\n\n/** @internal */\nconst transform$1 = /*#__PURE__*/dual(2, (self, f) => make$1(f(self)));\n\n/** @internal */\nconst transformResponse$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => f(self(request))));\n\n/** @internal */\nconst catchTag$1 = /*#__PURE__*/dual(3, (self, tag, f) => make$1(request => Effect.catchTag(self(request), tag, f)));\n\n/** @internal */\nconst catchTags$1 = /*#__PURE__*/dual(2, (self, cases) => make$1(request => Effect.catchTags(self(request), cases)));\n\n/** @internal */\nconst catchAll$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.catchAll(self(request), f)));\n\n/** @internal */\nconst filterOrElse$1 = /*#__PURE__*/dual(3, (self, f, orElse) => make$1(request => Effect.filterOrElse(self(request), f, orElse)));\n\n/** @internal */\nconst filterOrFail$1 = /*#__PURE__*/dual(3, (self, f, orFailWith) => make$1(request => Effect.filterOrFail(self(request), f, orFailWith)));\n\n/** @internal */\nconst filterStatus$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.filterOrFail(self(request), response => f(response.status), response => responseError({\n  request,\n  response,\n  reason: \"StatusCode\",\n  error: \"non 2xx status code\"\n}))));\n\n/** @internal */\nconst filterStatusOk$1 = /*#__PURE__*/filterStatus$1(status => status >= 200 && status < 300);\n\n/** @internal */\nconst map$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.map(self(request), f)));\n\n/** @internal */\nconst mapEffect$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.flatMap(self(request), f)));\n\n/** @internal */\nconst mapRequest$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => self(f(request))));\n\n/** @internal */\nconst mapRequestEffect$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.flatMap(f(request), self)));\n\n/** @internal */\nconst retry$1 = /*#__PURE__*/dual(2, (self, policy) => make$1(request => Effect.retry(self(request), policy)));\n\n/** @internal */\nconst schemaFunction$1 = /*#__PURE__*/dual(2, (self, schema) => {\n  const encode = Schema.encode(schema);\n  return request => a => Effect.flatMap(Effect.tryMap(encode(a), {\n    try: body => new TextEncoder().encode(JSON.stringify(body)),\n    catch: error => requestError({\n      request,\n      reason: \"Encode\",\n      error\n    })\n  }), body => self(setBody(request, uint8Array(body, \"application/json\"))));\n});\n\n/** @internal */\nconst tap$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.tap(self(request), f)));\n\n/** @internal */\nconst tapRequest$1 = /*#__PURE__*/dual(2, (self, f) => make$1(request => Effect.zipRight(f(request), self(request))));\n\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n * @category type ids\n */\nconst TypeId = TypeId$1;\n\n/**\n * @since 1.0.0\n * @category type ids\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category tags\n */\nconst Client = tag;\n\n/**\n * @since 1.0.0\n * @category layers\n */\nconst layer = layer$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst fetch = fetch$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst fetchOk = fetchOk$1;\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nconst catchAll = catchAll$1;\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nconst catchTag = catchTag$1;\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nconst catchTags = catchTags$1;\n\n/**\n * @since 1.0.0\n * @category filters\n */\nconst filterOrElse = filterOrElse$1;\n\n/**\n * @since 1.0.0\n * @category filters\n */\nconst filterOrFail = filterOrFail$1;\n\n/**\n * @since 1.0.0\n * @category filters\n */\nconst filterStatus = filterStatus$1;\n\n/**\n * @since 1.0.0\n * @category filters\n */\nconst filterStatusOk = filterStatusOk$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst makeDefault = makeDefault$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst transform = transform$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst transformResponse = transformResponse$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst map = map$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst mapEffect = mapEffect$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst mapRequest = mapRequest$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst mapRequestEffect = mapRequestEffect$1;\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nconst retry = retry$1;\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaFunction = schemaFunction$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst tap = tap$1;\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nconst tapRequest = tapRequest$1;\n\nvar Client$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TypeId: TypeId,\n  Client: Client,\n  layer: layer,\n  fetch: fetch,\n  fetchOk: fetchOk,\n  catchAll: catchAll,\n  catchTag: catchTag,\n  catchTags: catchTags,\n  filterOrElse: filterOrElse,\n  filterOrFail: filterOrFail,\n  filterStatus: filterStatus,\n  filterStatusOk: filterStatusOk,\n  make: make,\n  makeDefault: makeDefault,\n  transform: transform,\n  transformResponse: transformResponse,\n  map: map,\n  mapEffect: mapEffect,\n  mapRequest: mapRequest,\n  mapRequestEffect: mapRequestEffect,\n  retry: retry,\n  schemaFunction: schemaFunction,\n  tap: tap,\n  tapRequest: tapRequest\n});\n\nexport { Client$1 as C, TypeId as T, Client as a, fetchOk as b, catchAll as c, catchTag as d, catchTags as e, fetch as f, filterOrElse as g, filterOrFail as h, filterStatus as i, filterStatusOk as j, makeDefault as k, layer as l, make as m, transformResponse as n, map as o, mapEffect as p, mapRequest as q, mapRequestEffect as r, retry as s, transform as t, schemaFunction as u, tap as v, tapRequest as w };\n","import '../../../dist/clientRequest-fe7578cf.esm.js';\nexport { T as TypeId, k as accept, l as acceptJson, r as appendUrl, w as appendUrlParam, x as appendUrlParams, i as basicAuth, j as bearerToken, d as del, I as fileBody, J as fileWebBody, G as formDataBody, g as get, h as head, B as jsonBody, m as make, c as modify, o as options, a as patch, p as post, q as prependUrl, b as put, E as schemaBody, y as setBody, e as setHeader, f as setHeaders, s as setMethod, n as setUrl, t as setUrlParam, v as setUrlParams, H as streamBody, A as textBody, z as uint8ArrayBody, D as unsafeJsonBody, u as updateUrl, F as urlParamsBody } from '../../../dist/ClientRequest-27630c54.esm.js';\nimport 'effect/Effect';\nimport 'effect/Function';\nimport 'effect/Pipeable';\nimport '../../../dist/Headers-58b56a08.esm.js';\nimport 'effect/ReadonlyArray';\nimport 'effect/ReadonlyRecord';\nimport '../../../dist/UrlParams-1286c728.esm.js';\nimport 'effect/Chunk';\nimport '../../../dist/body-db8cfb3d.esm.js';\nimport '@effect/schema/Schema';\nimport 'effect/Data';\nimport 'effect/Stream';\nimport '../../../FileSystem/dist/effect-platform-FileSystem.esm.js';\nimport 'effect/Brand';\nimport 'effect/Context';\nimport 'effect/Option';\nimport 'effect/Sink';\nimport '../../../Error/dist/effect-platform-Error.esm.js';\n","import { m as make$1, g as get$1, p as post$1, b as patch$1, c as put$1, d as del$1, h as head$1, o as options$1, e as modify$1, f as setMethod$1, a as setHeader$1, i as setHeaders$1, j as basicAuth$1, k as bearerToken$1, l as accept$1, n as acceptJson$1, q as setUrl$1, r as prependUrl$1, t as appendUrl$1, u as updateUrl$1, v as setUrlParam$1, w as setUrlParams$1, x as appendUrlParam$1, y as appendUrlParams$1, s as setBody$1, z as uint8ArrayBody$1, A as textBody$1, B as jsonBody$1, C as unsafeJsonBody$1, D as schemaBody$1, E as urlParamsBody$1, F as formDataBody$1, G as streamBody$1, H as fileBody$1, I as fileWebBody$1 } from './clientRequest-fe7578cf.esm.js';\n\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n * @category type ids\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Http/ClientRequest\");\n\n/**\n * @since 1.0.0\n * @category type ids\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst make = make$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst get = get$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst post = post$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst patch = patch$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst put = put$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst del = del$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst head = head$1;\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst options = options$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst modify = modify$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setMethod = setMethod$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setHeader = setHeader$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setHeaders = setHeaders$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst basicAuth = basicAuth$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst bearerToken = bearerToken$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst accept = accept$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst acceptJson = acceptJson$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setUrl = setUrl$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst prependUrl = prependUrl$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst appendUrl = appendUrl$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst updateUrl = updateUrl$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setUrlParam = setUrlParam$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setUrlParams = setUrlParams$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst appendUrlParam = appendUrlParam$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst appendUrlParams = appendUrlParams$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst setBody = setBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst uint8ArrayBody = uint8ArrayBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst textBody = textBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst jsonBody = jsonBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst unsafeJsonBody = unsafeJsonBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst schemaBody = schemaBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst urlParamsBody = urlParamsBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst formDataBody = formDataBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst streamBody = streamBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst fileBody = fileBody$1;\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nconst fileWebBody = fileWebBody$1;\n\nvar ClientRequest = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TypeId: TypeId,\n  make: make,\n  get: get,\n  post: post,\n  patch: patch,\n  put: put,\n  del: del,\n  head: head,\n  options: options,\n  modify: modify,\n  setMethod: setMethod,\n  setHeader: setHeader,\n  setHeaders: setHeaders,\n  basicAuth: basicAuth,\n  bearerToken: bearerToken,\n  accept: accept,\n  acceptJson: acceptJson,\n  setUrl: setUrl,\n  prependUrl: prependUrl,\n  appendUrl: appendUrl,\n  updateUrl: updateUrl,\n  setUrlParam: setUrlParam,\n  setUrlParams: setUrlParams,\n  appendUrlParam: appendUrlParam,\n  appendUrlParams: appendUrlParams,\n  setBody: setBody,\n  uint8ArrayBody: uint8ArrayBody,\n  textBody: textBody,\n  jsonBody: jsonBody,\n  unsafeJsonBody: unsafeJsonBody,\n  schemaBody: schemaBody,\n  urlParamsBody: urlParamsBody,\n  formDataBody: formDataBody,\n  streamBody: streamBody,\n  fileBody: fileBody,\n  fileWebBody: fileWebBody\n});\n\nexport { textBody as A, jsonBody as B, ClientRequest as C, unsafeJsonBody as D, schemaBody as E, urlParamsBody as F, formDataBody as G, streamBody as H, fileBody as I, fileWebBody as J, TypeId as T, patch as a, put as b, modify as c, del as d, setHeader as e, setHeaders as f, get as g, head as h, basicAuth as i, bearerToken as j, accept as k, acceptJson as l, make as m, setUrl as n, options as o, post as p, prependUrl as q, appendUrl as r, setMethod as s, setUrlParam as t, updateUrl as u, setUrlParams as v, appendUrlParam as w, appendUrlParams as x, setBody as y, uint8ArrayBody as z };\n","import '../../../dist/clientResponse-23f1ffca.esm.js';\nexport { schemaBodyJson, schemaBodyUrlParams, schemaHeaders } from '../../IncomingMessage/dist/effect-platform-Http-IncomingMessage.esm.js';\nexport { T as TypeId, f as fromWeb, s as schemaJson, a as schemaNoBody } from '../../../dist/ClientResponse-862f0a17.esm.js';\nimport '@effect/schema/Schema';\nimport 'effect/Effect';\nimport 'effect/Option';\nimport 'effect/Stream';\nimport '../../../dist/Headers-58b56a08.esm.js';\nimport 'effect/Function';\nimport 'effect/ReadonlyArray';\nimport 'effect/ReadonlyRecord';\nimport '../../../dist/UrlParams-1286c728.esm.js';\nimport 'effect/Chunk';\nimport '../../../dist/clientError-c4e1466c.esm.js';\nimport 'effect/Data';\nimport '@effect/schema/ParseResult';\nimport 'effect/FiberRef';\nimport 'effect/GlobalValue';\nimport 'effect/Tracer';\nimport '../../../FileSystem/dist/effect-platform-FileSystem.esm.js';\nimport 'effect/Brand';\nimport 'effect/Context';\nimport 'effect/Sink';\nimport '../../../Error/dist/effect-platform-Error.esm.js';\n","import { T as TypeId$1, f as fromWeb$1, s as schemaJson$1, a as schemaNoBody$1 } from './clientResponse-23f1ffca.esm.js';\nimport { schemaBodyJson, schemaBodyUrlParams, schemaHeaders } from '../Http/IncomingMessage/dist/effect-platform-Http-IncomingMessage.esm.js';\n\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nconst TypeId = TypeId$1;\n\n/**\n * @since 1.0.0\n * @category type ids\n */\n\n/**\n * @since 1.0.0\n * @category models\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst fromWeb = fromWeb$1;\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaJson = schemaJson$1;\n\n/**\n * @since 1.0.0\n * @category schema\n */\nconst schemaNoBody = schemaNoBody$1;\n\nvar ClientResponse = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TypeId: TypeId,\n  fromWeb: fromWeb,\n  schemaJson: schemaJson,\n  schemaNoBody: schemaNoBody,\n  schemaBodyJson: schemaBodyJson,\n  schemaBodyUrlParams: schemaBodyUrlParams,\n  schemaHeaders: schemaHeaders\n});\n\nexport { ClientResponse as C, TypeId as T, schemaNoBody as a, fromWeb as f, schemaJson as s };\n","import * as Body from '@effect/platform/Http/Body';\nexport { Body as body };\nimport * as Client from '@effect/platform/Http/Client';\nexport { Client as client };\nimport * as Error from '@effect/platform/Http/ClientError';\nexport { Error as error };\nimport * as ClientRequest from '@effect/platform/Http/ClientRequest';\nexport { ClientRequest as request };\nimport * as ClientResponse from '@effect/platform/Http/ClientResponse';\nexport { ClientResponse as response };\nimport * as Headers from '@effect/platform/Http/Headers';\nexport { Headers as headers };\nimport * as UrlParams from '@effect/platform/Http/UrlParams';\nexport { UrlParams as urlParams };\nexport { N as nodeClient } from '../../dist/NodeClient-25aa9b30.esm.js';\nimport 'effect/Context';\nimport 'effect/Effect';\nimport 'effect/Function';\nimport 'effect/Layer';\nimport 'effect/Stream';\nimport 'node:http';\nimport 'node:https';\nimport 'node:stream';\nimport 'node:stream/promises';\nimport '../../Sink/dist/effect-platform-node-Sink.esm.js';\nimport '../../dist/sink-f4bcb905.esm.js';\nimport 'effect/Channel';\nimport 'effect/Deferred';\nimport 'effect/Sink';\nimport '../../dist/stream-faaffb40.esm.js';\nimport 'effect/Chunk';\nimport 'effect/Either';\nimport 'effect/Exit';\nimport 'effect/Queue';\nimport '@effect/platform/Error';\nimport '../../dist/incomingMessage-a56317f6.esm.js';\nimport '@effect/platform/Http/IncomingMessage';\nimport 'effect/FiberRef';\nimport 'effect/Option';\nimport '../../Stream/dist/effect-platform-node-Stream.esm.js';\n","import * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as Layer from \"effect/Layer\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Scope from \"effect/Scope\"\n\n/** @internal */\nexport function RuntimeClass<Args extends Array<any>, RE, R>(\n  layer: (...args: Args) => Layer.Layer<never, RE, R>,\n) {\n  return class {\n    #scope = Effect.runSync(Scope.make())\n    #runtime: Effect.Effect<never, RE, Runtime.Runtime<R>>\n\n    constructor(...args: Args) {\n      this.#runtime = Effect.runSync(\n        Effect.cached(\n          Layer.toRuntime(layer(...args)).pipe(Scope.extend(this.#scope)),\n        ),\n      )\n    }\n\n    close(): Promise<void> {\n      return Effect.runPromise(Scope.close(this.#scope, Exit.unit))\n    }\n\n    [Symbol.asyncDispose]() {\n      return this.close()\n    }\n\n    [Symbol.dispose]() {\n      this.close()\n    }\n\n    $effect<E, A>(effect: Effect.Effect<R, E, A>): Promise<A> {\n      return Effect.runPromise(\n        Effect.flatMap(this.#runtime, runtime =>\n          Effect.provide(effect, runtime),\n        ),\n      )\n    }\n\n    $effectFn<F extends (...args: Array<any>) => Effect.Effect<R, any, any>>(\n      fn: F,\n    ): (\n      ...args: Parameters<F>\n    ) => Promise<Effect.Effect.Success<ReturnType<F>>> {\n      return (...args) => this.$effect(fn(...args))\n    }\n\n    $service<I extends R, S, A>(\n      tag: Context.Tag<I, S>,\n      fn: (service: S) => Effect.Effect<R, unknown, A>,\n    ): () => Promise<A> {\n      return () => this.$effect(Effect.flatMap(tag, _ => fn(_)))\n    }\n\n    $serviceFn<\n      I extends R,\n      S,\n      F extends (...args: Array<any>) => Effect.Effect<R, any, any>,\n    >(\n      tag: Context.Tag<I, S>,\n      fn: (service: S) => F,\n    ): (\n      ...args: Parameters<F>\n    ) => Promise<Effect.Effect.Success<ReturnType<F>>> {\n      return (...args) => this.$effect(Effect.flatMap(tag, _ => fn(_)(args)))\n    }\n  }\n}\n","import * as Http from \"@effect/platform-node/HttpClient\"\nimport * as Schema from \"@effect/schema/Schema\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { flow, identity } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport { Model, OpenAIClient, OpenAIConfig } from \"..\"\nimport { RuntimeClass } from \"./RuntimeClass\"\n\nconst make = (config: OpenAIConfig) =>\n  Effect.gen(function* (_) {\n    const client = (yield* _(Http.client.Client)).pipe(\n      Http.client.mapRequest(\n        flow(\n          Http.request.prependUrl(\"https://api.openai.com/v1\"),\n          Http.request.bearerToken(config.apiKey),\n          config.organization\n            ? Http.request.setHeader(\"OpenAI-Organization\", config.organization)\n            : identity,\n        ),\n      ),\n      Http.client.filterStatusOk,\n    )\n\n    const models = Http.request.get(\"/models\").pipe(\n      client,\n      Effect.flatMap(Http.response.schemaBodyJson(ListResult(ModelSchema))),\n      Effect.map(_ => _.data),\n    )\n\n    return { models } as const\n  })\n\ninterface OpenAI extends Effect.Effect.Success<ReturnType<typeof make>> {}\nconst OpenAI = Context.Tag<OpenAI>(\"openai-demo/OpenAI\")\nconst OpenAILive = (config: OpenAIConfig) =>\n  Layer.effect(OpenAI, make(config)).pipe(Layer.use(Http.client.layer))\n\n// client\n\nclass OpenAIClientImpl\n  extends RuntimeClass(OpenAILive)\n  implements OpenAIClient\n{\n  constructor(config: OpenAIConfig) {\n    super(config)\n  }\n  models: () => Promise<ReadonlyArray<Model>> = this.$service(\n    OpenAI,\n    _ => _.models,\n  )\n}\n\nexport const createClient = (config: OpenAIConfig): OpenAIClient =>\n  new OpenAIClientImpl(config)\n\n// schemas\n\nconst DateFromUnixTime = Schema.Int.pipe(\n  Schema.transform(\n    Schema.DateFromSelf,\n    _ => new Date(_ * 1000),\n    _ => Math.floor(_.getTime() / 1000),\n  ),\n)\n\nconst ListResult = <I, A>(schema: Schema.Schema<I, A>) =>\n  Schema.struct({\n    object: Schema.string,\n    data: Schema.array(schema),\n    has_more: Schema.optional(Schema.boolean).withDefault(() => false),\n  })\n\nclass ModelSchema\n  extends Schema.Class<ModelSchema>()({\n    id: Schema.string,\n    object: Schema.string,\n    created: DateFromUnixTime,\n    owned_by: Schema.string,\n    root: Schema.string,\n    parent: Schema.nullable(Schema.string),\n  })\n  implements Model {}\n","import * as internal from \"./internal/OpenAi\"\n\nexport interface OpenAIConfig {\n  readonly apiKey: string\n  readonly organization?: string\n}\n\nexport interface OpenAIClient {\n  models(): Promise<ReadonlyArray<Model>>\n}\n\nexport const createClient: (config: OpenAIConfig) => OpenAIClient =\n  internal.createClient\n\nexport interface Model {\n  readonly object: string\n  readonly id: string\n  readonly created: Date\n  readonly owned_by: string\n  readonly root: string\n  readonly parent: string | null\n}\n"]}